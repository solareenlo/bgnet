[{"id":0,"href":"/bgnet/docs/intro/","title":"1 Intro","section":"Docs","content":"1 Intro #  おいおい、ソケットプログラミングで参ってるのか？このようなことは man ページから理解するには少し難しすぎるのではありませんか？クールなインターネットプログラミングをしたいけど、connect() の前に bind() を呼ばないといけないのか、などなど、struct のゴブをかき分けている時間はないでしょう。\nさて、どうでしょう！？私はもうこの厄介なビジネスをやり遂げました。そして、この情報をみんなと共有したくてたまらないのです! あなたは正しい場所に来たのです。この文書は、平均的な有能なCプログラマーが、このネットワーク・ノイズに対処するために必要なエッジを与えてくれるはずです。\nそして、チェックしてみてください。私はついに未来に追いつき、（ちょうどいいタイミングで！）IPv6用にガイドを更新しました。お楽しみに！\n1.1 Audience #  このドキュメントは、完全なリファレンスではなく、チュートリアルとして書かれています。 ソケットプログラミングを始めたばかりで、足がかりを探している人が読むと、おそらく最適なものになるでしょう。ソケットプログラミングの完全なガイドではありません。\nでも、うまくいけば、あのマニュアルページが意味を持ち始めるかもしれませんね\u0026hellip;。:-)\n1.2 Platform and Compiler #  この文書に含まれるコードは、Gnu の gcc コンパイラを使用して Linux PC でコンパイルされています。しかし、gccを使うプラットフォームであれば、ほぼ全てのプラットフォームでビルドできるはずです。当然ながら、Windows用のプログラミングには適用されません。以下の section on Windows programmingを参照してください。\n1.3 Official Homepage and Books For Sale #  このドキュメントの正式な所在地は\n  https://beej.us/guide/bgnet/  また、サンプルコードや様々な言語への翻訳も掲載されています。\n製本された印刷物（\u0026ldquo;本\u0026quot;と呼ぶ人もいる）を購入するには、以下をご覧ください。\n  https://beej.us/guide/url/bgbuy  文書作成生活の維持に役立つので、購入はありがたいです！\n1.4 Note for Solaris/SunOS Programmers #  Solaris または SunOS 用にコンパイルする場合、適切なライブラリをリンクするために、いくつかの特別なコマンドラインスイッチを指定する必要があります。これを行うには、コンパイルコマンドの最後に \u0026ldquo;-lnsl -lsocket -lresolv\u0026rdquo; を以下のように追加するだけです。\n$ cc -o server server.c -lnsl -lsocket -lresolv それでもエラーが出るようなら、さらにそのコマンドラインの最後に -lxnet を追加してみるといいでしょう。それが何をするのか正確にはわかりませんが、必要な人もいるようです。\nもう一つ問題がありそうなのは、setsockopt() の呼び出しのところです。プロトタイプは私の Linux ボックスのものとは異なるので、代わりに\nint yes=1; char yes=\u0026#39;1\u0026#39;; を入力します。\n私は Sunbox を持っていないので、上記の情報を検証したわけではありません\u0026mdash;あくまでメールで教えてもらったことです。\n1.5 Note for Windows Programmers #  このガイドの時点では、歴史的に、私が Windows をあまり好きではないという事実のために、Windows を少し非難しています。しかし、Windows は膨大なインストールベースがあり、明らかに完璧なオペレーティングシステムであることを公平にお伝えする必要があります。\n不在は心を豊かにすると言いますが、この場合、私はそれが真実であると信じています。(ただ、言えることは、10数年前から個人的な仕事ではマイクロソフトのOSを使っていなかったので、ずっと幸せだということです だから、安心して、\u0026ldquo;どうぞ、ご自由に Windows を使ってください！\u0026ldquo;と言えるのです。 \u0026hellip;そう、歯ぎしりしながら言うんですけどね。\nですから私は、 Linux や BSD、あるいは Unix のいくつかのフレーバーを、代わりに試してみることをお勧めします。\nしかし、人は好きなものを好きになるものです。Windows の皆さんは、この情報が、もしあれば、いくつかの小さな変更を加えて、あなた方にも一般的に適用できることを知って喜んでいることでしょう。\nWindows 用の Unix ツールの集合体である Cygwin をインストールするのもいい方法です。そうすると、これらのプログラムはすべて修正なしでコンパイルできるようになると、人づてに聞いたことがあります。\nもうひとつ、 Windows Subsystem for Linux も検討してみてください。これは基本的に、Windows 10 に Linux の VM 的なものをインストールすることができます。これもまた、間違いなく位置づけられるでしょう。\nしかし、中には純粋な Windows のやり方で物事を進めたいと思う人もいるかもしれません。それはとてもガッツのあることで、こうすればいいんです。すぐに Unix を買ってきてください! いやいや\u0026mdash;冗談です。最近は Windows フレンドリー(笑)なはずなんですが\u0026hellip;。\nこれは、あなたがしなければならないことです（ Cygwinをインストールしない限り！）：まず、ここで私が言及するシステムヘッダーファイルのほとんどを無視してください。あなたがインクルードする必要があるのは、以下のものだけです。\n#include \u0026lt;winsock.h\u0026gt;待ってください！ソケットライブラリで何かする前に WSAStartup() を呼び出す必要があります。これを行うためのコードは以下のようなものです。\n#include \u0026lt;winsock.h\u0026gt; { WSADATA wsaData; // if this doesn\u0026#39;t work  //WSAData wsaData; // then try this instead  // MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:  if (WSAStartup(MAKEWORD(1,1), \u0026amp;wsaData) != 0) { fprintf(stderr, \u0026#34;WSAStartup failed.\\n\u0026#34;); exit(1); } また、Winsock ライブラリをリンクするようにコンパイラに指示する必要があります。通常、wsock32.lib または winsock32.lib、Winsock 2.0 の場合は ws2_32.lib と呼ばれます。VC++ では、これは Project メニューの Settings... から行うことができます。Link タブをクリックし、\u0026ldquo;Object/library modules\u0026rdquo; というタイトルのボックスを探します。そのリストに \u0026ldquo;wsock32.lib\u0026rdquo;（または、お好みの lib）を追加してください。\nとか聞いています。\n最後に、ソケットライブラリを使い終わったら、WSACleanup() を呼び出す必要があります。詳しくはオンラインヘルプを参照してください。\n一度これを行えば、このチュートリアルの残りの例は、いくつかの例外を除いて、概ね適用できるはずです。ひとつは、ソケットを閉じるために close() を使うことができません。また、select() はソケットディスクリプタに対してのみ動作し、ファイルディスクリプタに対しては動作しません (stdin に対する 0 のように)。\nまた、CSocket というソケットクラスもあります。詳細はコンパイラのヘルプを参照してください。\nWinsock についての詳しい情報は、 Winsock FAQ を読んで、そこから進んでください。\n最後に、Windows には fork() システムコールがないそうですが、これは残念ながら私の例のいくつかで使われているものです。多分、POSIX ライブラリか何かをリンクしないと動かないでしょうし、代わりに CreateProcess() を使ってもいいでしょう。fork() は引数を取らず、CreateProcess() は約480億の引数を取ります。もし、そこまで気が回らないのであれば、CreateThread() の方が少し消化しやすいでしょう。残念ながら、マルチスレッドに関する議論はこのドキュメントの範囲外です。私が語れることは限られているのですからね!\n1.6 Email Policy #  メールでの質問には基本的に対応しますので、気軽に書き込んでください。ただし、返事を保証するものではありません。私はかなり忙しい生活を送っているので、どうしても質問に答えられないことがあります。そのような場合は、メッセージを削除します。個人的なことではなく、あなたが必要とする詳細な回答をする時間がないだけなのです。\n原則として、質問が複雑であればあるほど、回答できる可能性は低くなります。質問を送る前に質問を絞り込み、関連する情報（プラットフォーム、コンパイラ、表示されるエラーメッセージなど、トラブルシューティングに役立ちそうなもの）を必ず記載していただければ、回答が得られる可能性は高くなります。より詳しい情報は、ESRのドキュメント、 How To Ask Questions The Smart Way をお読みください。\n返事がない場合は、もう少し調べてみて、答えが見つからなければ、また調べてみてください。そして調べたことまたを書き込んでください。その結果、私がお手伝いできるようになることを期待しています。\nさて、手紙の書き方、書き方についておせっかいを焼いてしまいましたが、このガイドが何年にもわたって賞賛されてきたことに、私は十分に感謝していることをお伝えしておきたいと思います。このガイドが良いことに使われていると聞いて、私はとても嬉しくなりました。:-) ありがとうございます。\n1.7 Mirroring #  このサイトをミラーリングすることは、公的にも私的にも大歓迎です。もし、あなたがこのサイトを公的にミラーリングし、メインページからリンクしてほしい場合は、beej@beej.us までご連絡ください。\n1.8 Note for Translators #  もし、このガイドを他の言語に翻訳したい場合は、beej@beej.us までメールをいただければ、メインページからあなたの翻訳をリンクさせていただきます。翻訳にはあなたの名前と連絡先を自由に追加してください。\nこのソースマークダウン文書は UTF-8 エンコーディングを使用しています。\n後述の Copyright, Distribution, and Legal に記載されている使用許諾条件にご注意ください。\nもし私に翻訳をホストして欲しいのであれば、言ってください。また、あなたがホストすることを望むなら、私はそれにリンクします；どちらでも構いません。\n1.9 Copyright, Distribution, and Legal #  Beej\u0026rsquo;s Guide to Network Programming is Copyright © 2019 Brian \u0026ldquo;Beej Jorgensen\u0026rdquo; Hall.\nこの作品は、以下のソースコードと翻訳に関する特定の例外を除き、クリエイティブ・コモンズ 表示-非営利-改変禁止 3.0 ライセンスの下に提供されています。このライセンスのコピーを見るには、以下をご覧ください。\n https://creativecommons.org/licenses/by-nc-nd/3.0/\nまたは、Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USAに手紙を送ってください。\n本使用許諾の\u0026quot;二次的著作物の禁止\u0026quot;部分の具体的な例外は、次のとおりです：このガイドは、翻訳が正確である限り、どの言語にも自由に翻訳でき、ガイド全体を再印刷することができます。翻訳には、オリジナルのガイドと同じライセンスの制約が適用されます。翻訳には、翻訳者の名前と連絡先も含めることができます。\n本書で紹介する C 言語のソースコードは、パブリックドメインとして許諾され、いかなるライセンス制限もありません。\n教育関係者は、このガイドを生徒に勧めたり、コピーを提供したりすることを自由に推奨します。\n書面による相互の合意がない限り、著者は作品を現状のまま提供し、作品に関して、明示的、黙示的、法定またはその他のいかなる種類の表明または保証（権利、商品性、特定目的への適合性、非侵害、潜在的またはその他の欠陥の不在、精度、または発見可能かどうかにかかわらず誤りの有無の保証を含むが、これに限定されない）も行わないものとします。\n適用される法律で要求される範囲を除き、いかなる場合においても、著作者は、著作物の使用から生じる特別損害、付随的損害、結果的損害、懲罰的損害または典型的損害について、たとえ著作者がその損害の可能性を知らされていたとしても、いかなる法的理論によってもお客様に対して責任を負うことはないものとします。\nお問い合わせは beej@beej.us までお願いします。\n1.10 Dedication #  このガイドを書くにあたり、過去から未来にわたって協力してくださった皆様に感謝します。そして、私がこのガイドを作るために使っているフリーソフトやパッケージを制作しているすべての人に感謝します。GNU、Linux、Slackware、vim、Python、Inkscape、pandoc、その他多数。そして最後に、文字通り何千もの人々が、改善の提案や励ましの言葉を書いてくれたことに、大きな感謝を捧げます。\nこのガイドを、コンピュータの世界における私の最大のヒーローであり、インスピレーターである何人かに捧げます。Donald Knuth、Bruce Schneier、W. Richard Stevens、The Woz、そして私の読者、さらにフリーおよびオープンソースソフトウェアのコミュニティ全体に捧げます。\n1.11 Publishing Information #  この本は、GNU ツールを搭載した Arch Linux のマシン上で vim エディタを使って、Markdown で書かれています。表紙の\u0026quot;アート\u0026quot;とダイアグラムは Inkscape で作成されています。Markdown は Python、Pandoc および XeLaTeX により、Liberation フォントを用いて HTML および LaTex/PDF に変換されます。このツールチェーンは 100% フリーおよびオープンソースソフトウェアで構成されています。\n"},{"id":1,"href":"/bgnet/docs/what-is-a-socket/","title":"2 What is a socket?","section":"Docs","content":"2 What is a socket? #  \u0026ldquo;ソケット\u0026quot;という言葉をよく耳にしますが、そもそも\u0026quot;ソケット\u0026quot;とは何なのでしょうか？それは、標準的な Unix のファイルディスクリプタを使って他のプログラムと会話するための方法です。\nなんと？\nOk\u0026mdash; Unix のハッカーが \u0026ldquo;Unix では何でもファイルなんだ！\u0026ldquo;と言ったのを聞いたことがあるかもしれません。その人が言っているのは、Unix のプログラムが何らかの I/O を行うとき、ファイル記述子に対して読み書きを行うという事実のことかもしれません。ファイルディスクリプタは、単純に、開いているファイルに関連する整数です。しかし、このファイルは、ネットワーク接続、FIFO、パイプ、ターミナル、ディスク上のファイルなど、あらゆるものになり得ます（ここが重要）。Unix ではすべてがファイルなのです！だから、インターネット上で他のプログラムと通信したいときは、ファイル記述子を介して行うことになるんだ。と思ってください。\n\u0026ldquo;ネットワーク通信のためのファイルディスクリプタはどこで手に入るのですか、お利口さん？\u0026ldquo;というのが、今あなたが考えている最後の質問でしょうが、とにかくそれに答えてあげましょう。あなたは socket() システムルーチンを呼び出すのです。このルーチンはソケットディスクリプタを返すので、それを使って send() と recv() ( man send, man recv) という特別なソケットコールを使って通信を行います。\n\u0026ldquo;でもね！\u0026ldquo;あなたは今頃、そう叫んでいるかもしれません。\u0026ldquo;ファイルディスクリプタなら、どうしてネプチューンの名において、通常の read() と write() の呼び出しでソケットを通して通信できないんだ？\u0026ldquo;と。短い答えは、\u0026ldquo;できる！\u0026ldquo;です。もっと長い答えは、\u0026ldquo;できるけど、send() と recv() はデータ転送をより大きく制御できる \u0026ldquo;です。\n次は何？どうでしょう、ソケットにはいろいろな種類がありますね。DARPA インターネットアドレス (インターネットソケット)、ローカルノード上のパス名 (Unix ソケット)、CCITT X.25 アドレス (X.25 ソケット、無視しても大丈夫)、そしておそらくあなたが実行する Unix のフレーバーに応じて他の多くの種類があります。この文書では、最初の\u0026quot;インターネットソケット\u0026quot;のみを扱います。\n2.1 Two Types of Internet Sockets #  これは何？インターネットソケットには2種類ある？そうです。まあ、違うけど。嘘です。もっとあるんだけど、怖がらせたくなかったんだ。 ここでは2種類しか話しません。ただし、この文章では、\u0026ldquo;Raw Sockets\u0026rdquo; も非常に強力なので、ぜひ調べてみてくださいと言うつもりです。\nわかったよ、もう。この2つのタイプは何ですか？一つは\u0026quot;ストリームソケット\u0026rdquo;、もう一つは\u0026quot;データグラムソケット\u0026quot;で、以下、それぞれ \u0026ldquo;SOCK_STREAM\u0026rdquo; \u0026ldquo;SOCK_DGRAM\u0026rdquo; と呼ぶことがあります。データグラムソケットは\u0026quot;コネクションレス型ソケット\u0026quot;と呼ばれることもあります 。(ただし、本当に必要であれば connect()' を使用することができます。後述の connect() を参照してください)。\nストリームソケットは、信頼性の高い双方向接続の通信ストリームです。ソケットに2つのアイテムを \u0026ldquo;1, 2\u0026rdquo; という順序で出力すると、反対側にも \u0026ldquo;1, 2\u0026rdquo; という順序で届きます。また、エラーも発生しません。実際、私はエラーフリーであることを確信しています。もし、そうでないと主張する人がいたら、耳に指を突っ込んで\u0026quot;ララララ\u0026quot;と唱えてやりたいくらいだ。\n何がストリーム・ソケットを使うのでしょうか？さて、皆さんは telnet というアプリケーションをご存知でしょうか？あれはストリームソケットを使っているんだ。あなたが入力した文字は、すべて入力した順番に到着する必要がありますよね？また、Webブラウザは HTTP(Hypertext Transfer Protocol) を使っていますが、これはストリームソケットを使ってページを取得します。実際、80番ポートで Web サイトに telnet して、\u0026quot;GET / HTTP/1.0\u0026rdquo; と入力してリターンを2回押すと、HTML がダンプされて戻ってきますよ。\nもし telnet がインストールされておらず、インストールもしたくない場合、あるいは telnet がクライアントとの接続にうるさい場合、ガイドには telnot という telnet に似たプログラムが付属しています。これは、このガイドで必要なものすべてに対してうまく機能するはずです。(なお、telnet は実際には spec\u0026rsquo;d networking protocol であり、telnot はこのプロトコルを全く実装していません)。\nストリームソケットは、どのようにしてこの高いレベルのデータ伝送品質を実現しているのでしょうか。 それは、\u0026ldquo;TCP\u0026rdquo; として知られる\u0026quot;伝送制御プロトコル\u0026rdquo;(TCP の詳細については RFC 793 を参照)というプロトコルを使用しているからです。TCP はデータが順次、エラーなく到着することを確認します。\u0026ldquo;TCP\u0026rdquo; は \u0026ldquo;TCP/IP\u0026rdquo; の半分で、\u0026ldquo;IP\u0026rdquo; は \u0026ldquo;Internet Protocol\u0026rdquo;（ RFC 791 を参照）の略だと聞いたことがあるかもしれません。IP は主にインターネット・ルーティングを扱い、一般にデータの完全性には責任を持ちません。\nかっこいい。データグラムソケットについてはどうでしょうか？なぜコネクションレス型と呼ばれるのでしょうか？どうなっているんだ？なぜ信頼性が低いのでしょうか？データグラムを送ると、それが届くかもしれません。データグラムを送信すると、それは到着するかもしれません。もし到着すれば、パケット内のデータはエラーフリーです。\nデータグラムソケットもルーティングに IP を使いますが、TCP は使わず、\u0026ldquo;User Datagram Protocol\u0026rdquo;、つまり \u0026ldquo;UDP\u0026rdquo; を使います（ RFC 768 を参照）。\nなぜコネクションレスレスなのか？まあ、基本的には、ストリームソケットのようにオープンな接続を維持する必要がないからです。パケットを作り、その上に宛先情報を含む IP ヘッダを貼り付け、送信するだけでいいのです。コネクションは必要ありません。一般的には、TCP スタックが利用できないときや、パケットをいくつか落としても宇宙の終わりを意味しないときに使用されます。サンプルアプリケーション: tftp (FTP の弟分のようなファイル転送プロトコル)、dhcpcd (DHCP クライアント)、マルチプレイヤーゲーム、ストリーミングオーディオ、ビデオ会議、などなど。\n\u0026ldquo;ちょっと待った！tftp と dhcpcd はバイナリアプリケーションをあるホストから別のホストに転送するために使われるんだ！アプリケーションが到着したときに動作することを期待するならば、データが失われることはありえない！これはどんな黒魔術なんだ？\u0026rdquo;\nさて、私の人間の友人である tftp やそれに類するプログラムは、UDP の上に独自のプロトコルを載せています。たとえば、tftp プロトコルは、送信されたパケットごとに、受信者は\u0026quot;受け取ったよ！\u0026ldquo;というパケットを送り返さなければならない、と言っています。というパケット(\u0026ldquo;ACK\u0026rdquo; パケット)を送り返さなければなりません。元のパケットの送信者は、例えば5秒間返信がない場合、最終的に ACK を得るまでパケットを再送信することになります。この確認手続きは、信頼性の高い SOCK_DGRAM アプリケーションを実装する際に非常に重要です。\nゲーム、オーディオ、ビデオなどの信頼性の低いアプリケーションでは、ドロップしたパケットを無視するか、あるいは巧みに補うようにします。(Quake プレイヤーは、この効果の発現を呪われたラグという専門用語で知っていることでしょう。 この場合の\u0026quot;呪われた\u0026quot;という単語は、非常に不敬な発言を意味します)。\nなぜ信頼性の低い基礎プロトコルを使うのでしょうか？理由は2つ、速度とスピードです。何が無事に到着したかを追跡し、順序立てて確認したりするよりも、発射して忘れる方がずっと速いのです。チャットメッセージを送るなら、TCP は素晴らしいです。世界中のプレイヤーの位置情報を毎秒40件送るなら、1件や2件が落ちてもそれほど問題ではないので、UDP は良い選択だと思います。\n2.2 Low level Nonsense and Network Theory #  先ほどプロトコルの階層化について触れましたので、そろそろネットワークが実際にどのように動作するのか、そして SOCK_DGRAM パケットがどのように構築されるのかについて、いくつかの例を挙げて説明しましょう。 実際のところ、このセクションは読み飛ばしても大丈夫でしょう。しかし、良い背景にはなります。\n データのカプセル化  子供たちよ、データカプセル化について学ぶ時間だ！これはとても重要なことです。あまりに重要なので、このチコステでネットワークの授業を受けると、このことを学ぶことになるかもしれません ;-). 基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えば TFTP プロトコル）によってヘッダー（まれにフッターも）でラップ（\u0026ldquo;カプセル化\u0026rdquo;）され、次のプロトコル（例えば UDP）によって全体（TFTP ヘッダーも含む）が再びカプセル化され、さらに次のプロトコル（IP）によってカプセル化され、ハードウェア（物理）層（例えば Ethernet）の最終プロトコルによって再びカプセル化されます。\n他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルが IP と UDP ヘッダを、TFTP プログラムが TFTP ヘッダを取り除き、ようやくデータを手に入れることができます。\nこれでやっと悪名高いレイヤードネットワークモデル（通称 \u0026ldquo;ISO/OSI\u0026rdquo;）について語れるようになりました。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。\nさっそくですが、本格的なモデルのレイヤーを紹介します。 ネットワーククラスの試験のために覚えておいてください。\n アプリケーション層 プレゼンテーション層 セッション層 トランスポート層 ネットワーク層 データリンク層 物理層  物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと相互作用する場所です。\nさて、このモデルは、本当にやろうと思えば、自動車の修理ガイドとして使えるほど一般的なものです。Unix とより整合性のあるレイヤーモデルは、次のようなものでしょう。\n アプリケーション層 (telnet, ftp, etc.) Host-to-Host トランスポート層 (TCP, UDP) インターネット層 (IP and routing) ネットワークアクセス層 (Ethernet, wi-fi, or whatever)  この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。\nシンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ！そして、\u0026quot;cat\u0026rdquo; を使って自分でパケットヘッダを入力しなければならないのです！冗談です。ストリームソケットでやるべきことは、データを send() することだけです。データグラムソケットでは、あなたが選んだメソッドでパケットをカプセル化し、sendto() で送り出すだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築します。ああ、現代の技術ですね。\nというわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていました：何もありません！（笑）。その通り、全く話すつもりはありません。ルータはパケットを IP ヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、 IP RFC をチェックしてみてください。もしあなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。\n"},{"id":2,"href":"/bgnet/docs/ip-addresses-structs-and-data-munging/","title":"3 IP Addresses, structs, and Data Munging","section":"Docs","content":"3 IP Addresses, structs, and Data Munging #  ここからは気分転換にコードの話をするところです。\nその前に、もっとノンコードの話をしましょう! イエーイ! まず最初に IP アドレスとポートについて少しお話したいと思いますので、それを整理します。それからソケット API がどのように IP アドレスや他のデータを保存し、操作するかについて話します。\n3.1 IP Addresses, versions 4 and 6 #  ベン・ケノービがまだオビワン・ケノービと呼ばれていた頃、インターネット・プロトコル・バージョン4（IPv4）と呼ばれる素晴らしいネットワーク・ルーティング・システムが存在しました。IPv4 は4バイト（4オクテット）で構成されるアドレスで、一般に「ドットと数字」で表記されるのが一般的でした。192.0.2.111 のように。\n皆さんも一度は目にしたことがあるのではないでしょうか。\n実際、この記事を書いている時点では、インターネット上のほぼすべてのサイトが IPv4 を使っています。\nオビ・ワンをはじめ、誰もが幸せでした。しかし、ヴィント・サーフという名の否定的な人物が、IPv4 アドレスが足りなくなると警告を発したのです！\n( ヴィント・サーフ氏は、IPv4 による「破滅と暗黒の黙示録」の到来を警告するとともに、「インターネットの父」としても有名です。だから、私は彼の判断に二の足を踏む立場にはないのだ)。\nアドレスが足りなくなる？そんなことがあるのでしょうか？つまり、32ビットの IPv4 アドレスには何十億もの IP アドレスが存在するのです。本当に何十億台ものコンピュータがあるのでしょうか？\nYes.\nまた、コンピュータが数台しかなく、10億という数字があり得ないほど大きいと誰もが思っていた当初、いくつかの大きな組織は、自分たちが使うために何百万というIPアドレスを惜しげもなく割り当てていたのです。(ゼロックス、MIT、フォード、HP、IBM、GE、AT\u0026amp;T、そしてアップルという小さな会社などです)。\n実際、いくつかの応急処置がなかったら、とっくに使い果たしていたでしょう。\nしかし今は、すべての人間がIPアドレスを持ち、すべてのコンピュータ、電卓、電話、パーキングメーター、そして（なぜか）子犬も、という時代です。\nそして、IPv6 が誕生したのです。ヴィント・サーフはおそらく不死身なので（たとえ肉体がこの世を去ったとしても、おそらく彼はすでにインターネット2の奥深くにある超知的な ELIZA プログラムとして存在しているはずです）、もし次のバージョンのインターネットプロトコルで十分なアドレスが確保できなければ、誰も彼の「だから言っただろう」という言葉を再び聞きたくはないでしょう。\nこれは何を示唆しているのでしょうか？\nもっとたくさんのアドレスが必要だということです。2倍どころか10億倍でもなく1000兆倍でもなく 7900万ビリオン・トリリオンの数のアドレスが必要なのです！そうこなくちゃ！\nビージェイ、それは本当なの？大きな数字を信じない理由があるんだ。\u0026ldquo;32ビットと128ビットの差は大したことないように聞こえるかもしれない、96ビット多いだけだろ？しかし、私たちはここで累乗の話をしていることを忘れてはなりません。32ビットは約40億の数字（2^32）を表し、128ビットは約340兆の数字（2^128）を表します。これは、宇宙の星1つに対して、100万個の IPv4 インターネットがあるようなものです。\nIPv4のドットや数字も忘れて、16進数では、2バイトの塊をコロンで区切って、このように表現しています。\n2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551 それだけではありません! 多くの場合、IPアドレスにはたくさんのゼロが含まれていますが、それらを2つのコロンで区切って圧縮することができます。そして、各バイトペアの先頭のゼロを省くことができます。例えば、次のようなアドレスのペアは、それぞれ等価です。\n2001:0db8:c9d2:0012:0000:0000:0000:0051 2001:db8:c9d2:12::51 2001:0db8:ab00:0000:0000:0000:0000:0000 2001:db8:ab00:: 0000:0000:0000:0000:0000:0000:0000:0001 ::1 アドレス ::1 はループバックアドレスです。常に「今走っているこのマシン」という意味です。IPv4 では、ループバックアドレスは 127.0.0.1 です。\n最後に、IPv6 アドレスの IPv4 互換モードですが、これは皆さんが遭遇する可能性のあるものです。例えば、192.0.2.33という IPv4 アドレスを IPv6 アドレスとして表現したい場合、次のような表記をします。\u0026quot;::ffff:192.0.2.33\u0026quot;。\n本気で楽しみたいんです。\n実際、IPv6 の開発者たちは、何兆個ものアドレスを軽率にも予約用に切り捨てたほど、IPv6 は楽しいものなのですが、数が多すぎて、正直言って、もう誰が数えているのでしょうか？銀河系のすべての惑星のすべての男性、女性、子供、子犬、そしてパーキングメーターのために十分な数が残されています。 信じてくれ、銀河系のどの星にもパーキングメーターはあるんだ。本当なんだ。\n3.1.1 Subnets #  組織上、「このIPアドレスの先頭からこのビットまでがネットワーク部分、それ以外がホスト部分」と宣言するのが便利な場合があります。\n例えば、IPv4 では 192.0.2.12 というように、最初の3バイトがネットワークで、最後の1バイトがホストと言えるでしょう。あるいは、別の言い方をすれば、ネットワーク 192.0.2.0 上のホスト 12 について話していることになります (ホストであるバイトをゼロにしているところをご覧ください)。\nそして、さらに時代遅れの情報を! 準備はいいですか？古代では、サブネットには「クラス」があり、アドレスの最初の1バイト、2バイト、3バイトがネットワーク部分でした。運良く1バイトがネットワーク、3バイトがホストの場合、ネットワーク上に24ビット分のホスト（1600万程度）を持つことができます。これが「クラスA」のネットワークである。一方、「クラスC」は、ネットワークが3バイト、ホストが1バイトで、256台のホスト（ただし、予約された数台は除く）を持ちます。\nご覧のように、Aクラスがほんの少し、Cクラスが大量に、そして真ん中にBクラスが何個かある状態でした。\nIPアドレスのネットワーク部分は、ネットマスクと呼ばれるもので記述されており、IPアドレスとビット単位でANDすることでネットワーク番号を取得します。ネットマスクは通常 255.255.255.0 のような形をしています。(例えば、このネットマスクでは、あなたのIPが 192.0.2.12 なら、あなたのネットワークは 192.0.2.12 AND 255.255.255.0 で、 192.0.2.0 となります)。\nしかし、残念ながら、これはインターネットの最終的なニーズに対して十分なきめ細かさではないことが判明しました。クラスCのネットワークはすぐに足りなくなったし、クラスAのネットワークも足りなくなったので、わざわざ尋ねる必要はありません。この問題を解決するために、権力者たちはネットマスクを 8、16、24 のどれでもなく、任意のビット数にすることを許可しました。例えば 255.255.255.252 というネットマスクは、30 ビットのネットワークと 2 ビットのホストで、 ネットワーク上に 4 つのホストを置くことができます。 (ネットマスクは常に1ビットの束と0ビットの束からなることに注意してください)。\nしかし、255.192.0.0 のような大きな数字の羅列をネットマスクとして使うのは、少し扱いにくいです。まず、それが何ビットなのかが直感的にわからないし、コンパクトでもありません。そこで新スタイルが登場したのですが、これはもっとすっきりしています。IP アドレスの後にスラッシュを付けて、その後に10進数でネットワークのビット数を指定するだけです。こんな感じです。192.0.2.12/30。\nあるいは、IPv6 の場合、このようなものです。2001:db8::/32 または 2001:db8:5413:4028::9db9/64 です。\n3.1.2 Port Numbers #  以前、インターネット層（IP）とホスト間トランスポート層（TCPとUDP）を分離した レイヤードネットワークモデルをご紹介しましたが、覚えていらっしゃいますか？次の段落の前に、そのことをしっかり覚えておいてください。\nIP アドレス（IP 層で使われる）の他に、TCP（ストリームソケット）や、偶然にも UDP（データグラムソケット）で使われるアドレスがあることが判明したのです。それは、ポート番号です。これは16ビットの数字で、接続のためのローカルアドレスのようなものです。\nIP アドレスはホテルの番地、ポート番号は部屋番号だと思ってください。後で自動車業界の例も考えてみましょう。\n例えば、受信メールとウェブサービスの両方を扱うコンピュータを用意したい場合、1つのIPアドレスを持つコンピュータでその2つを区別する方法はあるでしょうか？\nさて、インターネット上のサービスには、それぞれ異なるウェルノウン・ポート番号が設定されています。 IANA のポート一覧か、Unix であれば /etc/services ファイルで確認することができます。HTTP（ウェブ）はポート80、telnet はポート23、SMTP はポート25、ゲーム DOOM はポート666、などなど。1024以下のポートはしばしば特殊とみなされ、通常、使用するには OS の特別な権限が必要です。\nといったところでしょうか。\n3.2 Byte Order #  レルムの命令で！バイトの並び順は2種類とします。今後、Lame and Magnificent と呼ばれるようになります。\nというのは冗談ですが、本当にどちらか一方が優れているのです。:-)\nあなたのコンピュータは、あなたの背後でバイトを逆順に保存しているかもしれないのです。そうなんです。誰もあなたに言いたくはなかったのです。\nつまり、2バイトの16進数、たとえば b34f を表現する場合、b3 と 4f の2バイトに続けて格納する、というのがインターネットの世界の共通認識になっているのです。これは理にかなっているし、 ウィルフォード・ブリムリーも言うように、正しい行為です。このように、大きい方の端が先になるように格納された数字をビッグエンディアン（Big-Endian）と呼びます。\n残念ながら、世界中に散在する一部のコンピュータ、すなわちインテルまたはインテル互換のプロセッサを搭載したものは、バイトを逆に格納しているため、b34fは 4f と b3 の連続したバイトとしてメモリに格納されることになります。この記憶方式をリトルエンディアンと呼びます。\nでも、ちょっと待ってください！用語の説明はまだ終わっていないのです。もっとまともなビッグエンディアンはネットワークバイトオーダーとも呼ばれ、私たちネットワーク系が好む順序だからです。\nコンピュータはホストバイトオーダーで数字を記憶しています。インテル 80x86 であれば、ホストバイト順はリトルエンディアンです。モトローラ 68K の場合は、ビッグエンディアンです。PowerPC なら、ホストバイトの並びは\u0026hellip;\u0026hellip;まあ、人それぞれですね。\nパケットを作成するときやデータ構造を埋めるときに、2バイトや4バイトの数値がネットワークバイトオーダーになっていることを確認する必要があることがよくあります。しかし、ネイティブなホストバイトオーダーがわからない場合、どのようにすればよいのでしょうか。\n朗報です。ホストのバイトオーダーが正しくないと仮定して、値をネットワークバ イトオーダーに設定するための関数を常に実行するようにすればよいのです。この関数は、必要であれば魔法のような変換を行い、エンディアンが異なるマシンにもコードを移植することができます。\nよしよし。変換できる数値は、short（2バイト）と long（4バイト）の2種類です。これらの関数は、符号なしのバリエーションでも動作します。例えば、short をホストバイトオーダーからネットワークバイトオーダーに変換したいとします。まず \u0026ldquo;h\u0026rdquo; でホスト、その後に \u0026ldquo;to\u0026rdquo; をつけます。そして、\u0026ldquo;n\u0026rdquo; は \u0026ldquo;network\u0026rdquo;、\u0026ldquo;s\u0026rdquo; は \u0026ldquo;short\u0026rdquo; を表します。h-to-n-s または htons() (読み方: \u0026ldquo;ホストからネットワークへのショート\u0026rdquo;) です。\n簡単すぎるくらいに\u0026hellip;。\n\u0026ldquo;n\u0026rdquo;、\u0026ldquo;h\u0026rdquo;、\u0026ldquo;s\u0026rdquo;、\u0026ldquo;l\u0026rdquo; の組み合わせは、本当にくだらないものを除いて、すべて使うことができるのです。たとえば、stolh() (\u0026ldquo;Short to Long Host\u0026rdquo;) という関数はありません\u0026mdash;とにかく、このパーティーでは。しかし、あるのです。\n   関数 説明     htons() host to network short   htonl() host to network long   ntohs() network to host short   ntohl() network to host long    基本的には、送出する前にネットワークバイトオーダーに変換し、送出後にホストバイトオーダーに変換します。\n64bitのバリエーションは知らないです、すみません。また、浮動小数点をやりたい場合は、ずっと下の Serialization の章をチェックしてください。\nこの文書では、特に断らない限り、数値はホストバイトオーダーであると仮定しています。\n3.3 structs #  さて、ついにここまで来ました。そろそろプログラミングの話をしましょう。この章では、ソケットインターフェイスで使用される様々なデータ型について説明します。\nまず、簡単なものからです。ソケットディスクリプタです。ソケットディスクリプタは以下のような型です。\nint 普通の int です。\nここからは変な話なので、我慢して読んでください。\nMy First Struct™\u0026mdash;struct addrinfo。この構造体は最近開発されたもので、ソケットアドレス構造体を後で使用するために準備するために使用されます。また、ホスト名のルックアップやサービス名のルックアップにも使用されます。これは、後で実際の使い方を説明するときに、より意味をなすと思いますが、今は、接続を行うときに最初に呼び出されるものの1つであることを知っておいてください。\nstruct addrinfo { int ai_flags; // AI_PASSIVE, AI_CANONNAME, etc.  int ai_family; // AF_INET, AF_INET6, AF_UNSPEC  int ai_socktype; // SOCK_STREAM, SOCK_DGRAM  int ai_protocol; // use 0 for \u0026#34;any\u0026#34;  size_t ai_addrlen; // size of ai_addr in bytes  struct sockaddr *ai_addr; // struct sockaddr_in or _in6  char *ai_canonname; // full canonical hostname  struct addrinfo *ai_next; // linked list, next node }; この構造体を少し読み込んでから、getaddrinfo() を呼び出します。この構造体のリンクリストへのポインタが返され、必要なものがすべて満たされます。\nai_family フィールドで IPv4 か IPv6 を使うように強制することもできますし、AF_UNSPEC のままにして何でも使えるようにすることも可能です。これは、あなたのコードが IP バージョンに依存しないので、クールです。\nこれはリンクされたリストであることに注意してください：ai_next は次の要素を指しています\u0026mdash;そこから選択するためにいくつかの結果があるかもしれません。私は最初にうまくいった結果を使いますが、あなたは異なるビジネスニーズを持っているかもしれません。何でもかんでも知ってるわけじゃないんです！\nstruct addrinfo の ai_addr フィールドは struct sockaddr へのポインタであることがわかります。ここからが、IP アドレス構造体の中身についての細かい話になります。\n通常、これらの構造体に書き込む必要はありません。多くの場合、addrinfo 構造体を埋めるために getaddrinfo() を呼び出すだけでよいでしょう。しかし、これらの構造体の内部を覗いて値を取得する必要があるため、ここでそれらを紹介します。\n(また、構造体 addrinfo が発明される前に書かれたコードはすべて、これらのものをすべて手作業で梱包していたので、まさにそのような IPv4 コードを多く見かけることができます。このガイドの古いバージョンなどでもそうです)。\nある構造体は IPv4 で、ある構造体は IPv6 で、ある構造体はその両方です。どれが何なのか、メモしておきます。\nとにかく、構造体 sockaddr は、多くの種類のソケットのためのソケットアドレス情報を保持します。\nstruct sockaddr { unsigned short sa_family; // address family, AF_xxx  char sa_data[14]; // 14 bytes of protocol address }; sa_family には様々なものを指定できますが、この文書ではすべて AF_INET (IPv4) または AF_INET6 (IPv6) とします。sa_data にはソケットの宛先アドレスとポート番号を指定します。sa_data にアドレスを手で詰め込むのは面倒なので、これはかなり扱いにくいです。\n構造体 sockaddr を扱うために、プログラマは IPv4 で使用する構造体 sockaddr_in（\u0026ldquo;in\u0026rdquo; は \u0026ldquo;Internet\u0026rdquo; の意）を並列に作成しました。\nsockaddr_in 構造体へのポインタは sockaddr 構造体へのポインタにキャストすることができ、その逆も可能です。つまり、connect() が struct sockaddr* を要求しても、struct sockaddr_in を使用して、最後の最後でキャストすることができるのです！\n// (IPv4 only--see struct sockaddr_in6 for IPv6)  struct sockaddr_in { short int sin_family; // Address family, AF_INET  unsigned short int sin_port; // Port number  struct in_addr sin_addr; // Internet address  unsigned char sin_zero[8]; // Same size as struct sockaddr }; この構造体により、ソケットアドレスの要素を簡単に参照することができます。sin_zero (構造体を struct sockaddr の長さに合わせるために含まれます) は、関数 memset() ですべて 0 に設定する必要があることに注意すること。また、sin_family は struct sockaddr の sa_family に相当し、\u0026quot;AF_INET\u0026rdquo; に設定されることに注意します。最後に、sin_port はネットワークバイトオーダーでなければなりません（htons() を使用することで！）。\nもっと掘り下げましょう！sin_addr フィールドは in_addr 構造体であることがわかりますね。あれは何なんだ？まあ、大げさではなく、史上最も恐ろしい組合せの1つです。\n// (IPv4 only--see struct in6_addr for IPv6)  // Internet address (a structure for historical reasons) struct in_addr { uint32_t s_addr; // that\u0026#39;s a 32-bit int (4 bytes) }; うおぉ まあ、昔はユニオンだったんだけど、今はもうそういう時代じゃないみたいだね。おつかれさまでした。つまり、ina を struct sockaddr_in 型と宣言した場合、ina.sin_addr.s_addr は4バイトの IP アドレス（ネットワークバイトオーダー）を参照することになります。あなたのシステムがまだ struct in_addr のための神々しいユニオンを使用している場合でも、あなたはまだ私が上記のように全く同じ方法で4バイトの IP アドレスを参照することができます（これは #defines によるものです）ことに注意してください。\nIPv6 ではどうでしょうか。これについても同様の構造体が存在します。\n// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)  struct sockaddr_in6 { u_int16_t sin6_family; // address family, AF_INET6  u_int16_t sin6_port; // port number, Network Byte Order  u_int32_t sin6_flowinfo; // IPv6 flow information  struct in6_addr sin6_addr; // IPv6 address  u_int32_t sin6_scope_id; // Scope ID }; struct in6_addr { unsigned char s6_addr[16]; // IPv6 address }; IPv4 が IPv4 アドレスとポート番号を持つように、IPv6 も IPv6 アドレスとポート番号を持つことに注意してください。\nまた、IPv6 フロー情報やスコープ ID のフィールドについては、今のところ触れないことに注意してください。:-)\n最後になりますが、こちらもシンプルな構造体である struct sockaddr_storage は、IPv4 と IPv6 の両方の構造体を保持できるように十分な大きさに設計されています。コールによっては、struct sockaddr に IPv4 と IPv6 のどちらのアドレスが記入されるのか事前にわからないことがありますよね。そこで、この並列構造体を渡しますが、サイズが大きい以外は struct sockaddr とよく似ており、必要な型にキャストします。\nstruct sockaddr_storage { sa_family_t ss_family; // address family  // all this is padding, implementation specific, ignore it:  char __ss_pad1[_SS_PAD1SIZE]; int64_t __ss_align; char __ss_pad2[_SS_PAD2SIZE]; }; 重要なのは、ss_family フィールドでアドレスファミリーを確認できることで、これが AF_INET か AF_INET6（IPv4 か IPv6 か）かを確認することです。それから、必要なら struct sockaddr_in や struct sockaddr_in6 にキャストすることができます。\n3.4 IP Addresses, Part Deux #  幸いなことに、IP アドレスを操作するための関数がたくさんあります。手書きで把握して \u0026lt;\u0026lt; 演算子で long に詰め込む必要はありません。\nまず、struct sockaddr_in ina があり、そこに格納したい IP アドレスが 10.12.110.57 または 2001:db8:63b3:1::3490 だとしましょう。inet_pton() という関数は、数字とドットで表記された IP アドレスを、AF_INET か AF_INET6 の指定によって、in_addr 構造体か in6_addr 構造体に変換する関数です。(\u0026quot;pton\u0026quot; は \u0026ldquo;presentation to network\u0026rdquo; の略で、覚えやすければ \u0026ldquo;printable to network\u0026rdquo; と呼んでも構いません)。変換は次のように行うことができます。\nstruct sockaddr_in sa; // IPv4 struct sockaddr_in6 sa6; // IPv6  inet_pton(AF_INET, \u0026#34;10.12.110.57\u0026#34;, \u0026amp;(sa.sin_addr)); // IPv4 inet_pton(AF_INET6, \u0026#34;2001:db8:63b3:1::3490\u0026#34;, \u0026amp;(sa6.sin6_addr)); // IPv6 (クイックメモ: 古い方法では、inet_addr() という関数や inet_aton() という別の関数を使っていましたが、これらはもう時代遅れで IPv6 では動きません。)\nさて、上記のコードスニペットは、エラーチェックがないため、あまり堅牢ではありません。inet_pton() はエラー時に -1 を返し、アドレスがめちゃくちゃになった場合は 0 を返します。ですから、使用する前に結果が 0 よりも大きいことを確認してください！\nさて、これで文字列の IP アドレスをバイナリ表現に変換することができるようになりました。では、その逆はどうでしょうか？in_addr 構造体を持っていて、それを数字とドットの表記で印刷したい場合はどうでしょうか。(この場合、関数 inet_ntop() (\u0026quot;ntop\u0026quot; は \u0026ldquo;network to presentation\u0026rdquo; という意味です。覚えやすければ \u0026ldquo;network to printable\u0026rdquo; と呼んでも構いません) を次のように使用します。\n// IPv4:  char ip4[INET_ADDRSTRLEN]; // space to hold the IPv4 string struct sockaddr_in sa; // pretend this is loaded with something  inet_ntop(AF_INET, \u0026amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN); printf(\u0026#34;The IPv4 address is: %s\\n\u0026#34;, ip4); // IPv6:  char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string struct sockaddr_in6 sa6; // pretend this is loaded with something  inet_ntop(AF_INET6, \u0026amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN); printf(\u0026#34;The address is: %s\\n\u0026#34;, ip6); 呼び出す際には、アドレスの種類（IPv4 または IPv6）、アドレス、結果を格納する文字列へのポインタ、その文字列の最大長を渡すことになります。(2つのマクロは、最大の IPv4 または IPv6 アドレスを保持するために必要な文字列のサイズを都合よく保持します。INET_ADDRSTRLEN と INET6_ADDRSTRLEN です)。\n(古いやり方についてもう一度簡単に触れておくと、この変換を行う歴史的な関数は inet_ntoa() と呼ばれるものでした。これも時代遅れで、IPv6 では動きません。)\n最後に、これらの関数は数値の IP アドレスに対してのみ動作します。\u0026quot;www.example.com\u0026quot; のようなホスト名に対してネームサーバの DNS ルックアップは行いません。後ほど説明するように、そのためには getaddrinfo() を使用します。\n3.4.1 Private (Or Disconnected) Networks #  多くの場所では、自分たちを守るために、ネットワークを他の地域から隠すファイアウォールがあります。そして多くの場合、ファイアウォールは、ネットワークアドレス変換（NAT）と呼ばれるプロセスを使って、\u0026ldquo;内部\u0026rdquo; IP アドレスを\u0026quot;外部\u0026quot;（世界中の誰もが知っている）IP アドレスに変換しています。\nもう緊張してきましたか？\u0026ldquo;こんな変なことして どこへ行くんだろう？\u0026rdquo;\nまあ、ノンアルコール飲料でも買ってリラックスしてください。初心者の場合、NAT は透過的に行われるので、心配する必要もありませんから。しかし、あなたが見ているネットワーク番号に混乱し始めた場合に備えて、ファイアウォールの背後にあるネットワークについて話したいと思います。\n例えば、私の自宅にはファイアウォールがあります。DSL 会社から割り当てられた2つの固定 IPv4 アドレスを持っていますが、ネットワーク上に7台のコンピューターがあります。どうしてこんなことが可能なのでしょうか？2台のコンピュータが同じ IP アドレスを共有することはできませんし、そうでなければデータはどちらに行けばいいのかわからなくなってしまいます。\n答えは、\u0026ldquo;同じIPアドレスを共有していない\u0026quot;です。2400万個の IP アドレスが割り当てられたプライベートネットワーク上にあるのです。それらはすべて私のためだけのものです。まあ、他の人たちから見れば、すべて私のためのものなのですが。ここで、何が起こっているのかを説明します。\nリモートコンピューターにログインすると、ISP から提供されたパブリック IP アドレスである 192.0.2.33 からログインしていると表示されるのです。しかし、ローカルコンピューターにその IP アドレスを尋ねると、10.0.0.5 と答えるのです。誰が IP アドレスを変換しているのでしょうか？そうです、ファイアウォールです。ファイアウォールが NAT しているのです。\n10.x.x.x は、完全に切断されたネットワークか、ファイアウォールの内側にあるネットワークでのみ使用される、数少ない予約ネットワークの1つです。どのプライベート・ネットワーク番号が使用できるかの詳細は、 RFC 1918 に概説されていますが、一般的によく目にするのは、10.x.x.x と 192.168.x.x で、x は通常 0 ～ 255 です。一般的ではないのは、172.y.x.x で、y は16から31の間です。\nNAT するファイアウォールの内側のネットワークは、これらの予約されたネットワークのいずれかにある必要はありませんが、一般的にはそうなっています。\n(楽しい事実！私の外部 IP アドレスは、本当は 192.0.2.33 ではないのです。192.0.2.x ネットワークは、このガイドのように、ドキュメントで使用するための架空の\u0026quot;本当の\u0026rdquo; IP アドレスのために予約されているのです！わーい、すごい！)\nIPv6 にも、ある意味プライベートネットワークがあります。 RFC 4193 にあるように、fdXX:（将来的には fcXX:）で始まります。しかし、NAT と IPv6 は一般的に混ざりません(このドキュメントの範囲外である IPv6 から IPv4 へのゲートウェイを行う場合を除きます)。理論的には、自由に使えるアドレスが非常に多くなるため、NAT を使用する必要はなくなるはずです。しかし、外部にルーティングしないネットワーク上で自分のためにアドレスを割り当てたい場合は、このようにします。\n"},{"id":3,"href":"/bgnet/docs/jumping-from-ipv4-to-ipv6/","title":"4 Jumping from IPv4 to IPv6","section":"Docs","content":"4 Jumping from IPv4 to IPv6 #  しかし、IPv6 で動作させるためには、私のコードのどこを変えればいいのか知りたいのです！今すぐ教えてください！\nOk! Ok!\nここに書かれていることはほとんどすべて、私が上で説明したことですが、せっかちな人のためのショートバージョンです。(もちろん、これ以外にもありますが、このガイドに該当するのはこれです)。\n  まず、構造体を手で詰めるのではなく、 getaddrinfo() を使ってすべての sockaddr 構造体の情報を取得するようにしてください。こうすることで、IP のバージョンに左右されず、また、その後の多くのステップを省くことができます。\n  IP バージョンに関連する何かをハードコーディングしていることが分かったら、ヘルパー関数でラップするようにします。\n  AF_INET を AF_INET6 に変更します。\n  PF_INET を PF_INET6 に変更します。\n  INADDR_ANY の割り当てを in6addr_any の割り当てに変更し、若干の差異が生じます。\nstruct sockaddr_in sa; struct sockaddr_in6 sa6; sa.sin_addr.s_addr = INADDR_ANY; // use my IPv4 address sa6.sin6_addr = in6addr_any; // use my IPv6 address Also, the value IN6ADDR_ANY_INIT can be used as an initializer when the struct in6_addr is declared, like so:\nstruct in6_addr ia6 = IN6ADDR_ANY_INIT;   struct sockaddr_in の代わりに struct sockaddr_in6 を使用し、必要に応じてフィールドに \u0026ldquo;6\u0026rdquo; を追加してください（上記の structs を参照）。sin6_zero フィールドはありません。\n  struct in_addr の代わりに struct in6_addr を使用し、必要に応じてフィールドに \u0026ldquo;6\u0026rdquo; を追加してください（上記の structs を参照）。\n  inet_aton() や inet_addr() の代わりに、inet_apton() を使用してください。\n  inet_ntoa() の代わりに inet_ntop() を使用してください。\n  gethostbyname() の代わりに、優れた getaddrinfo() を使用してください。\n  gethostbyaddr() の代わりに、優れた getnameinfo() を使用してください（gethostbyaddr()は IPv6 でも動作可能です）。\n  INADDR_BROADCAST は動作しなくなりました。代わりに IPv6 マルチキャストを使用してください。\n  出来上がり！\n"},{"id":4,"href":"/bgnet/docs/system-calls-or-bust/","title":"5 System Calls or Bust","section":"Docs","content":"5 System Calls or Bust #  このセクションでは、Unix マシンのネットワーク機能にアクセスするためのシステムコールやその他のライブラリコールに触れることができますし、ソケット API をサポートしているあらゆるマシン (BSD, Windows, Linux, Mac, など) も同様です。これらの関数を呼び出すと、カーネルが引き継ぎ、すべての作業を自動で行ってくれます。\nこのあたりで多くの人がつまづくのは、これらのものをどのような順序で呼び出すかということです。これについては、皆さんもお分かりのように、man ページが役に立ちません。そこで、この恐ろしい状況を改善するために、以下の章のシステムコールを、あなたがプログラムの中で呼び出す必要があるのと全く（おおよそ）同じ順序で並べることにしました。\nこれに、あちこちにあるサンプルコード、ミルクとクッキー（自分で用意しなければならないのが怖い）、そして生粋のガッツと勇気があれば、ジョン・ポステルの息子のようにインターネット上でデータを発信することができるのです！\n(なお、以下の多くのコードでは、簡潔にするため、必要なエラーチェックは行っていません。また、getaddrinfo() の呼び出しが成功し、リンクリストの有効なエントリを返すと仮定することが非常に一般的です。これらの状況はいずれもスタンドアロン・プログラムで適切に対処されているので、それらをモデルとして使用してください。)\n5.1 getaddrinfo()\u0026mdash;Prepare to launch! #  この関数は多くのオプションを持つ真の主力関数ですが、使い方はいたってシンプルです。後で必要な構造体をセットアップするのに役立ちます。\n昔は、gethostbyname() という関数を使って DNS のルックアップを行っていました。そして、その情報を sockaddr_in 構造体に手作業でロードし、それを呼び出しに使用するのです。\nこれは、ありがたいことに、もう必要ありません。(IPv4 と IPv6 の両方で動作するコードを書きたいのであれば、望ましいことではありません！) 現代では、DNS やサービス名のルックアップなど、あらゆる種類の良いことをやってくれる getaddrinfo() という関数があり、さらに必要な struct も埋めてくれます！\nそれでは、ご覧ください！\n#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netdb.h\u0026gt; int getaddrinfo(const char *node, // e.g. \u0026#34;www.example.com\u0026#34; or IP  const char *service, // e.g. \u0026#34;http\u0026#34; or port number  const struct addrinfo *hints, struct addrinfo **res); この関数に3つの入力パラメータを与えると、結果のリンクリストである res へのポインタが得られます。\nnode パラメータには、接続先のホスト名、または IP アドレスを指定します。\n次にパラメータ service ですが、これは \u0026ldquo;80\u0026rdquo; のようなポート番号か、\u0026ldquo;http\u0026rdquo;, \u0026ldquo;ftp\u0026rdquo;, \u0026ldquo;telnet\u0026rdquo;, \u0026ldquo;smtp\u0026rdquo; などの特定のサービスの名前（ IANAポートリストや Unix マシンの /etc/services ファイルで見つけることができます）であることができます。\n最後に、hints パラメータは、関連情報をすでに記入した addrinfo 構造体を指します。\n以下は、自分のホストの IP アドレス、ポート 3490 をリッスンしたいサーバの場合の呼び出し例です。これは実際にはリスニングやネットワークの設定を行っていないことに注意してください。\nint status; struct addrinfo hints; struct addrinfo *servinfo; // will point to the results  memset(\u0026amp;hints, 0, sizeof hints); // make sure the struct is empty hints.ai_family = AF_UNSPEC; // don\u0026#39;t care IPv4 or IPv6 hints.ai_socktype = SOCK_STREAM; // TCP stream sockets hints.ai_flags = AI_PASSIVE; // fill in my IP for me  if ((status = getaddrinfo(NULL, \u0026#34;3490\u0026#34;, \u0026amp;hints, \u0026amp;servinfo)) != 0) { fprintf(stderr, \u0026#34;getaddrinfo error: %s\\n\u0026#34;, gai_strerror(status)); exit(1); } // servinfo now points to a linked list of 1 or more struct addrinfos  // ... do everything until you don\u0026#39;t need servinfo anymore ....  freeaddrinfo(servinfo); // free the linked-list ai_family を AF_UNSPEC に設定することで、IPv4 や IPv6 を使うかどうかを気にしないことを表明していることに注意してください。もし、どちらか一方だけを使いたい場合は、AF_INET または AF_INET6 に設定することができます。\nまた、AI_PASSIVE フラグがあるのがわかると思いますが、これは getaddrinfo() にローカルホストのアドレスをソケット構造体に割り当てるように指示しています。これは、ハードコードする必要がないのがいいところです。(あるいは、getaddrinfo() の最初のパラメータとして特定のアドレスを入れることもできます。私は現在 NULL を持っています。)\nそして、呼び出しを行います。エラー(getaddrinfo() が0以外を返す)があれば、ご覧のように関数 gai_strerror() を使ってそれを表示することができます。しかし、すべてがうまくいけば、servinfo は struct addrinfos のリンクリストを指し、それぞれのリストには後で使用できる何らかの sockaddr 構造体が含まれています！素晴らしい！\n最後に、getaddrinfo() が快く割り当ててくれたリンクリストをすべて使い終わったら、freeaddrinfo() を呼び出してすべてを解放することができます(そうすべき)です。\nここでは、クライアントが特定のサーバ、例えば \u0026ldquo; www.example.net\u0026rdquo; ポート 3490 に接続したい場合のサンプルコールを紹介します。繰り返しますが、これは実際には接続しませんが、後で使用する構造をセットアップしています。\nint status; struct addrinfo hints; struct addrinfo *servinfo; // will point to the results  memset(\u0026amp;hints, 0, sizeof hints); // make sure the struct is empty hints.ai_family = AF_UNSPEC; // don\u0026#39;t care IPv4 or IPv6 hints.ai_socktype = SOCK_STREAM; // TCP stream sockets  // get ready to connect status = getaddrinfo(\u0026#34;www.example.net\u0026#34;, \u0026#34;3490\u0026#34;, \u0026amp;hints, \u0026amp;servinfo); // servinfo now points to a linked list of 1 or more struct addrinfos  // etc. servinfo は、あらゆるアドレス情報を持つリンクリストだと言い続けています。この情報を披露するために、簡単なデモプログラムを書いてみよう。 この短いプログラムは、コマンドラインで指定された任意のホストの IP アドレスを表示します。\n/* ** showip.c -- show IP addresses for a host given on the command line */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt; int main(int argc, char *argv[]) { struct addrinfo hints, *res, *p; int status; char ipstr[INET6_ADDRSTRLEN]; if (argc != 2) { fprintf(stderr,\u0026#34;usage: showip hostname\\n\u0026#34;); return 1; } memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // AF_INET or AF_INET6 to force version  hints.ai_socktype = SOCK_STREAM; if ((status = getaddrinfo(argv[1], NULL, \u0026amp;hints, \u0026amp;res)) != 0) { fprintf(stderr, \u0026#34;getaddrinfo: %s\\n\u0026#34;, gai_strerror(status)); return 2; } printf(\u0026#34;IP addresses for %s:\\n\\n\u0026#34;, argv[1]); for(p = res;p != NULL; p = p-\u0026gt;ai_next) { void *addr; char *ipver; // get the pointer to the address itself,  // different fields in IPv4 and IPv6:  if (p-\u0026gt;ai_family == AF_INET) { // IPv4  struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-\u0026gt;ai_addr; addr = \u0026amp;(ipv4-\u0026gt;sin_addr); ipver = \u0026#34;IPv4\u0026#34;; } else { // IPv6  struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-\u0026gt;ai_addr; addr = \u0026amp;(ipv6-\u0026gt;sin6_addr); ipver = \u0026#34;IPv6\u0026#34;; } // convert the IP to a string and print it:  inet_ntop(p-\u0026gt;ai_family, addr, ipstr, sizeof ipstr); printf(\u0026#34; %s: %s\\n\u0026#34;, ipver, ipstr); } freeaddrinfo(res); // free the linked list  return 0; } ご覧のように、このコードはコマンドラインで渡されたものに対して getaddrinfo() を呼び出し、res が指すリンクリストを埋めて、そのリストを繰り返し表示して何かを出力したりすることができます。\n(そこには、IP バージョンによって異なるタイプの struct sockaddrs を掘り下げなければならない、ちょっとした醜さがあります。申し訳ありません。他にいい方法はないかなぁ\u0026hellip;)\nサンプル走行！みんな大好きスクリーンショット。\n$ showip www.example.net IP addresses for www.example.net: IPv4: 192.0.2.88 $ showip ipv6.example.com IP addresses for ipv6.example.com: IPv4: 192.0.2.101 IPv6: 2001:db8:8c00:22::171 これで、getaddrinfo() の結果を他のソケット関数に渡して、ついにネットワーク接続を確立することができます。引き続きお読みください。\n5.2 socket()\u0026mdash;Get the File Descriptor! #  もう先延ばしにはできません。socket() システムコールの話をしなければならないのです。以下はその内訳です。\n#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt; int socket(int domain, int type, int protocol); しかし、これらの引数は何なのでしょうか？これらは、どのようなソケットが欲しいか（IPv4 か IPv6 か、ストリームかデータグラムか、TCP か UDP か）を指定することができます。\n以前は、これらの値をハードコードする人がいましたが、今でも絶対にそうすることができます。(ドメインは PF_INET または PF_INET6、タイプは SOCK_STREAM または SOCK_DGRAM、プロトコルは 0 に設定すると、与えられたタイプに適したプロトコルを選択することができます。あるいは getprotobyname() を呼んで、\u0026ldquo;tcp\u0026rdquo; や \u0026ldquo;udp\u0026rdquo; などの欲しいプロトコルを調べることもできます。)\n(この PF_INET は、struct sockaddr_in の sin_family フィールドを初期化するときに使用できる AF_INET の近縁種です。実際、両者は非常に密接な関係にあり、実際に同じ値を持っているので、多くのプログラマは socket() を呼び出して PF_INET の代わりに AF_INET を第一引数に渡しています。さて、ミルクとクッキーを用意して、お話の時間です。昔々、あるアドレスファミリ(AF_INET の AF)が、プロトコルファミリ(PF_INET の PF)で参照される複数のプロトコルをサポートするかもしれないと考えられたことがあります。しかし、そうはなりませんでした。そして、みんな幸せに暮らした、ザ・エンド。というわけで、最も正しいのは struct sockaddr_in で AF_INET を使い、socket() の呼び出しで PF_INET を使うことです。)\nとにかく、もう十分です。本当にやりたいことは、getaddrinfo() の呼び出しの結果の値を使い、以下のように直接 socket() に送り込むことです。\nint s; struct addrinfo hints, *res; // do the lookup // [pretend we already filled out the \u0026#34;hints\u0026#34; struct] getaddrinfo(\u0026#34;www.example.com\u0026#34;, \u0026#34;http\u0026#34;, \u0026amp;hints, \u0026amp;res); // again, you should do error-checking on getaddrinfo(), and walk // the \u0026#34;res\u0026#34; linked list looking for valid entries instead of just // assuming the first one is good (like many of these examples do). // See the section on client/server for real examples.  s = socket(res-\u0026gt;ai_family, res-\u0026gt;ai_socktype, res-\u0026gt;ai_protocol); socket() は単に、後のシステムコールで使用できるソケットディスクリプタを返すか、エラーの場合は -1 を返します。グローバル変数 errno にはエラーの値が設定されます (詳細については [errno(#errnoman) のマニュアルページを参照してください。また、マルチスレッドプログラムで errno を使用する際の簡単な注意も参照してください)。\nでも、このソケットは何の役に立つのでしょうか？答えは、これだけでは本当に意味がなく、もっと読み進めてシステムコールを作らないと意味がないのです。\n5.3 bind()\u0026mdash;What port am I on? #  ソケットを取得したら、そのソケットをローカルマシンのポートに関連付ける必要があるかもしれません。(これは、特定のポートへの接続を listen() する場合によく行われます。多人数参加型ネットワークゲームで \u0026ldquo;192.168.5.10 ポート 3490 に接続\u0026rdquo; と指示されたときに行います)。ポート番号はカーネルが受信パケットを特定のプロセスのソケットディスクリプタにマッチさせるために使用されます。もしあなたが connect() を行うだけなら(あなたはクライアントであり、サーバではないので)、これはおそらく不要でしょう。とにかく読んでみてください。\nbind() システムコールの概要は以下のとおりです。\n#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt; int bind(int sockfd, struct sockaddr *my_addr, int addrlen); sockfd は socket() が返すソケットファイル記述子です。my_addr は自分のアドレスに関する情報、すなわちポートおよび IP アドレスを含む sockaddr 構造体へのポインタです。\nふぅー。一度に吸収するのはちょっと無理があるな。ソケットをプログラムが実行されているホスト、ポート 3490 にバインドする例を見てみましょう。\nstruct addrinfo hints, *res; int sockfd; // first, load up address structs with getaddrinfo():  memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // use IPv4 or IPv6, whichever hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; // fill in my IP for me  getaddrinfo(NULL, \u0026#34;3490\u0026#34;, \u0026amp;hints, \u0026amp;res); // make a socket:  sockfd = socket(res-\u0026gt;ai_family, res-\u0026gt;ai_socktype, res-\u0026gt;ai_protocol); // bind it to the port we passed in to getaddrinfo():  bind(sockfd, res-\u0026gt;ai_addr, res-\u0026gt;ai_addrlen); AI_PASSIVE フラグを使うことで、プログラムが動作しているホストの IP にバインドするように指示しているのです。もし、特定のローカル IP アドレスにバインドしたい場合は、AI_PASSIVE を削除して、getaddrinfo() の最初の引数に IP アドレスを入れてください。\nbind() もエラー時には -1 を返し、errno にエラーの値を設定します。\n多くの古いコードでは、bind() を呼び出す前に、struct sockaddr_in を手動でパックしています。これは明らかに IPv4 特有のものですが、IPv6 で同じことをするのを止めるものは何もありません。ただし、一般的には getaddrinfo() を使う方が簡単になりそうです。とにかく、古いコードは次のようなものです。\n// !!! THIS IS THE OLD WAY !!!  int sockfd; struct sockaddr_in my_addr; sockfd = socket(PF_INET, SOCK_STREAM, 0); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(MYPORT); // short, network byte order my_addr.sin_addr.s_addr = inet_addr(\u0026#34;10.12.110.57\u0026#34;); memset(my_addr.sin_zero, \u0026#39;\\0\u0026#39;, sizeof my_addr.sin_zero); bind(sockfd, (struct sockaddr *)\u0026amp;my_addr, sizeof my_addr); 上記のコードでは、ローカルの IP アドレスにバインドしたい場合、s_addr フィールドに INADDR_ANY を代入することもできます（上記の AI_PASSIVE フラグのようなものです）。INADDR_ANY の IPv6 バージョンはグローバル変数 in6addr_any で、struct sockaddr_in6 の sin6_addr フィールドに代入されます。(変数の初期化で使用できるマクロ IN6ADDR_ANY_INIT も存在します。)また、IN6ADDR_ANY_INIT を使用することで、IPv6 の IP アドレスにバインドできます。\nbind() を呼ぶときにもうひとつ気をつけなければならないのは、ポート番号で下手を打たないことです。1024 以下のポートはすべて予約済みです(あなたがスーパーユーザでない限り)！それ以上のポート番号は、(他のプログラムによってすでに使われていなければ) 65535 までの任意のポート番号を使用することができます。\n時々、サーバを再実行しようとすると、bind() が \u0026ldquo;Address already in use\u0026rdquo; と言って失敗することに気がつくかもしれません。これはどういうことでしょう? それは、接続されたソケットの一部がまだカーネル内に残っていて、ポートを占有しているのです。それが消えるのを待つか(1分くらい)、次のようにポートが再利用できるようなコードをプログラムに追加します。\nint yes=1; //char yes=\u0026#39;1\u0026#39;; // Solaris people use this  // lose the pesky \u0026#34;Address already in use\u0026#34; error message if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,\u0026amp;yes,sizeof yes) == -1) { perror(\u0026#34;setsockopt\u0026#34;); exit(1); } bind() について、最後にちょっとした注意点があります。bind() を絶対に呼び出す必要がない場合があります。リモートマシンに connect() する際に、ローカルポートを気にしない場合 (telnet のようにリモートポートを気にする場合) は、単に connect() をコールすれば、ソケットが未束縛かどうかをチェックし、必要なら未使用のローカルポートに bind() してくれます。\n5.4 connect()\u0026mdash;Hey, you! #  ちょっとだけ、あなたが telnet アプリケーションであることを仮定してみましょう。ユーザが（映画 TRON のように）ソケットファイル記述子を取得するように命令します。あなたはそれに応じ、socket() を呼び出します。次に、ユーザはポート \u0026ldquo;23\u0026rdquo; (標準的な telnet ポート) で \u0026ldquo;10.12.110.57\u0026rdquo; に接続するように指示します。やったー! どうするんだ？\n幸運なことに、あなたは今、connect()の章\u0026mdash;リモートホストに接続する方法を読んでいるところです。だから、猛烈に読み進めよう！時間がない！\nconnect()の呼び出しは以下の通りです。\n#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt; int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); sockfd は socket() コールで返される、我々の身近なソケットファイル記述子、serv_addr は宛先ポートと IP アドレスを含む struct sockaddr、addrlen はサーバアドレス構造体のバイト長です。\nこれらの情報はすべて、getaddrinfo() の呼び出しの結果から得ることができ、これはロックします。\nだんだん分かってきたかな？ここからは聞こえないので、そうであることを祈るしかないですね。ポート 3490 の \u0026ldquo;www.example.com\u0026rdquo; にソケット接続する例を見てみましょう。\nstruct addrinfo hints, *res; int sockfd; // first, load up address structs with getaddrinfo():  memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; getaddrinfo(\u0026#34;www.example.com\u0026#34;, \u0026#34;3490\u0026#34;, \u0026amp;hints, \u0026amp;res); // make a socket:  sockfd = socket(res-\u0026gt;ai_family, res-\u0026gt;ai_socktype, res-\u0026gt;ai_protocol); // connect!  connect(sockfd, res-\u0026gt;ai_addr, res-\u0026gt;ai_addrlen); 繰り返しになりますが、古いタイプのプログラムでは、独自の struct sockaddr_ins を作成して connect() に渡していました。必要であれば、そうすることができます。上の bind() の節で同様のことを書いています。\nconnect() の戻り値を必ず確認してください。エラー時に -1 が返され、errno という変数がセットされます。\nまた、bind() を呼んでいないことに注意してください。基本的に、私たちはローカルのポート番号には関心がありません。カーネルは私たちのためにローカルポートを選択し、接続先のサイトは自動的にこの情報を取得します。心配はいりません。\n5.5 listen()\u0026mdash;Will somebody please call me? #  よし、気分転換の時間です。リモートホストに接続したくない場合はどうすればいいのでしょう。例えば、接続が来るのを待ち、何らかの方法でそれを処理したいとします。この処理は2段階です。まず listen() を行い、次に accept() を行います (後述)。\nlisten() の呼び出しはかなり単純ですが、少し説明が必要です。\nint listen(int sockfd, int backlog); sockfd は socket() システムコールから得られる通常のソケットファイル記述子です。これはどういう意味でしょうか？着信した接続は、accept() (後述) するまでこのキューで待機することになりますが、このキューに入れることができる数の上限を表しているのです。ほとんどのシステムでは、この数を黙って約 20 に制限しています。おそらく、5 や 10 に設定しても大丈夫でしょう。\nここでも、いつものように listen() はエラー時に -1 を返し、errno をセットします。\nさて、想像がつくと思いますが、サーバが特定のポートで動作するように listen() を呼び出す前に bind() を呼び出す必要があります。(どのポートに接続するかを仲間に伝えることができなければなりません！) ですから、もし接続を待ち受けるのであれば、一連のシステムコールは次のようになります。\ngetaddrinfo(); socket(); bind(); listen(); /* accept() goes here */ かなり自明なので、サンプルコードの代わりに置いておきます。(以下の accept() 章のコードはより完全なものです。) この全体の中で本当に厄介なのは、accept() の呼び出しです。\n5.6 accept()\u0026mdash;\u0026ldquo;Thank you for calling port 3490.\u0026rdquo; #  accept() の呼び出しはちょっと変です。これから起こることはこうです。遠く離れた誰かが、あなたが listen() しているポートであなたのマシンに connect() しようとするでしょう。その接続は、accept() されるのを待つためにキューに入れられることになります。あなたは accept() をコールし、保留中の接続を取得するように指示します。すると、この接続に使用する新しいソケットファイル記述子が返されます！そうです、1つの値段で2つのソケットファイル記述子を手に入れたことになります。元のソケットファイル記述子はまだ新しい接続を待ち続けており、新しく作成されたソケットファイル記述子はようやく send() と recv() を行う準備が整いました。着いたぞ！\nコールは以下の通りです。\n#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); sockfd は listen() するソケットディスクリプタです。addr は通常、ローカルのstruct sockaddr_storage へのポインタになります。この構造体には、着信接続に関する情報が格納されます(これにより、どのホストがどのポートから電話をかけてきたかを判断することができます)。addrlen はローカルの整数型変数で、そのアドレスが accept() に渡される前に sizeof(struct sockaddr_storage) に設定されなければなりません。accept() は、addr にそれ以上のバイト数を入れることはありません。もし、それ以下のバイト数であれば、addrlen の値を変更します。\n何だと思いますか？accept() はエラーが発生した場合は -1 を返し、errno をセットします。そうだったんですか。\n前回と同様、一度に吸収するのは大変なので、サンプルコードの一部をご覧ください。\n#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netdb.h\u0026gt; #define MYPORT \u0026#34;3490\u0026#34; // the port users will be connecting to #define BACKLOG 10 // how many pending connections queue will hold  int main(void) { struct sockaddr_storage their_addr; socklen_t addr_size; struct addrinfo hints, *res; int sockfd, new_fd; // !! don\u0026#39;t forget your error checking for these calls !!  // first, load up address structs with getaddrinfo():  memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // use IPv4 or IPv6, whichever  hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; // fill in my IP for me  getaddrinfo(NULL, MYPORT, \u0026amp;hints, \u0026amp;res); // make a socket, bind it, and listen on it:  sockfd = socket(res-\u0026gt;ai_family, res-\u0026gt;ai_socktype, res-\u0026gt;ai_protocol); bind(sockfd, res-\u0026gt;ai_addr, res-\u0026gt;ai_addrlen); listen(sockfd, BACKLOG); // now accept an incoming connection:  addr_size = sizeof their_addr; new_fd = accept(sockfd, (struct sockaddr *)\u0026amp;their_addr, \u0026amp;addr_size); // ready to communicate on socket descriptor new_fd!  . . . ここでも、すべての send() と recv() の呼び出しに、ソケットディスクリプタ new_fd を使用することに注意してください。もし、一度しか接続がないのであれば、同じポートからの接続を防ぐために、listen している sockfd を close() することができます。\n5.7 send() and recv()\u0026mdash;Talk to me, baby! #  この2つの関数は、ストリームソケットまたは接続されたデータグラムソケットで通信を行うためのものです。通常の非接続型データグラムソケットを使いたい場合は、以下の sendto() and recvfrom() の節を参照する必要があります。\nsend() 呼び出し。\nint send(int sockfd, const void *msg, int len, int flags); sockfd はデータを送信したいソケットディスクリプタ（socket() で返されたものでも accept() で取得したものでも可）、msg は送信したいデータへのポインタ、len はそのデータの長さ(バイト数)です。flags を 0 に設定するだけです(フラグに関する詳しい情報は send() の man ページを参照してください)。\nサンプルコードとしては、以下のようなものがあります。\nchar *msg = \u0026#34;Beej was here!\u0026#34;; int len, bytes_sent; . . . len = strlen(msg); bytes_sent = send(sockfd, msg, len, 0); . . . send() は実際に送信されたバイト数を返しますが、これは送信するように指示した数よりも少ないかもしれません！つまり、大量のデータを送信するように指示しても、それが処理しきれないことがあるのです。その場合、できる限りのデータを送信し、残りは後で送信するように指示します。send() が返す値が len の値と一致しない場合、残りの文字列を送信するかどうかはあなた次第だということを覚えておいてください。良いニュースはこれです。パケットが小さければ（1K以下とか）、 おそらく全部を一度に送信することができるでしょう。ここでも、エラー時には -1 が返され、 errno にはエラー番号がセットされます。\nrecv() 呼び出しは、多くの点で類似しています。\nint recv(int sockfd, void *buf, int len, int flags); sockfd は読み込むソケットディスクリプタ、buf は情報を読み込むバッファ、len はバッファの最大長、flags は再び 0 に設定できます(フラグについては recv() の man ページを参照してください)。\nrecv() は、実際にバッファに読み込まれたバイト数を返し、エラーの場合は -1 を返します（それに応じて errno が設定されます）。\n待ってください！recv() は 0 を返すことがあります。これは、リモート側が接続を切断したことを意味します！0 という返り値は、recv() がこのような事態が発生したことをあなたに知らせるためのものです。\nほら、簡単だったでしょう？これでストリームソケットでデータのやり取りができるようになったぞ。やったー！あなたは Unix ネットワークプログラマーです！\n5.8 sendto() and recvfrom()\u0026mdash;Talk to me, DGRAM-style #  \u0026ldquo;これはすべて素晴らしく、ダンディーだ\u0026rdquo;、\u0026ldquo;しかし、データグラムソケットを接続しないままにしておくのはどうなんだ？\u0026quot;、という声が聞こえてきそうです。大丈夫だ、アミーゴ。ちょうどいいものがありますよ。\nデータグラムソケットはリモートホストに接続されていないので、パケットを送信する前にどのような情報を与える必要があるか分かりますか？そうです！宛先アドレスです！これがそのスコープです。\nint sendto(int sockfd, const void *msg, int len, unsigned int flags, const struct sockaddr *to, socklen_t tolen); 見ての通り、この呼び出しは基本的に send() の呼び出しと同じで、他に2つの情報が追加されています。to は struct sockaddr へのポインタで（おそらく直前にキャストした別の struct sockaddr_in や struct sockaddr_in6、struct sockaddr_storage になるでしょう）、送信先の IP アドレスとポートが含まれています。tolen は int 型ですが、単純に sizeof *to または sizeof(struct sockaddr_storage) に設定することができます。\n宛先アドレスの構造体を手に入れるには、getaddrinfo() や以下の recvfrom() から取得するか、手で記入することになると思います。\nsend() と同様、sendto() は実際に送信したバイト数 (これも、送信するように指示したバイト数よりも少ないかもしれません！) を返し、エラーの場合は -1 を返します。\n同様に、recv() と recvfrom() も類似しています。recvfrom() の概要は以下の通りです。\nint recvfrom(int sockfd, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen); これも recv() と同様であるが、いくつかのフィールドが追加されています。from はローカルの struct sockaddr_storage へのポインタで、送信元のマシンの IP アドレスとポートが格納されます。fromlen はローカルの int へのポインタであり、sizeof *from または sizeof(struct sockaddr_storage) に初期化する必要があります。この関数が戻ったとき、fromlen は実際に from に格納されたアドレスの長さを含みます。\nrecvfrom() は受信したバイト数を返し、エラーの場合は -1 を返します（errno はそれに応じて設定されます）。\nそこで質問ですが、なぜソケットの型として struct sockaddr_storage を使うのでしょうか？なぜ、struct sockaddr_in ではないのでしょうか？なぜなら、私たちは IPv4 や IPv6 に縛られたくないからです。そこで、汎用的な構造体である sockaddr_storage を使用するのですが、これはどちらにも十分な大きさであることが分かっています。\n（そこで\u0026hellip;ここでまた疑問なのですが、なぜ struct sockaddr 自体はどんなアドレスに対しても十分な大きさがないのでしょうか？汎用 struct sockaddr_storage を汎用 struct sockaddr にキャストしているくらいなのに！？余計なことをしたような気がしますね。答えは、十分な大きさがなく、この時点で変更するのは問題がある、ということでしょう。だから新しいのを作ったんだ。）\nデータグラムソケットを connect() すれば、すべてのトランザクションに send() と recv() を使用できることを覚えておいてください。ソケット自体はデータグラムソケットであり、パケットは UDP を使用しますが、ソケットインターフェイスが自動的に宛先と送信元の情報を追加してくれるのです。\n5.9 close() and shutdown()\u0026mdash;Get outta my face! #  ふぅー 一日中データの送受信（send()ing と recv()ing）をしていて、もう限界だ。ソケットディスクリプタの接続を閉じる準備ができました。これは簡単です。通常の Unix ファイルディスクリプタの close() 関数を使えばいいのです。\nclose(sockfd); これにより、それ以上のソケットへの読み書きができなくなります。リモート側でソケットの読み書きをしようとすると、エラーが発生します。\nソケットの閉じ方をもう少し制御したい場合は、shutdown() 関数を使用します。この関数では、特定の方向、あるいは両方の通信を遮断することができます (ちょうど close() がそうであるように)。概要:\nint shutdown(int sockfd, int how); sockfd はシャットダウンしたいソケットファイル記述子、how は以下のいずれかです。\n   how Effect     0 それ以上の受信は不可   1 それ以上の送信は禁止   2 それ以上の送受信は禁止(close()のように)    shutdown() は成功すると 0 を、エラーが発生すると -1 を返します（errno は適宜設定されます）。\nデータグラムソケットが接続されていない状態で shutdown() を使用すると、それ以降の send() および recv() 呼び出しに使用できなくなります（データグラムソケットを connect() した場合、これらを使用できることを忘れないでください）。\nshutdown() は実際にはファイルディスクリプタを閉じないことに注意することが重要です。ソケットディスクリプタを解放するには、close() を使用する必要があります。\n何もないんだけどね。\n（ただし、Windows と Winsock を使用している場合は、close() ではなく closesocket() を呼び出すべきであることを忘れないでください。）\n5.10 getpeername()\u0026mdash;Who are you? #  この関数はとても簡単です。\nあまりに簡単なので、ほとんど独自のセクションを設けなかったほどです。でも、とりあえずここに書いておきます。\ngetpeername() 関数は、接続されたストリームソケットのもう一方の端にいるのが誰であるかを教えてくれます。その概要は\n#include \u0026lt;sys/socket.h\u0026gt; int getpeername(int sockfd, struct sockaddr *addr, int *addrlen); sockfd は接続したストリームソケットのディスクリプタ、addr は接続の相手側の情報を保持する struct sockaddr（または struct sockaddr_in）へのポインタ、addrlen は int へのポインタであり、 sizeof *addr または sizeof(struct sockaddr) で初期化される必要があります。\nこの関数は，エラーが発生すると -1 を返し，それに応じて errno を設定します。\nアドレスがわかれば、inet_ntop()、getnameinfo()、gethostbyaddr() を使って、より詳しい情報を表示したり取得したりすることができます。いいえ、ログイン名を取得することはできません。（OK、OK。相手のコンピュータで ident デーモンが動いていれば、可能です。しかし、これはこのドキュメントの範囲外です。詳しくは RFC 1413 をチェックしてください。）\n5.11 gethostname()\u0026mdash;Who am I? #  getpeername() よりもさらに簡単なのは、gethostname() という関数です。これは、あなたのプログラムが動作しているコンピュータの名前を返します。この名前は、後述の gethostbyname() でローカルマシンの IP アドレスを決定するために使用されます。\nこれ以上楽しいことはないでしょう？いくつか思いつきましたが、ソケットプログラミングには関係ないですね。とにかく、内訳はこんな感じです。\n#include \u0026lt;unistd.h\u0026gt; int gethostname(char *hostname, size_t size); 引数は単純で、hostname はこの関数が戻ったときにホスト名を格納する文字列の配列へのポインタ、size はホスト名配列のバイト長です。\nこの関数は，正常に終了した場合は 0 を，エラーの場合は -1 を返し，通常通り errno を設定します。\n"},{"id":5,"href":"/bgnet/docs/client-server-background/","title":"6 Client-Server Background","section":"Docs","content":"6 Client-Server Background #  クライアント-サーバの世界なのです。ネットワーク上のあらゆることが、クライアント・プロセスとサーバ・プロセスとの対話、またはその逆を扱っています。たとえば、telnet を考えてみよう。ポート 23 のリモートホストに telnet で接続すると（クライアント）、そのホスト上のプログラム（telnetd と呼ばれるサーバ）が起動します。このプログラムは、送られてきた telnet 接続を処理し、ログインプロンプトを表示するなどの設定を行います。\n クライアント-サーバの相互作用  クライアントとサーバ間の情報のやりとりは、上の図のようにまとめられます。\nクライアントとサーバのペアは、SOCK_STREAM、SOCK_DGRAM、その他（同じことを話している限り）何でも話すことができることに注意してください。クライアントとサーバのペアの良い例としては、telnet/telnetd、ftp/ftpd、Firefox/Apache などがあります。ftp を使うときはいつも、リモートプログラム ftpd があなたにサービスを提供します。\n多くの場合、1つのマシンには1つのサーバしかなく、そのサーバは fork() を使用して複数のクライアントを処理します。基本的なルーチンは、サーバが接続を待ち、それを accept() し、それを処理するために子プロセスを fork() する、というものです。これが、次の節で紹介するサンプルサーバが行っていることです。\n6.1 A Simple Stream Server #  このサーバがすることは、ストリーム接続で Hello, world! という文字列を送り出すだけです。このサーバをテストするために必要なことは、あるウィンドウでこのサーバを実行し、別のウィンドウからこのサーバに telnet でアクセスすることだけです。\n$ telnet remotehostname 3490 ここで、remotehostname は実行するマシンの名前です。\n サーバコード\n/* ** server.c -- a stream socket server demo */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;signal.h\u0026gt; #define PORT \u0026#34;3490\u0026#34; // the port users will be connecting to  #define BACKLOG 10 // how many pending connections queue will hold  void sigchld_handler(int s) { // waitpid() might overwrite errno, so we save and restore it:  int saved_errno = errno; while(waitpid(-1, NULL, WNOHANG) \u0026gt; 0); errno = saved_errno; } // get sockaddr, IPv4 or IPv6: void *get_in_addr(struct sockaddr *sa) { if (sa-\u0026gt;sa_family == AF_INET) { return \u0026amp;(((struct sockaddr_in*)sa)-\u0026gt;sin_addr); } return \u0026amp;(((struct sockaddr_in6*)sa)-\u0026gt;sin6_addr); } int main(void) { int sockfd, new_fd; // listen on sock_fd, new connection on new_fd  struct addrinfo hints, *servinfo, *p; struct sockaddr_storage their_addr; // connector\u0026#39;s address information  socklen_t sin_size; struct sigaction sa; int yes=1; char s[INET6_ADDRSTRLEN]; int rv; memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; // use my IP  if ((rv = getaddrinfo(NULL, PORT, \u0026amp;hints, \u0026amp;servinfo)) != 0) { fprintf(stderr, \u0026#34;getaddrinfo: %s\\n\u0026#34;, gai_strerror(rv)); return 1; } // loop through all the results and bind to the first we can  for(p = servinfo; p != NULL; p = p-\u0026gt;ai_next) { if ((sockfd = socket(p-\u0026gt;ai_family, p-\u0026gt;ai_socktype, p-\u0026gt;ai_protocol)) == -1) { perror(\u0026#34;server: socket\u0026#34;); continue; } if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;yes, sizeof(int)) == -1) { perror(\u0026#34;setsockopt\u0026#34;); exit(1); } if (bind(sockfd, p-\u0026gt;ai_addr, p-\u0026gt;ai_addrlen) == -1) { close(sockfd); perror(\u0026#34;server: bind\u0026#34;); continue; } break; } freeaddrinfo(servinfo); // all done with this structure  if (p == NULL) { fprintf(stderr, \u0026#34;server: failed to bind\\n\u0026#34;); exit(1); } if (listen(sockfd, BACKLOG) == -1) { perror(\u0026#34;listen\u0026#34;); exit(1); } sa.sa_handler = sigchld_handler; // reap all dead processes  sigemptyset(\u0026amp;sa.sa_mask); sa.sa_flags = SA_RESTART; if (sigaction(SIGCHLD, \u0026amp;sa, NULL) == -1) { perror(\u0026#34;sigaction\u0026#34;); exit(1); } printf(\u0026#34;server: waiting for connections...\\n\u0026#34;); while(1) { // main accept() loop  sin_size = sizeof their_addr; new_fd = accept(sockfd, (struct sockaddr *)\u0026amp;their_addr, \u0026amp;sin_size); if (new_fd == -1) { perror(\u0026#34;accept\u0026#34;); continue; } inet_ntop(their_addr.ss_family, get_in_addr((struct sockaddr *)\u0026amp;their_addr), s, sizeof s); printf(\u0026#34;server: got connection from %s\\n\u0026#34;, s); if (!fork()) { // this is the child process  close(sockfd); // child doesn\u0026#39;t need the listener  if (send(new_fd, \u0026#34;Hello, world!\u0026#34;, 13, 0) == -1) perror(\u0026#34;send\u0026#34;); close(new_fd); exit(0); } close(new_fd); // parent doesn\u0026#39;t need this  } return 0; } 一応、構文的にわかりやすいように、1つの大きな main() 関数にまとめてあります。もし、その方が良いと思われるなら、自由に小さな関数に分割してください。\n（また、この sigaction() 全体は、あなたにとって新しいものかもしれません\u0026mdash;それは大丈夫です。このコードは、fork() された子プロセスが終了するときに現れるゾンビプロセスを刈り取る役割を担っているのです。ゾンビをたくさん作ってそれを刈り取らないと、システム管理者が怒りますよ。）\nこのサーバからデータを取得するには、次の節に記載されているクライアントを使用します。\n6.2 A Simple Stream Client #  こいつはサーバよりもっと簡単です。このクライアントがすることはコマンドラインで指定したホスト、ポート 3490 に接続するだけです。サーバが送信する文字列を取得します。\n クライアントソース。\n/* ** client.c -- a stream socket client demo */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define PORT \u0026#34;3490\u0026#34; // the port client will be connecting to  #define MAXDATASIZE 100 // max number of bytes we can get at once  // get sockaddr, IPv4 or IPv6: void *get_in_addr(struct sockaddr *sa) { if (sa-\u0026gt;sa_family == AF_INET) { return \u0026amp;(((struct sockaddr_in*)sa)-\u0026gt;sin_addr); } return \u0026amp;(((struct sockaddr_in6*)sa)-\u0026gt;sin6_addr); } int main(int argc, char *argv[]) { int sockfd, numbytes; char buf[MAXDATASIZE]; struct addrinfo hints, *servinfo, *p; int rv; char s[INET6_ADDRSTRLEN]; if (argc != 2) { fprintf(stderr,\u0026#34;usage: client hostname\\n\u0026#34;); exit(1); } memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; if ((rv = getaddrinfo(argv[1], PORT, \u0026amp;hints, \u0026amp;servinfo)) != 0) { fprintf(stderr, \u0026#34;getaddrinfo: %s\\n\u0026#34;, gai_strerror(rv)); return 1; } // loop through all the results and connect to the first we can  for(p = servinfo; p != NULL; p = p-\u0026gt;ai_next) { if ((sockfd = socket(p-\u0026gt;ai_family, p-\u0026gt;ai_socktype, p-\u0026gt;ai_protocol)) == -1) { perror(\u0026#34;client: socket\u0026#34;); continue; } if (connect(sockfd, p-\u0026gt;ai_addr, p-\u0026gt;ai_addrlen) == -1) { close(sockfd); perror(\u0026#34;client: connect\u0026#34;); continue; } break; } if (p == NULL) { fprintf(stderr, \u0026#34;client: failed to connect\\n\u0026#34;); return 2; } inet_ntop(p-\u0026gt;ai_family, get_in_addr((struct sockaddr *)p-\u0026gt;ai_addr), s, sizeof s); printf(\u0026#34;client: connecting to %s\\n\u0026#34;, s); freeaddrinfo(servinfo); // all done with this structure  if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) { perror(\u0026#34;recv\u0026#34;); exit(1); } buf[numbytes] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;client: received \u0026#39;%s\u0026#39;\\n\u0026#34;,buf); close(sockfd); return 0; } クライアントを実行する前にサーバを実行しない場合、connect() は \u0026ldquo;Connection refused\u0026rdquo; を返すことに注意してください。非常に便利です。\n6.3 Datagram Sockets #  UDP データグラムソケットの基本は、上記の 5.8 sendto() and recvfrom() ですでに説明しましたので、ここでは talker.c と listener.c という2つのサンプルプログラムのみを紹介します。\nlistener は、ポート 4950 で入ってくるパケットを待つマシンに座っています。talker は、指定されたマシンのそのポートに、ユーザがコマンドラインに入力したものを含むパケットを送信します。\nデータグラムソケットはコネクションレス型であり、パケットを無慈悲に発射するだけなので、クライアントとサーバには IPv6 を使用するように指示することにしています。こうすることで、サーバが IPv6 でリッスンしていて、クライアントが IPv4 で送信するような状況を避けることができます。（接続された TCP ストリームソケットの世界では、まだ不一致があるかもしれませんが、一方のアドレスファミリーの connect() でエラーが発生すると、他方のアドレスファミリーの再試行が行われます。）\n listener ソースコード\n/* ** listener.c -- a datagram sockets \u0026#34;server\u0026#34; demo */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;netdb.h\u0026gt; #define MYPORT \u0026#34;4950\u0026#34;\t// the port users will be connecting to  #define MAXBUFLEN 100  // get sockaddr, IPv4 or IPv6: void *get_in_addr(struct sockaddr *sa) { if (sa-\u0026gt;sa_family == AF_INET) { return \u0026amp;(((struct sockaddr_in*)sa)-\u0026gt;sin_addr); } return \u0026amp;(((struct sockaddr_in6*)sa)-\u0026gt;sin6_addr); } int main(void) { int sockfd; struct addrinfo hints, *servinfo, *p; int rv; int numbytes; struct sockaddr_storage their_addr; char buf[MAXBUFLEN]; socklen_t addr_len; char s[INET6_ADDRSTRLEN]; memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_INET6; // set to AF_INET to use IPv4 \thints.ai_socktype = SOCK_DGRAM; hints.ai_flags = AI_PASSIVE; // use my IP  if ((rv = getaddrinfo(NULL, MYPORT, \u0026amp;hints, \u0026amp;servinfo)) != 0) { fprintf(stderr, \u0026#34;getaddrinfo: %s\\n\u0026#34;, gai_strerror(rv)); return 1; } // loop through all the results and bind to the first we can \tfor(p = servinfo; p != NULL; p = p-\u0026gt;ai_next) { if ((sockfd = socket(p-\u0026gt;ai_family, p-\u0026gt;ai_socktype, p-\u0026gt;ai_protocol)) == -1) { perror(\u0026#34;listener: socket\u0026#34;); continue; } if (bind(sockfd, p-\u0026gt;ai_addr, p-\u0026gt;ai_addrlen) == -1) { close(sockfd); perror(\u0026#34;listener: bind\u0026#34;); continue; } break; } if (p == NULL) { fprintf(stderr, \u0026#34;listener: failed to bind socket\\n\u0026#34;); return 2; } freeaddrinfo(servinfo); printf(\u0026#34;listener: waiting to recvfrom...\\n\u0026#34;); addr_len = sizeof their_addr; if ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN-1 , 0, (struct sockaddr *)\u0026amp;their_addr, \u0026amp;addr_len)) == -1) { perror(\u0026#34;recvfrom\u0026#34;); exit(1); } printf(\u0026#34;listener: got packet from %s\\n\u0026#34;, inet_ntop(their_addr.ss_family, get_in_addr((struct sockaddr *)\u0026amp;their_addr), s, sizeof s)); printf(\u0026#34;listener: packet is %d bytes long\\n\u0026#34;, numbytes); buf[numbytes] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;listener: packet contains \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, buf); close(sockfd); return 0; } getaddrinfo() の呼び出しで、最終的に SOCK_DGRAM を使用していることに注意してください。また、listen() や accept() は必要ないことに注意してください。これは非接続型データグラムソケットを使用する利点の1つです！\n talker.c ソースコード\n/* ** talker.c -- a datagram \u0026#34;client\u0026#34; demo */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;netdb.h\u0026gt; #define SERVERPORT \u0026#34;4950\u0026#34;\t// the port users will be connecting to  int main(int argc, char *argv[]) { int sockfd; struct addrinfo hints, *servinfo, *p; int rv; int numbytes; if (argc != 3) { fprintf(stderr,\u0026#34;usage: talker hostname message\\n\u0026#34;); exit(1); } memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_INET6; // set to AF_INET to use IPv4 \thints.ai_socktype = SOCK_DGRAM; if ((rv = getaddrinfo(argv[1], SERVERPORT, \u0026amp;hints, \u0026amp;servinfo)) != 0) { fprintf(stderr, \u0026#34;getaddrinfo: %s\\n\u0026#34;, gai_strerror(rv)); return 1; } // loop through all the results and make a socket \tfor(p = servinfo; p != NULL; p = p-\u0026gt;ai_next) { if ((sockfd = socket(p-\u0026gt;ai_family, p-\u0026gt;ai_socktype, p-\u0026gt;ai_protocol)) == -1) { perror(\u0026#34;talker: socket\u0026#34;); continue; } break; } if (p == NULL) { fprintf(stderr, \u0026#34;talker: failed to create socket\\n\u0026#34;); return 2; } if ((numbytes = sendto(sockfd, argv[2], strlen(argv[2]), 0, p-\u0026gt;ai_addr, p-\u0026gt;ai_addrlen)) == -1) { perror(\u0026#34;talker: sendto\u0026#34;); exit(1); } freeaddrinfo(servinfo); printf(\u0026#34;talker: sent %d bytes to %s\\n\u0026#34;, numbytes, argv[1]); close(sockfd); return 0; } と、これだけです！listener をあるマシンで実行し、次に takler を別のマシンで実行します。それらのコミュニケーションをご覧ください！核家族で楽しめるG級興奮体験です！\n今回はサーバを動かす必要もありません。talker はただ楽しくパケットをエーテルに発射し、相手側に recvfrom() の準備が出来ていなければ消えてしまうのです。UDP データグラムソケットを使用して送信されたデータは、到着が保証されていないことを思い出してください！\n過去に何度も述べた、もうひとつの小さなディテールを除いては、コネクテッド・データグラム・ソケットです。このドキュメントのデータグラムセクションにいるので、ここでこれについて話す必要があります。例えば、talker が connect() を呼び出して listener のアドレスを指定したとします。それ以降、talker は connect() で指定されたアドレスにのみ送信と受信ができます。このため、sendto() と recvfrom() を使う必要はなく、単に send() と recv() を使えばいいのです。\n"},{"id":6,"href":"/bgnet/docs/slightly-advanced-techniques/","title":"7 Slightly Advanced Techniques","section":"Docs","content":"7 Slightly Advanced Techniques #  これらは本当に高度なものではありませんが、私たちがすでにカバーしたより基本的なレベルから抜け出したものです。実際、ここまでくれば、Unix ネットワークプログラミングの基本をかなり習得したと考えてよいでしょう！おめでとうございます！\nさて、ここからは、より難解な事柄の勇敢な新世界に突入します。ソケットについて学ぶことができます。どうぞお楽しみに！\n7.1 Blocking #  ブロッキング。聞いたことがあると思います\u0026mdash;さて、一体何でしょう？一言で言えば、\u0026ldquo;ブロック\u0026quot;は技術用語で\u0026quot;スリープ\u0026quot;のことです。上で listener を実行したとき、パケットが到着するまでただそこに座っていることに気付いたと思います。何が起こったかというと、recvfrom() を呼び出したのですが、データがなかったので、recvfrom() はデータが到着するまで \u0026ldquo;block\u0026rdquo;（つまり、そこで眠る）と言われているのです。\n多くの関数がブロックします。accept() がブロックします。すべての recv() 関数がブロックします。このようなことができるのは、ブロックすることが許されているからです。最初に socket() でソケットディスクリプタを作成するとき、カーネルはそれをブロッキングに設定します。もし、ソケットをブロッキングさせたくなければ、fcntl() を呼び出す必要があります。\n#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;. . . sockfd = socket(PF_INET, SOCK_STREAM, 0); fcntl(sockfd, F_SETFL, O_NONBLOCK); . . . ソケットをノンブロッキングに設定することで、効果的にソケットの情報を\u0026quot;ポール\u0026quot;することができます。ノンブロッキングソケットから読み込もうとしたときに、そこにデータがない場合、ブロックすることは許されません\u0026mdash;その際には -1 が返り、errno には EAGAIN または EWOULDBLOCK がセットされます。\n（待てよ\u0026ndash;EAGAIN や EWOULDBLOCK を返すこともあるのか？どちらをチェックする？仕様では実際にあなたのシステムがどちらを返すかは指定されていないので、移植性のために両方チェックしましょう。）\nしかし、一般的に言って、この種のポーリングは悪い考えです。ソケットのデータを探すためにプログラムをビジーウェイト状態にすると、流行遅れのように CPU 時間を吸い取られてしまうからです。読み込み待ちのデータがあるかどうかを確認するための、よりエレガントなソリューションが、次の poll() の節で紹介されています。\n7.2 poll()\u0026mdash;Synchronous I/O Multiplexing #  本当にやりたいことは、一度にたくさんのソケットを監視して、データの準備ができたものを処理することです。そうすれば、すべてのソケットを継続的にポーリングして、どれが読み込み可能な状態にあるかを確認する必要がなくなります。\n 警告: poll() は膨大な数のコネクションを持つ場合、恐ろしく遅くなります。そのような状況では、システムで利用可能な最も高速なメソッドを使用しようとする libevent のようなイベントライブラリの方が良いパフォーマンスを得ることができるでしょう。\n では、どうすればポーリングを回避できるのでしょうか。少し皮肉なことに、poll() システムコールを使えばポーリングを避けることができます。簡単に言うと、オペレーティングシステムにすべての汚い仕事を代行してもらい、どのソケットでデータが読めるようになったかだけを知らせてもらうのです。その間、我々のプロセスはスリープして、システムリソースを節約することができます。\n一般的なゲームプランは、どのソケットディスクリプタを監視したいか、どのような種類のイベントを監視したいかという情報を struct pollfd の配列として保持することです。OS は、これらのイベントのいずれかが発生するか（例えば \u0026ldquo;socket ready to read!\u0026quot;）またはユーザが指定したタイムアウトが発生するまで poll() 呼び出しでブロックします。\n便利なことに、 listen()しているソケットは、新しい接続が accept() される準備ができたときに \u0026ldquo;ready to read\u0026rdquo; を返します。\n雑談はこのくらいにして。これをどう使うかです？\n#include \u0026lt;poll.h\u0026gt; int poll(struct pollfd fds[], nfds_t nfds, int timeout); fds は情報の配列（どのソケットの何を監視するか）、nfds は配列の要素数、そして timeout はミリ秒単位のタイムアウトです。timeout はミリ秒単位のタイムアウトで、poll はイベントが発生した配列の要素数を返します。\nstruct pollfd を見てみましょう。\nstruct pollfd { int fd; // the socket descriptor  short events; // bitmap of events we\u0026#39;re interested in  short revents; // when poll() returns, bitmap of events that occurred }; そして、その配列を用意するんだ。各要素の fd フィールドに、監視したいソケットディスクリプタを指定します。そして、events フィールドには、監視するイベントの種類を指定します。\nevents フィールドは、以下のビット単位の OR です。\n   Macro 説明     POLLIN このソケットで recv() のためのデータが準備できたときに警告を出す。   POLLOUT このソケットにブロックせずにデータを send() できるようになったら警告します。    一旦 struct pollfd の配列を整えたら、それを poll() に渡すことができます。配列のサイズと、ミリ秒単位のタイムアウト値も一緒に渡してください。（タイムアウトに負の値を指定すると、永遠に待つことができます。）\npoll() が返った後、revents フィールドをチェックして、POLLIN または POLLOUT がセットされているかどうかを確認し、イベントが発生したことを示すことができます。\n（実際には poll() の呼び出しでできることはもっとたくさんあります。詳細は以下の poll() man ページを参照してください。）\nここでは、標準入力からデータを読み込めるようになるまで、つまり RETURN を押したときに 2.5 秒間待つ 例を示します。\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;poll.h\u0026gt; int main(void) { struct pollfd pfds[1]; // More if you want to monitor more  pfds[0].fd = 0; // Standard input  pfds[0].events = POLLIN; // Tell me when ready to read  // If you needed to monitor other things, as well:  //pfds[1].fd = some_socket; // Some socket descriptor  //pfds[1].events = POLLIN; // Tell me when ready to read  printf(\u0026#34;Hit RETURN or wait 2.5 seconds for timeout\\n\u0026#34;); int num_events = poll(pfds, 1, 2500); // 2.5 second timeout  if (num_events == 0) { printf(\u0026#34;Poll timed out!\\n\u0026#34;); } else { int pollin_happened = pfds[0].revents \u0026amp; POLLIN; if (pollin_happened) { printf(\u0026#34;File descriptor %d is ready to read\\n\u0026#34;, pfds[0].fd); } else { printf(\u0026#34;Unexpected event occurred: %d\\n\u0026#34;, pfds[0].revents); } } return 0; } poll() が pfds 配列の中でイベントが発生した要素の数を返していることに再度注目してください。これは配列のどの要素かを教えてくれるわけではありませんが（そのためにはまだスキャンしなければなりません）、revents フィールドが 0 以外のエントリがいくつあるかを教えてくれます（したがって、その数がわかったらスキャンをやめることができます。）\nここで、いくつかの疑問が出てくるかもしれません。poll() に渡したセットに新しいファイルディスクリプタを追加するにはどうしたらいいのでしょうか？これについては、単に配列に必要なだけのスペースがあることを確認するか、必要に応じて realloc() でスペースを追加してください。\nセットから項目を削除する場合はどうすればよいのでしょうか。この場合は、配列の最後の要素をコピーして、削除する要素の上に置くことができます。そして、その数をひとつ減らして poll() に渡します。もうひとつの方法として、fd フィールドに負の数を設定すると、poll() はそれを無視します。\nどうすれば、telnet できるチャットサーバにまとめることができるのでしょうか？\nこれから行うのは、リスナーソケットを起動し、それをファイルディスクリプタのセットに追加して poll() に送ることです。（これは、接続があったときに読み込み可能な状態を表示します。）\nそして、新しい接続を struct pollfd 配列に追加していきます。そして、容量が足りなくなったら、動的にそれを増やしていきます。\n接続が終了したら、その接続を配列から削除します。\nそして、ある接続が読み取り可能になったら、そこからデータを読み取り、そのデータを他のすべての接続に送ることで、他のユーザが入力した内容を見ることができるようにします。\nそこで、 このポール・サーバを試してみてください。あるウィンドウで実行し、他の多くのターミナルウィンドウから telnet localhost 9034 を実行してみてください。一つのウィンドウで入力したものが他のウィンドウでも（RETURNを押した後で）見られるようになるはずです。\nそれだけでなく、CTRL-] を押して quit とタイプして telnet を終了すると、サーバは切断を検出し、ファイルディスクリプタの配列からあなたを削除するはずです。\n/* ** pollserver.c -- a cheezy multiperson chat server */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;poll.h\u0026gt; #define PORT \u0026#34;9034\u0026#34; // Port we\u0026#39;re listening on  // Get sockaddr, IPv4 or IPv6: void *get_in_addr(struct sockaddr *sa) { if (sa-\u0026gt;sa_family == AF_INET) { return \u0026amp;(((struct sockaddr_in*)sa)-\u0026gt;sin_addr); } return \u0026amp;(((struct sockaddr_in6*)sa)-\u0026gt;sin6_addr); } // Return a listening socket int get_listener_socket(void) { int listener; // Listening socket descriptor  int yes=1; // For setsockopt() SO_REUSEADDR, below  int rv; struct addrinfo hints, *ai, *p; // Get us a socket and bind it  memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; if ((rv = getaddrinfo(NULL, PORT, \u0026amp;hints, \u0026amp;ai)) != 0) { fprintf(stderr, \u0026#34;selectserver: %s\\n\u0026#34;, gai_strerror(rv)); exit(1); } for(p = ai; p != NULL; p = p-\u0026gt;ai_next) { listener = socket(p-\u0026gt;ai_family, p-\u0026gt;ai_socktype, p-\u0026gt;ai_protocol); if (listener \u0026lt; 0) { continue; } // Lose the pesky \u0026#34;address already in use\u0026#34; error message  setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, \u0026amp;yes, sizeof(int)); if (bind(listener, p-\u0026gt;ai_addr, p-\u0026gt;ai_addrlen) \u0026lt; 0) { close(listener); continue; } break; } freeaddrinfo(ai); // All done with this  // If we got here, it means we didn\u0026#39;t get bound  if (p == NULL) { return -1; } // Listen  if (listen(listener, 10) == -1) { return -1; } return listener; } // Add a new file descriptor to the set void add_to_pfds(struct pollfd *pfds[], int newfd, int *fd_count, int *fd_size) { // If we don\u0026#39;t have room, add more space in the pfds array  if (*fd_count == *fd_size) { *fd_size *= 2; // Double it  *pfds = realloc(*pfds, sizeof(**pfds) * (*fd_size)); } (*pfds)[*fd_count].fd = newfd; (*pfds)[*fd_count].events = POLLIN; // Check ready-to-read  (*fd_count)++; } // Remove an index from the set void del_from_pfds(struct pollfd pfds[], int i, int *fd_count) { // Copy the one from the end over this one  pfds[i] = pfds[*fd_count-1]; (*fd_count)--; } // Main int main(void) { int listener; // Listening socket descriptor  int newfd; // Newly accept()ed socket descriptor  struct sockaddr_storage remoteaddr; // Client address  socklen_t addrlen; char buf[256]; // Buffer for client data  char remoteIP[INET6_ADDRSTRLEN]; // Start off with room for 5 connections  // (We\u0026#39;ll realloc as necessary)  int fd_count = 0; int fd_size = 5; struct pollfd *pfds = malloc(sizeof *pfds * fd_size); // Set up and get a listening socket  listener = get_listener_socket(); if (listener == -1) { fprintf(stderr, \u0026#34;error getting listening socket\\n\u0026#34;); exit(1); } // Add the listener to set  pfds[0].fd = listener; pfds[0].events = POLLIN; // Report ready to read on incoming connection  fd_count = 1; // For the listener  // Main loop  for(;;) { int poll_count = poll(pfds, fd_count, -1); if (poll_count == -1) { perror(\u0026#34;poll\u0026#34;); exit(1); } // Run through the existing connections looking for data to read  for(int i = 0; i \u0026lt; fd_count; i++) { // Check if someone\u0026#39;s ready to read  if (pfds[i].revents \u0026amp; POLLIN) { // We got one!!  if (pfds[i].fd == listener) { // If listener is ready to read, handle new connection  addrlen = sizeof remoteaddr; newfd = accept(listener, (struct sockaddr *)\u0026amp;remoteaddr, \u0026amp;addrlen); if (newfd == -1) { perror(\u0026#34;accept\u0026#34;); } else { add_to_pfds(\u0026amp;pfds, newfd, \u0026amp;fd_count, \u0026amp;fd_size); printf(\u0026#34;pollserver: new connection from %s on \u0026#34; \u0026#34;socket %d\\n\u0026#34;, inet_ntop(remoteaddr.ss_family, get_in_addr((struct sockaddr*)\u0026amp;remoteaddr), remoteIP, INET6_ADDRSTRLEN), newfd); } } else { // If not the listener, we\u0026#39;re just a regular client  int nbytes = recv(pfds[i].fd, buf, sizeof buf, 0); int sender_fd = pfds[i].fd; if (nbytes \u0026lt;= 0) { // Got error or connection closed by client  if (nbytes == 0) { // Connection closed  printf(\u0026#34;pollserver: socket %d hung up\\n\u0026#34;, sender_fd); } else { perror(\u0026#34;recv\u0026#34;); } close(pfds[i].fd); // Bye!  del_from_pfds(pfds, i, \u0026amp;fd_count); } else { // We got some good data from a client  for(int j = 0; j \u0026lt; fd_count; j++) { // Send to everyone!  int dest_fd = pfds[j].fd; // Except the listener and ourselves  if (dest_fd != listener \u0026amp;\u0026amp; dest_fd != sender_fd) { if (send(dest_fd, buf, nbytes, 0) == -1) { perror(\u0026#34;send\u0026#34;); } } } } } // END handle data from client  } // END got ready-to-read from poll()  } // END looping through file descriptors  } // END for(;;)--and you thought it would never end!  return 0; } 次の節では、似たような古い関数である select() について見ていきます。select() と poll() はどちらも似たような機能とパフォーマンスを持っており、どのように使うかが違うだけです。select() の方が若干移植性が高いかもしれませんが、使い勝手は少し悪いかもしれません。あなたのシステムでサポートされている限り、一番好きなものを選んでください。\n7.3 select()\u0026mdash;Synchronous I/O Multiplexing, Old School #  この関数、ちょっと不思議なんですが、とても便利なんです。次のような状況を考えてみましょう。あなたはサーバで、入ってくるコネクションをリッスンするだけでなく、すでに持っているコネクションを読み続けたいのです。\n問題ありません。accept() と recv() を数回実行するだけです。そうはいかないよ、バスター！もし accept() の呼び出しがブロックされていたらどうでしょう？どうやって recv() を同時に行うんだ？\u0026ldquo;ノンブロッキングソケットを使いましょう！\u0026ldquo;まさか！CPU を占有するようなことはしない方がいい。じゃあ、何？\nselect() は同時に複数のソケットを監視する力を与えてくれます。どのソケットが読み込み可能で、どのソケットが書き込み可能か、そしてどのソケットが例外を発生させたか、本当に知りたければ教えてくれるでしょう。\n 警告: select() は非常にポータブルですが、巨大な数の接続が発生した場合には恐ろしく遅くなります。そのような状況では、 libevent のようなイベントライブラリの方が、あなたのシステムで利用可能な最も高速なメソッドを使用しようとするため、より良いパフォーマンスを得ることができることでしょう。\n さっそくですが、select()の概要を説明します。\n#include \u0026lt;sys/time.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int select(int numfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); この関数は、ファイルディスクリプタの\u0026quot;集合\u0026rdquo;、特に readfds、writefds、exceptfds を監視します。標準入力とソケットディスクリプタ sockfd から読み込めるかどうかを確認したい場合、ファイルディスクリプタ 0 と sockfd を readfds の集合に追加するだけでよいです。パラメータ numfds には、最も大きいファイルディスクリプタの値に 1 を足した値を設定する必要があります。この例では、標準入力 (0) よりも確実に大きいので、sockfd+1 に設定する必要があります。\nselect() が戻ると、readfds は、選択したファイルディスクリプタのうち、どれが読み込める状態にあるかを反映するように変更されます。以下のマクロ FD_ISSET() を用いて、それらをテストすることができます。\nこの先に進む前に、これらのセットを操作する方法について説明します。各セットは fd_set 型です。以下のマクロはこの型を操作します。\n   Function 説明     FD_SET(int fd, fd_set *set); set に fd を追加します。   FD_CLR(int fd, fd_set *set); set から fd を削除します。   FD_ISSET(int fd, fd_set *set); fd が set に含まれる場合は true を返します。   FD_ZERO(fd_set *set); set からすべてのエントリをクリアします。    最後に、この奇妙な struct timeval とは何でしょうか？まあ、誰かがデータを送ってくるのをいつまでも待っていたくない場合もあるでしょう。例えば、96 秒ごとに \u0026ldquo;Still Going\u0026hellip;\u0026rdquo; とターミナルに表示させたい、でも何も起きていない。この time 構造体では、タイムアウト時間を指定することができます。タイムアウト時間を超えても select() がまだ準備のできたファイルディスクリプタを見つけられなければ、処理を続行できるように返されます。\nstruct timeval は以下のフィールドを持ちます。\nstruct timeval { int tv_sec; // seconds  int tv_usec; // microseconds }; tv_sec に待ち時間の秒数を、tv_usec に待ち時間のマイクロ秒数を設定するだけです。そう、これはミリ秒ではなくマイクロ秒なのです。ミリ秒の中には 1000 マイクロ秒があり、1 秒の中には 1000 ミリ秒があります。したがって、1 秒の中には 1,000,000 マイクロ秒があることになります。なぜ \u0026ldquo;usec\u0026quot;なのか？\u0026ldquo;u\u0026quot;は、私たちが\u0026quot;マイクロ\u0026quot;に使っているギリシャ文字の μ（ミュー）に似ていると思われるからです。また、関数が戻ってきたとき、timeout はまだ残っている時間を表示するように更新されるかもしれません。これは、あなたが使っている Unix のフレーバーに依存します。\nやったー！マイクロ秒の分解能のタイマーを手に入れたぞ！まあ、当てにしない方がいいです。どんなに小さな struct timeval を設定しても、おそらく標準的な Unix のタイムスライスの一部を待つ必要があります。\nその他、気になること。もし struct timeval のフィールドを 0 に設定すると、select() は直ちにタイムアウトし、セット内のすべてのファイルディスクリプタを効率よくポーリングします。パラメータ timeout を NULL に設定すると、決してタイムアウトせず、最初のファイルディスクリプタが準備できるまで待ちます。最後に、特定のセットを待つことを気にしないのであれば、select() のコールでそれを NULL に設定することができます。\n 次のコードでは、標準入力に何か表示されるまで 2.5 秒待ちます。\n/* ** select.c -- a select() demo */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/time.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #define STDIN 0 // file descriptor for standard input  int main(void) { struct timeval tv; fd_set readfds; tv.tv_sec = 2; tv.tv_usec = 500000; FD_ZERO(\u0026amp;readfds); FD_SET(STDIN, \u0026amp;readfds); // don\u0026#39;t care about writefds and exceptfds:  select(STDIN+1, \u0026amp;readfds, NULL, NULL, \u0026amp;tv); if (FD_ISSET(STDIN, \u0026amp;readfds)) printf(\u0026#34;A key was pressed!\\n\u0026#34;); else printf(\u0026#34;Timed out.\\n\u0026#34;); return 0; } ラインバッファ端末の場合、押すキーは RETURN でないと、とにかくタイムアウトしてしまいます。\nさて、この方法はデータグラムソケットでデータを待つのに最適な方法だと思う人もいるかもしれませんね。Unice の中にはこの方法で select を使えるものもあれば、使えないものもあります。試してみたいなら、ローカルの man ページに何が書いてあるか見てみるといいです。\nUnices の中には、タイムアウトまでの残り時間を反映して、struct timeval の時間を更新するものがあります。しかし、そうでないものもあります。ポータブルにしたいのであれば、そのようなことが起こることを当てにしないでください。（経過時間を追跡する必要がある場合は、gettimeofday() を使ってください。残念なことですが、それが現実なのです。）\nリードセット内のソケットがコネクションをクローズした場合はどうなるのでしょうか？その場合、select() はそのソケットディスクリプタを \u0026ldquo;ready to read\u0026rdquo; に設定して返す。実際にそこから recv() を実行すると、recv() は 0 を返します。これが、クライアントが接続を閉じたことを知るための方法です。\nもうひとつ select() について書いておくと、listen() しているソケットがある場合、そのソケットのファイルディスクリプタを readfds セットに入れておけば、新しい接続があるかどうかチェックすることができます。\n以上、全能の関数 select() の概要を簡単に説明しました。\nしかし、ご要望の多かった、より詳細な例をご紹介します。残念ながら、上記のごく簡単な例と、こちらの例では、大きな違いがあります。しかし、ご覧になってから、その後に続く説明をお読みください。\n このプログラムは、簡単なマルチユーザチャットサーバーのように動作します。一つのウィンドウで起動し、他の複数のウィンドウから telnet (\u0026quot;telnet hostname 9034\u0026quot;) で接続してください。ある telnet セッションで何かを入力すると、他のすべてのウィンドウに表示されるはずです。\n/* ** selectserver.c -- a cheezy multiperson chat server */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;netdb.h\u0026gt; #define PORT \u0026#34;9034\u0026#34; // port we\u0026#39;re listening on  // get sockaddr, IPv4 or IPv6: void *get_in_addr(struct sockaddr *sa) { if (sa-\u0026gt;sa_family == AF_INET) { return \u0026amp;(((struct sockaddr_in*)sa)-\u0026gt;sin_addr); } return \u0026amp;(((struct sockaddr_in6*)sa)-\u0026gt;sin6_addr); } int main(void) { fd_set master; // master file descriptor list  fd_set read_fds; // temp file descriptor list for select()  int fdmax; // maximum file descriptor number  int listener; // listening socket descriptor  int newfd; // newly accept()ed socket descriptor  struct sockaddr_storage remoteaddr; // client address  socklen_t addrlen; char buf[256]; // buffer for client data  int nbytes; char remoteIP[INET6_ADDRSTRLEN]; int yes=1; // for setsockopt() SO_REUSEADDR, below  int i, j, rv; struct addrinfo hints, *ai, *p; FD_ZERO(\u0026amp;master); // clear the master and temp sets  FD_ZERO(\u0026amp;read_fds); // get us a socket and bind it  memset(\u0026amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; if ((rv = getaddrinfo(NULL, PORT, \u0026amp;hints, \u0026amp;ai)) != 0) { fprintf(stderr, \u0026#34;selectserver: %s\\n\u0026#34;, gai_strerror(rv)); exit(1); } for(p = ai; p != NULL; p = p-\u0026gt;ai_next) { listener = socket(p-\u0026gt;ai_family, p-\u0026gt;ai_socktype, p-\u0026gt;ai_protocol); if (listener \u0026lt; 0) { continue; } // lose the pesky \u0026#34;address already in use\u0026#34; error message  setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, \u0026amp;yes, sizeof(int)); if (bind(listener, p-\u0026gt;ai_addr, p-\u0026gt;ai_addrlen) \u0026lt; 0) { close(listener); continue; } break; } // if we got here, it means we didn\u0026#39;t get bound  if (p == NULL) { fprintf(stderr, \u0026#34;selectserver: failed to bind\\n\u0026#34;); exit(2); } freeaddrinfo(ai); // all done with this  // listen  if (listen(listener, 10) == -1) { perror(\u0026#34;listen\u0026#34;); exit(3); } // add the listener to the master set  FD_SET(listener, \u0026amp;master); // keep track of the biggest file descriptor  fdmax = listener; // so far, it\u0026#39;s this one  // main loop  for(;;) { read_fds = master; // copy it  if (select(fdmax+1, \u0026amp;read_fds, NULL, NULL, NULL) == -1) { perror(\u0026#34;select\u0026#34;); exit(4); } // run through the existing connections looking for data to read  for(i = 0; i \u0026lt;= fdmax; i++) { if (FD_ISSET(i, \u0026amp;read_fds)) { // we got one!!  if (i == listener) { // handle new connections  addrlen = sizeof remoteaddr; newfd = accept(listener, (struct sockaddr *)\u0026amp;remoteaddr, \u0026amp;addrlen); if (newfd == -1) { perror(\u0026#34;accept\u0026#34;); } else { FD_SET(newfd, \u0026amp;master); // add to master set  if (newfd \u0026gt; fdmax) { // keep track of the max  fdmax = newfd; } printf(\u0026#34;selectserver: new connection from %s on \u0026#34; \u0026#34;socket %d\\n\u0026#34;, inet_ntop(remoteaddr.ss_family, get_in_addr((struct sockaddr*)\u0026amp;remoteaddr), remoteIP, INET6_ADDRSTRLEN), newfd); } } else { // handle data from a client  if ((nbytes = recv(i, buf, sizeof buf, 0)) \u0026lt;= 0) { // got error or connection closed by client  if (nbytes == 0) { // connection closed  printf(\u0026#34;selectserver: socket %d hung up\\n\u0026#34;, i); } else { perror(\u0026#34;recv\u0026#34;); } close(i); // bye!  FD_CLR(i, \u0026amp;master); // remove from master set  } else { // we got some data from a client  for(j = 0; j \u0026lt;= fdmax; j++) { // send to everyone!  if (FD_ISSET(j, \u0026amp;master)) { // except the listener and ourselves  if (j != listener \u0026amp;\u0026amp; j != i) { if (send(j, buf, nbytes, 0) == -1) { perror(\u0026#34;send\u0026#34;); } } } } } } // END handle data from client  } // END got new incoming connection  } // END looping through file descriptors  } // END for(;;)--and you thought it would never end!  return 0; } このコードでは、2つのファイル記述子セットを持っていることに注意してください。master と read_fds です。最初の master は、現在接続されているすべてのソケットディスクリプタと、新しい接続を待ち受けているソケットディスクリプタを保持します。\nmaster のセットを持っている理由は、select() が実際に渡すセットを変更して、どのソケットが読み込み可能な状態にあるかを反映させるためです。ある select() から次の select() への呼び出しまでの接続を追跡する必要があるので、これらをどこかに安全に保存しておかなければなりません。最後の最後で、master を read_fds にコピーしてから select() を呼び出します。\nしかし、これでは新しい接続を得るたびに、それを master セットに追加しなければならないのではありませんか？そうです。そして接続が終了するたびに、それを master セットから削除しなければならないのですか？はい、その通りです。\n注目すべきは、listener ソケットが読み込み可能な状態になったかどうかをチェックしていることです。このとき、新しい接続が保留されていることを意味するので、それを accept() して master セットに追加します。同様に、クライアントの接続が読み込み可能な状態になったときに、recv() が 0 を返したら、クライアントが接続を閉じたことがわかるので、master セットからそれを削除しなければなりません。\nしかし、クライアントの recv() がゼロ以外を返した場合、何らかのデータを受信したことが分かります。そこで私はそれを取得し、master リストを経由して、接続されている残りのすべてのクライアントにそのデータを送信します。\n以上が、全能の関数 select() の簡単でない概要です。\nLinux ファンの皆さんへ：まれに、Linux の select() が \u0026ldquo;ready-to-read\u0026rdquo; を返した後、実際には読み込む準備ができていないことがあります！これは、Linux の select() が \u0026ldquo;ready-to-read\u0026rdquo; を返した後、実際には読み込む準備ができていないことを意味します。これはつまり、select() が読まないと言っているのに、read() でブロックしてしまうということです！なぜだ、この野郎\u0026mdash;！とにかく、回避策は受信側のソケットで O_NONBLOCK フラグをセットして、 EWOULDBLOCK でエラーにすることです（これは発生しても無視しても大丈夫です）。ソケットをノンブロッキングに設定する方法については、 fcntl() リファレンスページを参照してください。\nさらに、ここでボーナス的な余談ですが、poll() という別の関数があります。これは select() とほぼ同じ動作をしますが、ファイルディスクリプタ集合を管理するシステムが異なります。 チェックしてみてください！\n"}]