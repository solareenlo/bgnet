[{"id":0,"href":"/bgnet/docs/intro/","title":"1 Intro","section":"Docs","content":"1 Intro #  おいおい、ソケットプログラミングで参ってるのか？このようなことは man ページから理解するには少し難しすぎるのではありませんか？クールなインターネットプログラミングをしたいけど、connect() の前に bind() を呼ばないといけないのか、などなど、struct のゴブをかき分けている時間はないでしょう。\nさて、どうでしょう！？私はもうこの厄介なビジネスをやり遂げました。そして、この情報をみんなと共有したくてたまらないのです! あなたは正しい場所に来たのです。この文書は、平均的な有能なCプログラマーが、このネットワーク・ノイズに対処するために必要なエッジを与えてくれるはずです。\nそして、チェックしてみてください。私はついに未来に追いつき、（ちょうどいいタイミングで！）IPv6用にガイドを更新しました。お楽しみに！\n1.1 Audience #  このドキュメントは、完全なリファレンスではなく、チュートリアルとして書かれています。 ソケットプログラミングを始めたばかりで、足がかりを探している人が読むと、おそらく最適なものになるでしょう。ソケットプログラミングの完全なガイドではありません。\nでも、うまくいけば、あのマニュアルページが意味を持ち始めるかもしれませんね\u0026hellip;。:-)\n1.2 Platform and Compiler #  この文書に含まれるコードは、Gnu の gcc コンパイラを使用して Linux PC でコンパイルされています。しかし、gccを使うプラットフォームであれば、ほぼ全てのプラットフォームでビルドできるはずです。当然ながら、Windows用のプログラミングには適用されません。以下の section on Windows programmingを参照してください。\n1.3 Official Homepage and Books For Sale #  このドキュメントの正式な所在地は\n  https://beej.us/guide/bgnet/  また、サンプルコードや様々な言語への翻訳も掲載されています。\n製本された印刷物（\u0026ldquo;本\u0026quot;と呼ぶ人もいる）を購入するには、以下をご覧ください。\n  https://beej.us/guide/url/bgbuy  文書作成生活の維持に役立つので、購入はありがたいです！\n1.4 Note for Solaris/SunOS Programmers #  Solaris または SunOS 用にコンパイルする場合、適切なライブラリをリンクするために、いくつかの特別なコマンドラインスイッチを指定する必要があります。これを行うには、コンパイルコマンドの最後に \u0026ldquo;-lnsl -lsocket -lresolv\u0026rdquo; を以下のように追加するだけです。\n$ cc -o server server.c -lnsl -lsocket -lresolv それでもエラーが出るようなら、さらにそのコマンドラインの最後に -lxnet を追加してみるといいでしょう。それが何をするのか正確にはわかりませんが、必要な人もいるようです。\nもう一つ問題がありそうなのは、setsockopt() の呼び出しのところです。プロトタイプは私の Linux ボックスのものとは異なるので、代わりに\nint yes=1; char yes='1'; を入力します。\n私は Sunbox を持っていないので、上記の情報を検証したわけではありません\u0026mdash;あくまでメールで教えてもらったことです。\n1.5 Note for Windows Programmers #  このガイドの時点では、歴史的に、私が Windows をあまり好きではないという事実のために、Windows を少し非難しています。しかし、Windows は膨大なインストールベースがあり、明らかに完璧なオペレーティングシステムであることを公平にお伝えする必要があります。\n不在は心を豊かにすると言いますが、この場合、私はそれが真実であると信じています。(ただ、言えることは、10数年前から個人的な仕事ではマイクロソフトのOSを使っていなかったので、ずっと幸せだということです だから、安心して、\u0026ldquo;どうぞ、ご自由に Windows を使ってください！\u0026ldquo;と言えるのです。 \u0026hellip;そう、歯ぎしりしながら言うんですけどね。\nですから私は、 Linux や BSD、あるいは Unix のいくつかのフレーバーを、代わりに試してみることをお勧めします。\nしかし、人は好きなものを好きになるものです。Windows の皆さんは、この情報が、もしあれば、いくつかの小さな変更を加えて、あなた方にも一般的に適用できることを知って喜んでいることでしょう。\nWindows 用の Unix ツールの集合体である Cygwin をインストールするのもいい方法です。そうすると、これらのプログラムはすべて修正なしでコンパイルできるようになると、人づてに聞いたことがあります。\nもうひとつ、 Windows Subsystem for Linux も検討してみてください。これは基本的に、Windows 10 に Linux の VM 的なものをインストールすることができます。これもまた、間違いなく位置づけられるでしょう。\nしかし、中には純粋な Windows のやり方で物事を進めたいと思う人もいるかもしれません。それはとてもガッツのあることで、こうすればいいんです。すぐに Unix を買ってきてください! いやいや\u0026mdash;冗談です。最近は Windows フレンドリー(笑)なはずなんですが\u0026hellip;。\nこれは、あなたがしなければならないことです（ Cygwinをインストールしない限り！）：まず、ここで私が言及するシステムヘッダーファイルのほとんどを無視してください。あなたがインクルードする必要があるのは、以下のものだけです。\n#include \u0026lt;winsock.h\u0026gt; 待ってください！ソケットライブラリで何かする前に WSAStartup() を呼び出す必要があります。これを行うためのコードは以下のようなものです。\n#include \u0026lt;winsock.h\u0026gt; { WSADATA wsaData; // if this doesn\u0026#39;t work  //WSAData wsaData; // then try this instead  // MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:  if (WSAStartup(MAKEWORD(1,1), \u0026amp;wsaData) != 0) { fprintf(stderr, \u0026#34;WSAStartup failed.\\n\u0026#34;); exit(1); } また、Winsock ライブラリをリンクするようにコンパイラに指示する必要があります。通常、wsock32.lib または winsock32.lib、Winsock 2.0 の場合は ws2_32.lib と呼ばれます。VC++ では、これは Project メニューの Settings... から行うことができます。Link タブをクリックし、\u0026ldquo;Object/library modules\u0026rdquo; というタイトルのボックスを探します。そのリストに \u0026ldquo;wsock32.lib\u0026rdquo;（または、お好みの lib）を追加してください。\nとか聞いています。\n最後に、ソケットライブラリを使い終わったら、WSACleanup() を呼び出す必要があります。詳しくはオンラインヘルプを参照してください。\n一度これを行えば、このチュートリアルの残りの例は、いくつかの例外を除いて、概ね適用できるはずです。ひとつは、ソケットを閉じるために close() を使うことができません。また、select() はソケットディスクリプタに対してのみ動作し、ファイルディスクリプタに対しては動作しません (stdin に対する 0 のように)。\nまた、CSocket というソケットクラスもあります。詳細はコンパイラのヘルプを参照してください。\nWinsock についての詳しい情報は、 Winsock FAQ を読んで、そこから進んでください。\n最後に、Windows には fork() システムコールがないそうですが、これは残念ながら私の例のいくつかで使われているものです。多分、POSIX ライブラリか何かをリンクしないと動かないでしょうし、代わりに CreateProcess() を使ってもいいでしょう。fork() は引数を取らず、CreateProcess() は約480億の引数を取ります。もし、そこまで気が回らないのであれば、CreateThread() の方が少し消化しやすいでしょう。残念ながら、マルチスレッドに関する議論はこのドキュメントの範囲外です。私が語れることは限られているのですからね!\n1.6 Email Policy #  メールでの質問には基本的に対応しますので、気軽に書き込んでください。ただし、返事を保証するものではありません。私はかなり忙しい生活を送っているので、どうしても質問に答えられないことがあります。そのような場合は、メッセージを削除します。個人的なことではなく、あなたが必要とする詳細な回答をする時間がないだけなのです。\n原則として、質問が複雑であればあるほど、回答できる可能性は低くなります。質問を送る前に質問を絞り込み、関連する情報（プラットフォーム、コンパイラ、表示されるエラーメッセージなど、トラブルシューティングに役立ちそうなもの）を必ず記載していただければ、回答が得られる可能性は高くなります。より詳しい情報は、ESRのドキュメント、 How To Ask Questions The Smart Way をお読みください。\n返事がない場合は、もう少し調べてみて、答えが見つからなければ、また調べてみてください。そして調べたことまたを書き込んでください。その結果、私がお手伝いできるようになることを期待しています。\nさて、手紙の書き方、書き方についておせっかいを焼いてしまいましたが、このガイドが何年にもわたって賞賛されてきたことに、私は十分に感謝していることをお伝えしておきたいと思います。このガイドが良いことに使われていると聞いて、私はとても嬉しくなりました。:-) ありがとうございます。\n1.7 Mirroring #  このサイトをミラーリングすることは、公的にも私的にも大歓迎です。もし、あなたがこのサイトを公的にミラーリングし、メインページからリンクしてほしい場合は、beej@beej.us までご連絡ください。\n1.8 Note for Translators #  もし、このガイドを他の言語に翻訳したい場合は、beej@beej.us までメールをいただければ、メインページからあなたの翻訳をリンクさせていただきます。翻訳にはあなたの名前と連絡先を自由に追加してください。\nこのソースマークダウン文書は UTF-8 エンコーディングを使用しています。\n後述の Copyright, Distribution, and Legal に記載されている使用許諾条件にご注意ください。\nもし私に翻訳をホストして欲しいのであれば、言ってください。また、あなたがホストすることを望むなら、私はそれにリンクします；どちらでも構いません。\n1.9 Copyright, Distribution, and Legal #  Beej\u0026rsquo;s Guide to Network Programming is Copyright © 2019 Brian \u0026ldquo;Beej Jorgensen\u0026rdquo; Hall.\nこの作品は、以下のソースコードと翻訳に関する特定の例外を除き、クリエイティブ・コモンズ 表示-非営利-改変禁止 3.0 ライセンスの下に提供されています。このライセンスのコピーを見るには、以下をご覧ください。\n https://creativecommons.org/licenses/by-nc-nd/3.0/\nまたは、Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USAに手紙を送ってください。\n本使用許諾の\u0026quot;二次的著作物の禁止\u0026quot;部分の具体的な例外は、次のとおりです：このガイドは、翻訳が正確である限り、どの言語にも自由に翻訳でき、ガイド全体を再印刷することができます。翻訳には、オリジナルのガイドと同じライセンスの制約が適用されます。翻訳には、翻訳者の名前と連絡先も含めることができます。\n本書で紹介する C 言語のソースコードは、パブリックドメインとして許諾され、いかなるライセンス制限もありません。\n教育関係者は、このガイドを生徒に勧めたり、コピーを提供したりすることを自由に推奨します。\n書面による相互の合意がない限り、著者は作品を現状のまま提供し、作品に関して、明示的、黙示的、法定またはその他のいかなる種類の表明または保証（権利、商品性、特定目的への適合性、非侵害、潜在的またはその他の欠陥の不在、精度、または発見可能かどうかにかかわらず誤りの有無の保証を含むが、これに限定されない）も行わないものとします。\n適用される法律で要求される範囲を除き、いかなる場合においても、著作者は、著作物の使用から生じる特別損害、付随的損害、結果的損害、懲罰的損害または典型的損害について、たとえ著作者がその損害の可能性を知らされていたとしても、いかなる法的理論によってもお客様に対して責任を負うことはないものとします。\nお問い合わせは beej@beej.us までお願いします。\n1.10 Dedication #  このガイドを書くにあたり、過去から未来にわたって協力してくださった皆様に感謝します。そして、私がこのガイドを作るために使っているフリーソフトやパッケージを制作しているすべての人に感謝します。GNU、Linux、Slackware、vim、Python、Inkscape、pandoc、その他多数。そして最後に、文字通り何千もの人々が、改善の提案や励ましの言葉を書いてくれたことに、大きな感謝を捧げます。\nこのガイドを、コンピュータの世界における私の最大のヒーローであり、インスピレーターである何人かに捧げます。Donald Knuth、Bruce Schneier、W. Richard Stevens、The Woz、そして私の読者、さらにフリーおよびオープンソースソフトウェアのコミュニティ全体に捧げます。\n1.11 Publishing Information #  この本は、GNU ツールを搭載した Arch Linux のマシン上で vim エディタを使って、Markdown で書かれています。表紙の\u0026quot;アート\u0026quot;とダイアグラムは Inkscape で作成されています。Markdown は Python、Pandoc および XeLaTeX により、Liberation フォントを用いて HTML および LaTex/PDF に変換されます。このツールチェーンは 100% フリーおよびオープンソースソフトウェアで構成されています。\n"},{"id":1,"href":"/bgnet/docs/what-is-a-socket/","title":"2 What is a socket?","section":"Docs","content":"2 What is a socket? #  \u0026ldquo;ソケット\u0026quot;という言葉をよく耳にしますが、そもそも\u0026quot;ソケット\u0026quot;とは何なのでしょうか？それは、標準的な Unix のファイルディスクリプタを使って他のプログラムと会話するための方法です。\nなんと？\nOk\u0026mdash; Unix のハッカーが \u0026ldquo;Unix では何でもファイルなんだ！\u0026ldquo;と言ったのを聞いたことがあるかもしれません。その人が言っているのは、Unix のプログラムが何らかの I/O を行うとき、ファイル記述子に対して読み書きを行うという事実のことかもしれません。ファイルディスクリプタは、単純に、開いているファイルに関連する整数です。しかし、このファイルは、ネットワーク接続、FIFO、パイプ、ターミナル、ディスク上のファイルなど、あらゆるものになり得ます（ここが重要）。Unix ではすべてがファイルなのです！だから、インターネット上で他のプログラムと通信したいときは、ファイル記述子を介して行うことになるんだ。と思ってください。\n\u0026ldquo;ネットワーク通信のためのファイルディスクリプタはどこで手に入るのですか、お利口さん？\u0026ldquo;というのが、今あなたが考えている最後の質問でしょうが、とにかくそれに答えてあげましょう。あなたは socket() システムルーチンを呼び出すのです。このルーチンはソケットディスクリプタを返すので、それを使って send() と recv() ( man send, man recv) という特別なソケットコールを使って通信を行います。\n\u0026ldquo;でもね！\u0026ldquo;あなたは今頃、そう叫んでいるかもしれません。\u0026ldquo;ファイルディスクリプタなら、どうしてネプチューンの名において、通常の read() と write() の呼び出しでソケットを通して通信できないんだ？\u0026ldquo;と。短い答えは、\u0026ldquo;できる！\u0026ldquo;です。もっと長い答えは、\u0026ldquo;できるけど、send() と recv() はデータ転送をより大きく制御できる \u0026ldquo;です。\n次は何？どうでしょう、ソケットにはいろいろな種類がありますね。DARPA インターネットアドレス (インターネットソケット)、ローカルノード上のパス名 (Unix ソケット)、CCITT X.25 アドレス (X.25 ソケット、無視しても大丈夫)、そしておそらくあなたが実行する Unix のフレーバーに応じて他の多くの種類があります。この文書では、最初の\u0026quot;インターネットソケット\u0026quot;のみを扱います。\n2.1 Two Types of Internet Sockets #  これは何？インターネットソケットには2種類ある？そうです。まあ、違うけど。嘘です。もっとあるんだけど、怖がらせたくなかったんだ。 ここでは2種類しか話しません。ただし、この文章では、\u0026ldquo;Raw Sockets\u0026rdquo; も非常に強力なので、ぜひ調べてみてくださいと言うつもりです。\nわかったよ、もう。この2つのタイプは何ですか？一つは\u0026quot;ストリームソケット\u0026rdquo;、もう一つは\u0026quot;データグラムソケット\u0026quot;で、以下、それぞれ \u0026ldquo;SOCK_STREAM\u0026rdquo; \u0026ldquo;SOCK_DGRAM\u0026rdquo; と呼ぶことがあります。データグラムソケットは\u0026quot;コネクションレス型ソケット\u0026quot;と呼ばれることもあります 。(ただし、本当に必要であれば connect()' を使用することができます。後述の connect() を参照してください)。\nストリームソケットは、信頼性の高い双方向接続の通信ストリームです。ソケットに2つのアイテムを \u0026ldquo;1, 2\u0026rdquo; という順序で出力すると、反対側にも \u0026ldquo;1, 2\u0026rdquo; という順序で届きます。また、エラーも発生しません。実際、私はエラーフリーであることを確信しています。もし、そうでないと主張する人がいたら、耳に指を突っ込んで\u0026quot;ララララ\u0026quot;と唱えてやりたいくらいだ。\n何がストリーム・ソケットを使うのでしょうか？さて、皆さんは telnet というアプリケーションをご存知でしょうか？あれはストリームソケットを使っているんだ。あなたが入力した文字は、すべて入力した順番に到着する必要がありますよね？また、Webブラウザは HTTP(Hypertext Transfer Protocol) を使っていますが、これはストリームソケットを使ってページを取得します。実際、80番ポートで Web サイトに telnet して、\u0026quot;GET / HTTP/1.0\u0026rdquo; と入力してリターンを2回押すと、HTML がダンプされて戻ってきますよ。\nもし telnet がインストールされておらず、インストールもしたくない場合、あるいは telnet がクライアントとの接続にうるさい場合、ガイドには telnot という telnet に似たプログラムが付属しています。これは、このガイドで必要なものすべてに対してうまく機能するはずです。(なお、telnet は実際には spec\u0026rsquo;d networking protocol であり、telnot はこのプロトコルを全く実装していません)。\nストリームソケットは、どのようにしてこの高いレベルのデータ伝送品質を実現しているのでしょうか。 それは、\u0026ldquo;TCP\u0026rdquo; として知られる\u0026quot;伝送制御プロトコル\u0026rdquo;(TCP の詳細については RFC 793 を参照)というプロトコルを使用しているからです。TCP はデータが順次、エラーなく到着することを確認します。\u0026ldquo;TCP\u0026rdquo; は \u0026ldquo;TCP/IP\u0026rdquo; の半分で、\u0026ldquo;IP\u0026rdquo; は \u0026ldquo;Internet Protocol\u0026rdquo;（ RFC 791 を参照）の略だと聞いたことがあるかもしれません。IP は主にインターネット・ルーティングを扱い、一般にデータの完全性には責任を持ちません。\nかっこいい。データグラムソケットについてはどうでしょうか？なぜコネクションレス型と呼ばれるのでしょうか？どうなっているんだ？なぜ信頼性が低いのでしょうか？データグラムを送ると、それが届くかもしれません。データグラムを送信すると、それは到着するかもしれません。もし到着すれば、パケット内のデータはエラーフリーです。\nデータグラムソケットもルーティングに IP を使いますが、TCP は使わず、\u0026ldquo;User Datagram Protocol\u0026rdquo;、つまり \u0026ldquo;UDP\u0026rdquo; を使います（ RFC 768 を参照）。\nなぜコネクションレスレスなのか？まあ、基本的には、ストリームソケットのようにオープンな接続を維持する必要がないからです。パケットを作り、その上に宛先情報を含む IP ヘッダを貼り付け、送信するだけでいいのです。コネクションは必要ありません。一般的には、TCP スタックが利用できないときや、パケットをいくつか落としても宇宙の終わりを意味しないときに使用されます。サンプルアプリケーション: tftp (FTP の弟分のようなファイル転送プロトコル)、dhcpcd (DHCP クライアント)、マルチプレイヤーゲーム、ストリーミングオーディオ、ビデオ会議、などなど。\n\u0026ldquo;ちょっと待った！tftp と dhcpcd はバイナリアプリケーションをあるホストから別のホストに転送するために使われるんだ！アプリケーションが到着したときに動作することを期待するならば、データが失われることはありえない！これはどんな黒魔術なんだ？\u0026rdquo;\nさて、私の人間の友人である tftp やそれに類するプログラムは、UDP の上に独自のプロトコルを載せています。たとえば、tftp プロトコルは、送信されたパケットごとに、受信者は\u0026quot;受け取ったよ！\u0026ldquo;というパケットを送り返さなければならない、と言っています。というパケット(\u0026ldquo;ACK\u0026rdquo; パケット)を送り返さなければなりません。元のパケットの送信者は、例えば5秒間返信がない場合、最終的に ACK を得るまでパケットを再送信することになります。この確認手続きは、信頼性の高い SOCK_DGRAM アプリケーションを実装する際に非常に重要です。\nゲーム、オーディオ、ビデオなどの信頼性の低いアプリケーションでは、ドロップしたパケットを無視するか、あるいは巧みに補うようにします。(Quake プレイヤーは、この効果の発現を呪われたラグという専門用語で知っていることでしょう。 この場合の\u0026quot;呪われた\u0026quot;という単語は、非常に不敬な発言を意味します)。\nなぜ信頼性の低い基礎プロトコルを使うのでしょうか？理由は2つ、速度とスピードです。何が無事に到着したかを追跡し、順序立てて確認したりするよりも、発射して忘れる方がずっと速いのです。チャットメッセージを送るなら、TCP は素晴らしいです。世界中のプレイヤーの位置情報を毎秒40件送るなら、1件や2件が落ちてもそれほど問題ではないので、UDP は良い選択だと思います。\n2.2 Low level Nonsense and Network Theory #  先ほどプロトコルの階層化について触れましたので、そろそろネットワークが実際にどのように動作するのか、そして SOCK_DGRAM パケットがどのように構築されるのかについて、いくつかの例を挙げて説明しましょう。 実際のところ、このセクションは読み飛ばしても大丈夫でしょう。しかし、良い背景にはなります。\n データのカプセル化  子供たちよ、データカプセル化について学ぶ時間だ！これはとても重要なことです。あまりに重要なので、このチコステでネットワークの授業を受けると、このことを学ぶことになるかもしれません ;-). 基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えば TFTP プロトコル）によってヘッダー（まれにフッターも）でラップ（\u0026ldquo;カプセル化\u0026rdquo;）され、次のプロトコル（例えば UDP）によって全体（TFTP ヘッダーも含む）が再びカプセル化され、さらに次のプロトコル（IP）によってカプセル化され、ハードウェア（物理）層（例えば Ethernet）の最終プロトコルによって再びカプセル化されます。\n他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルが IP と UDP ヘッダを、TFTP プログラムが TFTP ヘッダを取り除き、ようやくデータを手に入れることができます。\nこれでやっと悪名高いレイヤードネットワークモデル（通称 \u0026ldquo;ISO/OSI\u0026rdquo;）について語れるようになりました。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。\nさっそくですが、本格的なモデルのレイヤーを紹介します。 ネットワーククラスの試験のために覚えておいてください。\n アプリケーション層 プレゼンテーション層 セッション層 トランスポート層 ネットワーク層 データリンク層 物理層  物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと相互作用する場所です。\nさて、このモデルは、本当にやろうと思えば、自動車の修理ガイドとして使えるほど一般的なものです。Unix とより整合性のあるレイヤーモデルは、次のようなものでしょう。\n アプリケーション層 (telnet, ftp, etc.) Host-to-Host トランスポート層 (TCP, UDP) インターネット層 (IP and routing) ネットワークアクセス層 (Ethernet, wi-fi, or whatever)  この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。\nシンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ！そして、\u0026quot;cat\u0026rdquo; を使って自分でパケットヘッダを入力しなければならないのです！冗談です。ストリームソケットでやるべきことは、データを send() することだけです。データグラムソケットでは、あなたが選んだメソッドでパケットをカプセル化し、sendto() で送り出すだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築します。ああ、現代の技術ですね。\nというわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていました：何もありません！（笑）。その通り、全く話すつもりはありません。ルータはパケットを IP ヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、 IP RFC をチェックしてみてください。もしあなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。\n"}]