[{"id":0,"href":"/bgnet/docs/intro/","title":"1 Intro","section":"Docs","content":"1 Intro #  おいおい、ソケットプログラミングで参ってるのか？このようなことは man ページから理解するには少し難しすぎるのではありませんか？クールなインターネットプログラミングをしたいけど、connect() の前に bind() を呼ばないといけないのか、などなど、struct のゴブをかき分けている時間はないでしょう。\nさて、どうでしょう！？私はもうこの厄介なビジネスをやり遂げました。そして、この情報をみんなと共有したくてたまらないのです! あなたは正しい場所に来たのです。この文書は、平均的な有能なCプログラマーが、このネットワーク・ノイズに対処するために必要なエッジを与えてくれるはずです。\nそして、チェックしてみてください。私はついに未来に追いつき、（ちょうどいいタイミングで！）IPv6用にガイドを更新しました。お楽しみに！\n1.1 Audience #  このドキュメントは、完全なリファレンスではなく、チュートリアルとして書かれています。 ソケットプログラミングを始めたばかりで、足がかりを探している人が読むと、おそらく最適なものになるでしょう。ソケットプログラミングの完全なガイドではありません。\nでも、うまくいけば、あのマニュアルページが意味を持ち始めるかもしれませんね\u0026hellip;。:-)\n1.2 Platform and Compiler #  この文書に含まれるコードは、Gnu の gcc コンパイラを使用して Linux PC でコンパイルされています。しかし、gccを使うプラットフォームであれば、ほぼ全てのプラットフォームでビルドできるはずです。当然ながら、Windows用のプログラミングには適用されません。以下の section on Windows programmingを参照してください。\n1.3 Official Homepage and Books For Sale #  このドキュメントの正式な所在地は\n  https://beej.us/guide/bgnet/  また、サンプルコードや様々な言語への翻訳も掲載されています。\n製本された印刷物（\u0026ldquo;本\u0026quot;と呼ぶ人もいる）を購入するには、以下をご覧ください。\n  https://beej.us/guide/url/bgbuy  文書作成生活の維持に役立つので、購入はありがたいです！\n1.4 Note for Solaris/SunOS Programmers #  Solaris または SunOS 用にコンパイルする場合、適切なライブラリをリンクするために、いくつかの特別なコマンドラインスイッチを指定する必要があります。これを行うには、コンパイルコマンドの最後に \u0026ldquo;-lnsl -lsocket -lresolv\u0026rdquo; を以下のように追加するだけです。\n$ cc -o server server.c -lnsl -lsocket -lresolv それでもエラーが出るようなら、さらにそのコマンドラインの最後に -lxnet を追加してみるといいでしょう。それが何をするのか正確にはわかりませんが、必要な人もいるようです。\nもう一つ問題がありそうなのは、setsockopt() の呼び出しのところです。プロトタイプは私の Linux ボックスのものとは異なるので、代わりに\nint yes=1; char yes='1'; を入力します。\n私は Sunbox を持っていないので、上記の情報を検証したわけではありません\u0026mdash;あくまでメールで教えてもらったことです。\n1.5 Note for Windows Programmers #  このガイドの時点では、歴史的に、私が Windows をあまり好きではないという事実のために、Windows を少し非難しています。しかし、Windows は膨大なインストールベースがあり、明らかに完璧なオペレーティングシステムであることを公平にお伝えする必要があります。\n不在は心を豊かにすると言いますが、この場合、私はそれが真実であると信じています。(ただ、言えることは、10数年前から個人的な仕事ではマイクロソフトのOSを使っていなかったので、ずっと幸せだということです だから、安心して、\u0026ldquo;どうぞ、ご自由に Windows を使ってください！\u0026ldquo;と言えるのです。 \u0026hellip;そう、歯ぎしりしながら言うんですけどね。\nですから私は、 Linux や BSD、あるいは Unix のいくつかのフレーバーを、代わりに試してみることをお勧めします。\nしかし、人は好きなものを好きになるものです。Windows の皆さんは、この情報が、もしあれば、いくつかの小さな変更を加えて、あなた方にも一般的に適用できることを知って喜んでいることでしょう。\nWindows 用の Unix ツールの集合体である Cygwin をインストールするのもいい方法です。そうすると、これらのプログラムはすべて修正なしでコンパイルできるようになると、人づてに聞いたことがあります。\nもうひとつ、 Windows Subsystem for Linux も検討してみてください。これは基本的に、Windows 10 に Linux の VM 的なものをインストールすることができます。これもまた、間違いなく位置づけられるでしょう。\nしかし、中には純粋な Windows のやり方で物事を進めたいと思う人もいるかもしれません。それはとてもガッツのあることで、こうすればいいんです。すぐに Unix を買ってきてください! いやいや\u0026mdash;冗談です。最近は Windows フレンドリー(笑)なはずなんですが\u0026hellip;。\nこれは、あなたがしなければならないことです（ Cygwinをインストールしない限り！）：まず、ここで私が言及するシステムヘッダーファイルのほとんどを無視してください。あなたがインクルードする必要があるのは、以下のものだけです。\n#include \u0026lt;winsock.h\u0026gt; 待ってください！ソケットライブラリで何かする前に WSAStartup() を呼び出す必要があります。これを行うためのコードは以下のようなものです。\n#include \u0026lt;winsock.h\u0026gt; { WSADATA wsaData; // if this doesn\u0026#39;t work  //WSAData wsaData; // then try this instead  // MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:  if (WSAStartup(MAKEWORD(1,1), \u0026amp;wsaData) != 0) { fprintf(stderr, \u0026#34;WSAStartup failed.\\n\u0026#34;); exit(1); } また、Winsock ライブラリをリンクするようにコンパイラに指示する必要があります。通常、wsock32.lib または winsock32.lib、Winsock 2.0 の場合は ws2_32.lib と呼ばれます。VC++ では、これは Project メニューの Settings... から行うことができます。Link タブをクリックし、\u0026ldquo;Object/library modules\u0026rdquo; というタイトルのボックスを探します。そのリストに \u0026ldquo;wsock32.lib\u0026rdquo;（または、お好みの lib）を追加してください。\nとか聞いています。\n最後に、ソケットライブラリを使い終わったら、WSACleanup() を呼び出す必要があります。詳しくはオンラインヘルプを参照してください。\n一度これを行えば、このチュートリアルの残りの例は、いくつかの例外を除いて、概ね適用できるはずです。ひとつは、ソケットを閉じるために close() を使うことができません。また、select() はソケットディスクリプタに対してのみ動作し、ファイルディスクリプタに対しては動作しません (stdin に対する 0 のように)。\nまた、CSocket というソケットクラスもあります。詳細はコンパイラのヘルプを参照してください。\nWinsock についての詳しい情報は、 Winsock FAQ を読んで、そこから進んでください。\n最後に、Windows には fork() システムコールがないそうですが、これは残念ながら私の例のいくつかで使われているものです。多分、POSIX ライブラリか何かをリンクしないと動かないでしょうし、代わりに CreateProcess() を使ってもいいでしょう。fork() は引数を取らず、CreateProcess() は約480億の引数を取ります。もし、そこまで気が回らないのであれば、CreateThread() の方が少し消化しやすいでしょう。残念ながら、マルチスレッドに関する議論はこのドキュメントの範囲外です。私が語れることは限られているのですからね!\n1.6 Email Policy #  メールでの質問には基本的に対応しますので、気軽に書き込んでください。ただし、返事を保証するものではありません。私はかなり忙しい生活を送っているので、どうしても質問に答えられないことがあります。そのような場合は、メッセージを削除します。個人的なことではなく、あなたが必要とする詳細な回答をする時間がないだけなのです。\n原則として、質問が複雑であればあるほど、回答できる可能性は低くなります。質問を送る前に質問を絞り込み、関連する情報（プラットフォーム、コンパイラ、表示されるエラーメッセージなど、トラブルシューティングに役立ちそうなもの）を必ず記載していただければ、回答が得られる可能性は高くなります。より詳しい情報は、ESRのドキュメント、 How To Ask Questions The Smart Way をお読みください。\n返事がない場合は、もう少し調べてみて、答えが見つからなければ、また調べてみてください。そして調べたことまたを書き込んでください。その結果、私がお手伝いできるようになることを期待しています。\nさて、手紙の書き方、書き方についておせっかいを焼いてしまいましたが、このガイドが何年にもわたって賞賛されてきたことに、私は十分に感謝していることをお伝えしておきたいと思います。このガイドが良いことに使われていると聞いて、私はとても嬉しくなりました。:-) ありがとうございます。\n1.7 Mirroring #  このサイトをミラーリングすることは、公的にも私的にも大歓迎です。もし、あなたがこのサイトを公的にミラーリングし、メインページからリンクしてほしい場合は、beej@beej.us までご連絡ください。\n1.8 Note for Translators #  もし、このガイドを他の言語に翻訳したい場合は、beej@beej.us までメールをいただければ、メインページからあなたの翻訳をリンクさせていただきます。翻訳にはあなたの名前と連絡先を自由に追加してください。\nこのソースマークダウン文書は UTF-8 エンコーディングを使用しています。\n後述の Copyright, Distribution, and Legal に記載されている使用許諾条件にご注意ください。\nもし私に翻訳をホストして欲しいのであれば、言ってください。また、あなたがホストすることを望むなら、私はそれにリンクします；どちらでも構いません。\n1.9 Copyright, Distribution, and Legal #  Beej\u0026rsquo;s Guide to Network Programming is Copyright © 2019 Brian \u0026ldquo;Beej Jorgensen\u0026rdquo; Hall.\nこの作品は、以下のソースコードと翻訳に関する特定の例外を除き、クリエイティブ・コモンズ 表示-非営利-改変禁止 3.0 ライセンスの下に提供されています。このライセンスのコピーを見るには、以下をご覧ください。\n https://creativecommons.org/licenses/by-nc-nd/3.0/\nまたは、Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USAに手紙を送ってください。\n本使用許諾の\u0026quot;二次的著作物の禁止\u0026quot;部分の具体的な例外は、次のとおりです：このガイドは、翻訳が正確である限り、どの言語にも自由に翻訳でき、ガイド全体を再印刷することができます。翻訳には、オリジナルのガイドと同じライセンスの制約が適用されます。翻訳には、翻訳者の名前と連絡先も含めることができます。\n本書で紹介する C 言語のソースコードは、パブリックドメインとして許諾され、いかなるライセンス制限もありません。\n教育関係者は、このガイドを生徒に勧めたり、コピーを提供したりすることを自由に推奨します。\n書面による相互の合意がない限り、著者は作品を現状のまま提供し、作品に関して、明示的、黙示的、法定またはその他のいかなる種類の表明または保証（権利、商品性、特定目的への適合性、非侵害、潜在的またはその他の欠陥の不在、精度、または発見可能かどうかにかかわらず誤りの有無の保証を含むが、これに限定されない）も行わないものとします。\n適用される法律で要求される範囲を除き、いかなる場合においても、著作者は、著作物の使用から生じる特別損害、付随的損害、結果的損害、懲罰的損害または典型的損害について、たとえ著作者がその損害の可能性を知らされていたとしても、いかなる法的理論によってもお客様に対して責任を負うことはないものとします。\nお問い合わせは beej@beej.us までお願いします。\n1.10 Dedication #  このガイドを書くにあたり、過去から未来にわたって協力してくださった皆様に感謝します。そして、私がこのガイドを作るために使っているフリーソフトやパッケージを制作しているすべての人に感謝します。GNU、Linux、Slackware、vim、Python、Inkscape、pandoc、その他多数。そして最後に、文字通り何千もの人々が、改善の提案や励ましの言葉を書いてくれたことに、大きな感謝を捧げます。\nこのガイドを、コンピュータの世界における私の最大のヒーローであり、インスピレーターである何人かに捧げます。Donald Knuth、Bruce Schneier、W. Richard Stevens、The Woz、そして私の読者、さらにフリーおよびオープンソースソフトウェアのコミュニティ全体に捧げます。\n1.11 Publishing Information #  この本は、GNU ツールを搭載した Arch Linux のマシン上で vim エディタを使って、Markdown で書かれています。表紙の\u0026quot;アート\u0026quot;とダイアグラムは Inkscape で作成されています。Markdown は Python、Pandoc および XeLaTeX により、Liberation フォントを用いて HTML および LaTex/PDF に変換されます。このツールチェーンは 100% フリーおよびオープンソースソフトウェアで構成されています。\n"},{"id":1,"href":"/bgnet/docs/what-is-a-socket/","title":"2 What is a socket?","section":"Docs","content":"2 What is a socket? #  \u0026ldquo;ソケット\u0026quot;という言葉をよく耳にしますが、そもそも\u0026quot;ソケット\u0026quot;とは何なのでしょうか？それは、標準的な Unix のファイルディスクリプタを使って他のプログラムと会話するための方法です。\nなんと？\nOk\u0026mdash; Unix のハッカーが \u0026ldquo;Unix では何でもファイルなんだ！\u0026ldquo;と言ったのを聞いたことがあるかもしれません。その人が言っているのは、Unix のプログラムが何らかの I/O を行うとき、ファイル記述子に対して読み書きを行うという事実のことかもしれません。ファイルディスクリプタは、単純に、開いているファイルに関連する整数です。しかし、このファイルは、ネットワーク接続、FIFO、パイプ、ターミナル、ディスク上のファイルなど、あらゆるものになり得ます（ここが重要）。Unix ではすべてがファイルなのです！だから、インターネット上で他のプログラムと通信したいときは、ファイル記述子を介して行うことになるんだ。と思ってください。\n\u0026ldquo;ネットワーク通信のためのファイルディスクリプタはどこで手に入るのですか、お利口さん？\u0026ldquo;というのが、今あなたが考えている最後の質問でしょうが、とにかくそれに答えてあげましょう。あなたは socket() システムルーチンを呼び出すのです。このルーチンはソケットディスクリプタを返すので、それを使って send() と recv() ( man send, man recv) という特別なソケットコールを使って通信を行います。\n\u0026ldquo;でもね！\u0026ldquo;あなたは今頃、そう叫んでいるかもしれません。\u0026ldquo;ファイルディスクリプタなら、どうしてネプチューンの名において、通常の read() と write() の呼び出しでソケットを通して通信できないんだ？\u0026ldquo;と。短い答えは、\u0026ldquo;できる！\u0026ldquo;です。もっと長い答えは、\u0026ldquo;できるけど、send() と recv() はデータ転送をより大きく制御できる \u0026ldquo;です。\n次は何？どうでしょう、ソケットにはいろいろな種類がありますね。DARPA インターネットアドレス (インターネットソケット)、ローカルノード上のパス名 (Unix ソケット)、CCITT X.25 アドレス (X.25 ソケット、無視しても大丈夫)、そしておそらくあなたが実行する Unix のフレーバーに応じて他の多くの種類があります。この文書では、最初の\u0026quot;インターネットソケット\u0026quot;のみを扱います。\n2.1 Two Types of Internet Sockets #  これは何？インターネットソケットには2種類ある？そうです。まあ、違うけど。嘘です。もっとあるんだけど、怖がらせたくなかったんだ。 ここでは2種類しか話しません。ただし、この文章では、\u0026ldquo;Raw Sockets\u0026rdquo; も非常に強力なので、ぜひ調べてみてくださいと言うつもりです。\nわかったよ、もう。この2つのタイプは何ですか？一つは\u0026quot;ストリームソケット\u0026rdquo;、もう一つは\u0026quot;データグラムソケット\u0026quot;で、以下、それぞれ \u0026ldquo;SOCK_STREAM\u0026rdquo; \u0026ldquo;SOCK_DGRAM\u0026rdquo; と呼ぶことがあります。データグラムソケットは\u0026quot;コネクションレス型ソケット\u0026quot;と呼ばれることもあります 。(ただし、本当に必要であれば connect()' を使用することができます。後述の connect() を参照してください)。\nストリームソケットは、信頼性の高い双方向接続の通信ストリームです。ソケットに2つのアイテムを \u0026ldquo;1, 2\u0026rdquo; という順序で出力すると、反対側にも \u0026ldquo;1, 2\u0026rdquo; という順序で届きます。また、エラーも発生しません。実際、私はエラーフリーであることを確信しています。もし、そうでないと主張する人がいたら、耳に指を突っ込んで\u0026quot;ララララ\u0026quot;と唱えてやりたいくらいだ。\n何がストリーム・ソケットを使うのでしょうか？さて、皆さんは telnet というアプリケーションをご存知でしょうか？あれはストリームソケットを使っているんだ。あなたが入力した文字は、すべて入力した順番に到着する必要がありますよね？また、Webブラウザは HTTP(Hypertext Transfer Protocol) を使っていますが、これはストリームソケットを使ってページを取得します。実際、80番ポートで Web サイトに telnet して、\u0026quot;GET / HTTP/1.0\u0026rdquo; と入力してリターンを2回押すと、HTML がダンプされて戻ってきますよ。\nもし telnet がインストールされておらず、インストールもしたくない場合、あるいは telnet がクライアントとの接続にうるさい場合、ガイドには telnot という telnet に似たプログラムが付属しています。これは、このガイドで必要なものすべてに対してうまく機能するはずです。(なお、telnet は実際には spec\u0026rsquo;d networking protocol であり、telnot はこのプロトコルを全く実装していません)。\nストリームソケットは、どのようにしてこの高いレベルのデータ伝送品質を実現しているのでしょうか。 それは、\u0026ldquo;TCP\u0026rdquo; として知られる\u0026quot;伝送制御プロトコル\u0026rdquo;(TCP の詳細については RFC 793 を参照)というプロトコルを使用しているからです。TCP はデータが順次、エラーなく到着することを確認します。\u0026ldquo;TCP\u0026rdquo; は \u0026ldquo;TCP/IP\u0026rdquo; の半分で、\u0026ldquo;IP\u0026rdquo; は \u0026ldquo;Internet Protocol\u0026rdquo;（ RFC 791 を参照）の略だと聞いたことがあるかもしれません。IP は主にインターネット・ルーティングを扱い、一般にデータの完全性には責任を持ちません。\nかっこいい。データグラムソケットについてはどうでしょうか？なぜコネクションレス型と呼ばれるのでしょうか？どうなっているんだ？なぜ信頼性が低いのでしょうか？データグラムを送ると、それが届くかもしれません。データグラムを送信すると、それは到着するかもしれません。もし到着すれば、パケット内のデータはエラーフリーです。\nデータグラムソケットもルーティングに IP を使いますが、TCP は使わず、\u0026ldquo;User Datagram Protocol\u0026rdquo;、つまり \u0026ldquo;UDP\u0026rdquo; を使います（ RFC 768 を参照）。\nなぜコネクションレスレスなのか？まあ、基本的には、ストリームソケットのようにオープンな接続を維持する必要がないからです。パケットを作り、その上に宛先情報を含む IP ヘッダを貼り付け、送信するだけでいいのです。コネクションは必要ありません。一般的には、TCP スタックが利用できないときや、パケットをいくつか落としても宇宙の終わりを意味しないときに使用されます。サンプルアプリケーション: tftp (FTP の弟分のようなファイル転送プロトコル)、dhcpcd (DHCP クライアント)、マルチプレイヤーゲーム、ストリーミングオーディオ、ビデオ会議、などなど。\n\u0026ldquo;ちょっと待った！tftp と dhcpcd はバイナリアプリケーションをあるホストから別のホストに転送するために使われるんだ！アプリケーションが到着したときに動作することを期待するならば、データが失われることはありえない！これはどんな黒魔術なんだ？\u0026rdquo;\nさて、私の人間の友人である tftp やそれに類するプログラムは、UDP の上に独自のプロトコルを載せています。たとえば、tftp プロトコルは、送信されたパケットごとに、受信者は\u0026quot;受け取ったよ！\u0026ldquo;というパケットを送り返さなければならない、と言っています。というパケット(\u0026ldquo;ACK\u0026rdquo; パケット)を送り返さなければなりません。元のパケットの送信者は、例えば5秒間返信がない場合、最終的に ACK を得るまでパケットを再送信することになります。この確認手続きは、信頼性の高い SOCK_DGRAM アプリケーションを実装する際に非常に重要です。\nゲーム、オーディオ、ビデオなどの信頼性の低いアプリケーションでは、ドロップしたパケットを無視するか、あるいは巧みに補うようにします。(Quake プレイヤーは、この効果の発現を呪われたラグという専門用語で知っていることでしょう。 この場合の\u0026quot;呪われた\u0026quot;という単語は、非常に不敬な発言を意味します)。\nなぜ信頼性の低い基礎プロトコルを使うのでしょうか？理由は2つ、速度とスピードです。何が無事に到着したかを追跡し、順序立てて確認したりするよりも、発射して忘れる方がずっと速いのです。チャットメッセージを送るなら、TCP は素晴らしいです。世界中のプレイヤーの位置情報を毎秒40件送るなら、1件や2件が落ちてもそれほど問題ではないので、UDP は良い選択だと思います。\n2.2 Low level Nonsense and Network Theory #  先ほどプロトコルの階層化について触れましたので、そろそろネットワークが実際にどのように動作するのか、そして SOCK_DGRAM パケットがどのように構築されるのかについて、いくつかの例を挙げて説明しましょう。 実際のところ、このセクションは読み飛ばしても大丈夫でしょう。しかし、良い背景にはなります。\n データのカプセル化  子供たちよ、データカプセル化について学ぶ時間だ！これはとても重要なことです。あまりに重要なので、このチコステでネットワークの授業を受けると、このことを学ぶことになるかもしれません ;-). 基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えば TFTP プロトコル）によってヘッダー（まれにフッターも）でラップ（\u0026ldquo;カプセル化\u0026rdquo;）され、次のプロトコル（例えば UDP）によって全体（TFTP ヘッダーも含む）が再びカプセル化され、さらに次のプロトコル（IP）によってカプセル化され、ハードウェア（物理）層（例えば Ethernet）の最終プロトコルによって再びカプセル化されます。\n他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルが IP と UDP ヘッダを、TFTP プログラムが TFTP ヘッダを取り除き、ようやくデータを手に入れることができます。\nこれでやっと悪名高いレイヤードネットワークモデル（通称 \u0026ldquo;ISO/OSI\u0026rdquo;）について語れるようになりました。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。\nさっそくですが、本格的なモデルのレイヤーを紹介します。 ネットワーククラスの試験のために覚えておいてください。\n アプリケーション層 プレゼンテーション層 セッション層 トランスポート層 ネットワーク層 データリンク層 物理層  物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと相互作用する場所です。\nさて、このモデルは、本当にやろうと思えば、自動車の修理ガイドとして使えるほど一般的なものです。Unix とより整合性のあるレイヤーモデルは、次のようなものでしょう。\n アプリケーション層 (telnet, ftp, etc.) Host-to-Host トランスポート層 (TCP, UDP) インターネット層 (IP and routing) ネットワークアクセス層 (Ethernet, wi-fi, or whatever)  この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。\nシンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ！そして、\u0026quot;cat\u0026rdquo; を使って自分でパケットヘッダを入力しなければならないのです！冗談です。ストリームソケットでやるべきことは、データを send() することだけです。データグラムソケットでは、あなたが選んだメソッドでパケットをカプセル化し、sendto() で送り出すだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築します。ああ、現代の技術ですね。\nというわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていました：何もありません！（笑）。その通り、全く話すつもりはありません。ルータはパケットを IP ヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、 IP RFC をチェックしてみてください。もしあなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。\n"},{"id":2,"href":"/bgnet/docs/ip-addresses-structs-and-data-munging/","title":"3 IP Addresses, structs, and Data Munging","section":"Docs","content":"3 IP Addresses, structs, and Data Munging #  ここからは気分転換にコードの話をするところです。\nその前に、もっとノンコードの話をしましょう! イエーイ! まず最初に IP アドレスとポートについて少しお話したいと思いますので、それを整理します。それからソケット API がどのように IP アドレスや他のデータを保存し、操作するかについて話します。\n3.1 IP Addresses, versions 4 and 6 #  ベン・ケノービがまだオビワン・ケノービと呼ばれていた頃、インターネット・プロトコル・バージョン4（IPv4）と呼ばれる素晴らしいネットワーク・ルーティング・システムが存在しました。IPv4 は4バイト（4オクテット）で構成されるアドレスで、一般に「ドットと数字」で表記されるのが一般的でした。192.0.2.111 のように。\n皆さんも一度は目にしたことがあるのではないでしょうか。\n実際、この記事を書いている時点では、インターネット上のほぼすべてのサイトが IPv4 を使っています。\nオビ・ワンをはじめ、誰もが幸せでした。しかし、ヴィント・サーフという名の否定的な人物が、IPv4 アドレスが足りなくなると警告を発したのです！\n( ヴィント・サーフ氏は、IPv4 による「破滅と暗黒の黙示録」の到来を警告するとともに、「インターネットの父」としても有名です。だから、私は彼の判断に二の足を踏む立場にはないのだ)。\nアドレスが足りなくなる？そんなことがあるのでしょうか？つまり、32ビットの IPv4 アドレスには何十億もの IP アドレスが存在するのです。本当に何十億台ものコンピュータがあるのでしょうか？\nYes.\nまた、コンピュータが数台しかなく、10億という数字があり得ないほど大きいと誰もが思っていた当初、いくつかの大きな組織は、自分たちが使うために何百万というIPアドレスを惜しげもなく割り当てていたのです。(ゼロックス、MIT、フォード、HP、IBM、GE、AT\u0026amp;T、そしてアップルという小さな会社などです)。\n実際、いくつかの応急処置がなかったら、とっくに使い果たしていたでしょう。\nしかし今は、すべての人間がIPアドレスを持ち、すべてのコンピュータ、電卓、電話、パーキングメーター、そして（なぜか）子犬も、という時代です。\nそして、IPv6 が誕生したのです。ヴィント・サーフはおそらく不死身なので（たとえ肉体がこの世を去ったとしても、おそらく彼はすでにインターネット2の奥深くにある超知的な ELIZA プログラムとして存在しているはずです）、もし次のバージョンのインターネットプロトコルで十分なアドレスが確保できなければ、誰も彼の「だから言っただろう」という言葉を再び聞きたくはないでしょう。\nこれは何を示唆しているのでしょうか？\nもっとたくさんのアドレスが必要だということです。2倍どころか10億倍でもなく1000兆倍でもなく 7900万ビリオン・トリリオンの数のアドレスが必要なのです！そうこなくちゃ！\nビージェイ、それは本当なの？大きな数字を信じない理由があるんだ。\u0026ldquo;32ビットと128ビットの差は大したことないように聞こえるかもしれない、96ビット多いだけだろ？しかし、私たちはここで累乗の話をしていることを忘れてはなりません。32ビットは約40億の数字（2^32）を表し、128ビットは約340兆の数字（2^128）を表します。これは、宇宙の星1つに対して、100万個の IPv4 インターネットがあるようなものです。\nIPv4のドットや数字も忘れて、16進数では、2バイトの塊をコロンで区切って、このように表現しています。\n2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551 それだけではありません! 多くの場合、IPアドレスにはたくさんのゼロが含まれていますが、それらを2つのコロンで区切って圧縮することができます。そして、各バイトペアの先頭のゼロを省くことができます。例えば、次のようなアドレスのペアは、それぞれ等価です。\n2001:0db8:c9d2:0012:0000:0000:0000:0051 2001:db8:c9d2:12::51 2001:0db8:ab00:0000:0000:0000:0000:0000 2001:db8:ab00:: 0000:0000:0000:0000:0000:0000:0000:0001 ::1 アドレス ::1 はループバックアドレスです。常に「今走っているこのマシン」という意味です。IPv4 では、ループバックアドレスは 127.0.0.1 です。\n最後に、IPv6 アドレスの IPv4 互換モードですが、これは皆さんが遭遇する可能性のあるものです。例えば、192.0.2.33という IPv4 アドレスを IPv6 アドレスとして表現したい場合、次のような表記をします。\u0026quot;::ffff:192.0.2.33\u0026quot;。\n本気で楽しみたいんです。\n実際、IPv6 の開発者たちは、何兆個ものアドレスを軽率にも予約用に切り捨てたほど、IPv6 は楽しいものなのですが、数が多すぎて、正直言って、もう誰が数えているのでしょうか？銀河系のすべての惑星のすべての男性、女性、子供、子犬、そしてパーキングメーターのために十分な数が残されています。 信じてくれ、銀河系のどの星にもパーキングメーターはあるんだ。本当なんだ。\n3.1.1 Subnets #  組織上、「このIPアドレスの先頭からこのビットまでがネットワーク部分、それ以外がホスト部分」と宣言するのが便利な場合があります。\n例えば、IPv4 では 192.0.2.12 というように、最初の3バイトがネットワークで、最後の1バイトがホストと言えるでしょう。あるいは、別の言い方をすれば、ネットワーク 192.0.2.0 上のホスト 12 について話していることになります (ホストであるバイトをゼロにしているところをご覧ください)。\nそして、さらに時代遅れの情報を! 準備はいいですか？古代では、サブネットには「クラス」があり、アドレスの最初の1バイト、2バイト、3バイトがネットワーク部分でした。運良く1バイトがネットワーク、3バイトがホストの場合、ネットワーク上に24ビット分のホスト（1600万程度）を持つことができます。これが「クラスA」のネットワークである。一方、「クラスC」は、ネットワークが3バイト、ホストが1バイトで、256台のホスト（ただし、予約された数台は除く）を持ちます。\nご覧のように、Aクラスがほんの少し、Cクラスが大量に、そして真ん中にBクラスが何個かある状態でした。\nIPアドレスのネットワーク部分は、ネットマスクと呼ばれるもので記述されており、IPアドレスとビット単位でANDすることでネットワーク番号を取得します。ネットマスクは通常 255.255.255.0 のような形をしています。(例えば、このネットマスクでは、あなたのIPが 192.0.2.12 なら、あなたのネットワークは 192.0.2.12 AND 255.255.255.0 で、 192.0.2.0 となります)。\nしかし、残念ながら、これはインターネットの最終的なニーズに対して十分なきめ細かさではないことが判明しました。クラスCのネットワークはすぐに足りなくなったし、クラスAのネットワークも足りなくなったので、わざわざ尋ねる必要はありません。この問題を解決するために、権力者たちはネットマスクを 8、16、24 のどれでもなく、任意のビット数にすることを許可しました。例えば 255.255.255.252 というネットマスクは、30 ビットのネットワークと 2 ビットのホストで、 ネットワーク上に 4 つのホストを置くことができます。 (ネットマスクは常に1ビットの束と0ビットの束からなることに注意してください)。\nしかし、255.192.0.0 のような大きな数字の羅列をネットマスクとして使うのは、少し扱いにくいです。まず、それが何ビットなのかが直感的にわからないし、コンパクトでもありません。そこで新スタイルが登場したのですが、これはもっとすっきりしています。IP アドレスの後にスラッシュを付けて、その後に10進数でネットワークのビット数を指定するだけです。こんな感じです。192.0.2.12/30。\nあるいは、IPv6 の場合、このようなものです。2001:db8::/32 または 2001:db8:5413:4028::9db9/64 です。\n3.1.2 Port Numbers #  以前、インターネット層（IP）とホスト間トランスポート層（TCPとUDP）を分離した レイヤードネットワークモデルをご紹介しましたが、覚えていらっしゃいますか？次の段落の前に、そのことをしっかり覚えておいてください。\nIP アドレス（IP 層で使われる）の他に、TCP（ストリームソケット）や、偶然にも UDP（データグラムソケット）で使われるアドレスがあることが判明したのです。それは、ポート番号です。これは16ビットの数字で、接続のためのローカルアドレスのようなものです。\nIP アドレスはホテルの番地、ポート番号は部屋番号だと思ってください。後で自動車業界の例も考えてみましょう。\n例えば、受信メールとウェブサービスの両方を扱うコンピュータを用意したい場合、1つのIPアドレスを持つコンピュータでその2つを区別する方法はあるでしょうか？\nさて、インターネット上のサービスには、それぞれ異なるウェルノウン・ポート番号が設定されています。 IANA のポート一覧か、Unix であれば /etc/services ファイルで確認することができます。HTTP（ウェブ）はポート80、telnet はポート23、SMTP はポート25、ゲーム DOOM はポート666、などなど。1024以下のポートはしばしば特殊とみなされ、通常、使用するには OS の特別な権限が必要です。\nといったところでしょうか。\n3.2 Byte Order #  レルムの命令で！バイトの並び順は2種類とします。今後、Lame and Magnificent と呼ばれるようになります。\nというのは冗談ですが、本当にどちらか一方が優れているのです。:-)\nあなたのコンピュータは、あなたの背後でバイトを逆順に保存しているかもしれないのです。そうなんです。誰もあなたに言いたくはなかったのです。\nつまり、2バイトの16進数、たとえば b34f を表現する場合、b3 と 4f の2バイトに続けて格納する、というのがインターネットの世界の共通認識になっているのです。これは理にかなっているし、 ウィルフォード・ブリムリーも言うように、正しい行為です。このように、大きい方の端が先になるように格納された数字をビッグエンディアン（Big-Endian）と呼びます。\n残念ながら、世界中に散在する一部のコンピュータ、すなわちインテルまたはインテル互換のプロセッサを搭載したものは、バイトを逆に格納しているため、b34fは 4f と b3 の連続したバイトとしてメモリに格納されることになります。この記憶方式をリトルエンディアンと呼びます。\nでも、ちょっと待ってください！用語の説明はまだ終わっていないのです。もっとまともなビッグエンディアンはネットワークバイトオーダーとも呼ばれ、私たちネットワーク系が好む順序だからです。\nコンピュータはホストバイトオーダーで数字を記憶しています。インテル 80x86 であれば、ホストバイト順はリトルエンディアンです。モトローラ 68K の場合は、ビッグエンディアンです。PowerPC なら、ホストバイトの並びは\u0026hellip;\u0026hellip;まあ、人それぞれですね。\nパケットを作成するときやデータ構造を埋めるときに、2バイトや4バイトの数値がネットワークバイトオーダーになっていることを確認する必要があることがよくあります。しかし、ネイティブなホストバイトオーダーがわからない場合、どのようにすればよいのでしょうか。\n朗報です。ホストのバイトオーダーが正しくないと仮定して、値をネットワークバ イトオーダーに設定するための関数を常に実行するようにすればよいのです。この関数は、必要であれば魔法のような変換を行い、エンディアンが異なるマシンにもコードを移植することができます。\nよしよし。変換できる数値は、short（2バイト）と long（4バイト）の2種類です。これらの関数は、符号なしのバリエーションでも動作します。例えば、short をホストバイトオーダーからネットワークバイトオーダーに変換したいとします。まず \u0026ldquo;h\u0026rdquo; でホスト、その後に \u0026ldquo;to\u0026rdquo; をつけます。そして、\u0026ldquo;n\u0026rdquo; は \u0026ldquo;network\u0026rdquo;、\u0026ldquo;s\u0026rdquo; は \u0026ldquo;short\u0026rdquo; を表します。h-to-n-s または htons() (読み方: \u0026ldquo;ホストからネットワークへのショート\u0026rdquo;) です。\n簡単すぎるくらいに\u0026hellip;。\n\u0026ldquo;n\u0026rdquo;、\u0026ldquo;h\u0026rdquo;、\u0026ldquo;s\u0026rdquo;、\u0026ldquo;l\u0026rdquo; の組み合わせは、本当にくだらないものを除いて、すべて使うことができるのです。たとえば、stolh() (\u0026ldquo;Short to Long Host\u0026rdquo;) という関数はありません\u0026mdash;とにかく、このパーティーでは。しかし、あるのです。\n   関数 説明     htons() host to network short   htonl() host to network long   ntohs() network to host short   ntohl() network to host long    基本的には、送出する前にネットワークバイトオーダーに変換し、送出後にホストバイトオーダーに変換します。\n64bitのバリエーションは知らないです、すみません。また、浮動小数点をやりたい場合は、ずっと下の Serialization の章をチェックしてください。\nこの文書では、特に断らない限り、数値はホストバイトオーダーであると仮定しています。\n3.3 structs #  さて、ついにここまで来ました。そろそろプログラミングの話をしましょう。この章では、ソケットインターフェイスで使用される様々なデータ型について説明します。\nまず、簡単なものからです。ソケットディスクリプタです。ソケットディスクリプタは以下のような型です。\nint 普通の int です。\nここからは変な話なので、我慢して読んでください。\nMy First Struct™\u0026mdash;struct addrinfo。この構造体は最近開発されたもので、ソケットアドレス構造体を後で使用するために準備するために使用されます。また、ホスト名のルックアップやサービス名のルックアップにも使用されます。これは、後で実際の使い方を説明するときに、より意味をなすと思いますが、今は、接続を行うときに最初に呼び出されるものの1つであることを知っておいてください。\nstruct addrinfo { int ai_flags; // AI_PASSIVE, AI_CANONNAME, etc. int ai_family; // AF_INET, AF_INET6, AF_UNSPEC int ai_socktype; // SOCK_STREAM, SOCK_DGRAM int ai_protocol; // use 0 for \u0026quot;any\u0026quot; size_t ai_addrlen; // size of ai_addr in bytes struct sockaddr *ai_addr; // struct sockaddr_in or _in6 char *ai_canonname; // full canonical hostname struct addrinfo *ai_next; // linked list, next node }; この構造体を少し読み込んでから、getaddrinfo() を呼び出します。この構造体のリンクリストへのポインタが返され、必要なものがすべて満たされます。\nai_family フィールドで IPv4 か IPv6 を使うように強制することもできますし、AF_UNSPEC のままにして何でも使えるようにすることも可能です。これは、あなたのコードが IP バージョンに依存しないので、クールです。\nこれはリンクされたリストであることに注意してください：ai_next は次の要素を指しています\u0026mdash;そこから選択するためにいくつかの結果があるかもしれません。私は最初にうまくいった結果を使いますが、あなたは異なるビジネスニーズを持っているかもしれません。何でもかんでも知ってるわけじゃないんです！\nstruct addrinfo の ai_addr フィールドは struct sockaddr へのポインタであることがわかります。ここからが、IP アドレス構造体の中身についての細かい話になります。\n通常、これらの構造体に書き込む必要はありません。多くの場合、addrinfo 構造体を埋めるために getaddrinfo() を呼び出すだけでよいでしょう。しかし、これらの構造体の内部を覗いて値を取得する必要があるため、ここでそれらを紹介します。\n(また、構造体 addrinfo が発明される前に書かれたコードはすべて、これらのものをすべて手作業で梱包していたので、まさにそのような IPv4 コードを多く見かけることができます。このガイドの古いバージョンなどでもそうです)。\nある構造体は IPv4 で、ある構造体は IPv6 で、ある構造体はその両方です。どれが何なのか、メモしておきます。\nとにかく、構造体 sockaddr は、多くの種類のソケットのためのソケットアドレス情報を保持します。\nstruct sockaddr { unsigned short sa_family; // address family, AF_xxx char sa_data[14]; // 14 bytes of protocol address }; sa_family には様々なものを指定できますが、この文書ではすべて AF_INET (IPv4) または AF_INET6 (IPv6) とします。sa_data にはソケットの宛先アドレスとポート番号を指定します。sa_data にアドレスを手で詰め込むのは面倒なので、これはかなり扱いにくいです。\n構造体 sockaddr を扱うために、プログラマは IPv4 で使用する構造体 sockaddr_in（\u0026ldquo;in\u0026rdquo; は \u0026ldquo;Internet\u0026rdquo; の意）を並列に作成しました。\nsockaddr_in 構造体へのポインタは sockaddr 構造体へのポインタにキャストすることができ、その逆も可能です。つまり、connect() が struct sockaddr* を要求しても、struct sockaddr_in を使用して、最後の最後でキャストすることができるのです！\n// (IPv4 only--see struct sockaddr_in6 for IPv6) struct sockaddr_in { short int sin_family; // Address family, AF_INET unsigned short int sin_port; // Port number struct in_addr sin_addr; // Internet address unsigned char sin_zero[8]; // Same size as struct sockaddr }; この構造体により、ソケットアドレスの要素を簡単に参照することができます。sin_zero (構造体を struct sockaddr の長さに合わせるために含まれます) は、関数 memset() ですべて 0 に設定する必要があることに注意すること。また、sin_family は struct sockaddr の sa_family に相当し、\u0026quot;AF_INET\u0026rdquo; に設定されることに注意します。最後に、sin_port はネットワークバイトオーダーでなければなりません（htons() を使用することで！）。\nもっと掘り下げましょう！sin_addr フィールドは in_addr 構造体であることがわかりますね。あれは何なんだ？まあ、大げさではなく、史上最も恐ろしい組合せの1つです。\n// (IPv4 only--see struct in6_addr for IPv6) // Internet address (a structure for historical reasons) struct in_addr { uint32_t s_addr; // that's a 32-bit int (4 bytes) }; うおぉ まあ、昔はユニオンだったんだけど、今はもうそういう時代じゃないみたいだね。おつかれさまでした。つまり、ina を struct sockaddr_in 型と宣言した場合、ina.sin_addr.s_addr は4バイトの IP アドレス（ネットワークバイトオーダー）を参照することになります。あなたのシステムがまだ struct in_addr のための神々しいユニオンを使用している場合でも、あなたはまだ私が上記のように全く同じ方法で4バイトの IP アドレスを参照することができます（これは #defines によるものです）ことに注意してください。\nIPv6 ではどうでしょうか。これについても同様の構造体が存在します。\n// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4) struct sockaddr_in6 { u_int16_t sin6_family; // address family, AF_INET6 u_int16_t sin6_port; // port number, Network Byte Order u_int32_t sin6_flowinfo; // IPv6 flow information struct in6_addr sin6_addr; // IPv6 address u_int32_t sin6_scope_id; // Scope ID }; struct in6_addr { unsigned char s6_addr[16]; // IPv6 address }; IPv4 が IPv4 アドレスとポート番号を持つように、IPv6 も IPv6 アドレスとポート番号を持つことに注意してください。\nまた、IPv6 フロー情報やスコープ ID のフィールドについては、今のところ触れないことに注意してください。:-)\n最後になりますが、こちらもシンプルな構造体である struct sockaddr_storage は、IPv4 と IPv6 の両方の構造体を保持できるように十分な大きさに設計されています。コールによっては、struct sockaddr に IPv4 と IPv6 のどちらのアドレスが記入されるのか事前にわからないことがありますよね。そこで、この並列構造体を渡しますが、サイズが大きい以外は struct sockaddr とよく似ており、必要な型にキャストします。\nstruct sockaddr_storage { sa_family_t ss_family; // address family // all this is padding, implementation specific, ignore it: char __ss_pad1[_SS_PAD1SIZE]; int64_t __ss_align; char __ss_pad2[_SS_PAD2SIZE]; }; 重要なのは、ss_family フィールドでアドレスファミリーを確認できることで、これが AF_INET か AF_INET6（IPv4 か IPv6 か）かを確認することです。それから、必要なら struct sockaddr_in や struct sockaddr_in6 にキャストすることができます。\n3.4 IP Addresses, Part Deux #  幸いなことに、IP アドレスを操作するための関数がたくさんあります。手書きで把握して \u0026lt;\u0026lt; 演算子で long に詰め込む必要はありません。\nまず、struct sockaddr_in ina があり、そこに格納したい IP アドレスが 10.12.110.57 または 2001:db8:63b3:1::3490 だとしましょう。inet_pton() という関数は、数字とドットで表記された IP アドレスを、AF_INET か AF_INET6 の指定によって、in_addr 構造体か in6_addr 構造体に変換する関数です。(\u0026quot;pton\u0026quot; は \u0026ldquo;presentation to network\u0026rdquo; の略で、覚えやすければ \u0026ldquo;printable to network\u0026rdquo; と呼んでも構いません)。変換は次のように行うことができます。\nstruct sockaddr_in sa; // IPv4 struct sockaddr_in6 sa6; // IPv6 inet_pton(AF_INET, \u0026quot;10.12.110.57\u0026quot;, \u0026amp;(sa.sin_addr)); // IPv4 inet_pton(AF_INET6, \u0026quot;2001:db8:63b3:1::3490\u0026quot;, \u0026amp;(sa6.sin6_addr)); // IPv6 (クイックメモ: 古い方法では、inet_addr() という関数や inet_aton() という別の関数を使っていましたが、これらはもう時代遅れで IPv6 では動きません。)\nさて、上記のコードスニペットは、エラーチェックがないため、あまり堅牢ではありません。inet_pton() はエラー時に -1 を返し、アドレスがめちゃくちゃになった場合は 0 を返します。ですから、使用する前に結果が 0 よりも大きいことを確認してください！\nさて、これで文字列の IP アドレスをバイナリ表現に変換することができるようになりました。では、その逆はどうでしょうか？in_addr 構造体を持っていて、それを数字とドットの表記で印刷したい場合はどうでしょうか。(この場合、関数 inet_ntop() (\u0026quot;ntop\u0026quot; は \u0026ldquo;network to presentation\u0026rdquo; という意味です。覚えやすければ \u0026ldquo;network to printable\u0026rdquo; と呼んでも構いません) を次のように使用します。\n// IPv4:  char ip4[INET_ADDRSTRLEN]; // space to hold the IPv4 string struct sockaddr_in sa; // pretend this is loaded with something  inet_ntop(AF_INET, \u0026amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN); printf(\u0026#34;The IPv4 address is: %s\\n\u0026#34;, ip4); // IPv6:  char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string struct sockaddr_in6 sa6; // pretend this is loaded with something  inet_ntop(AF_INET6, \u0026amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN); printf(\u0026#34;The address is: %s\\n\u0026#34;, ip6); 呼び出す際には、アドレスの種類（IPv4 または IPv6）、アドレス、結果を格納する文字列へのポインタ、その文字列の最大長を渡すことになります。(2つのマクロは、最大の IPv4 または IPv6 アドレスを保持するために必要な文字列のサイズを都合よく保持します。INET_ADDRSTRLEN と INET6_ADDRSTRLEN です)。\n(古いやり方についてもう一度簡単に触れておくと、この変換を行う歴史的な関数は inet_ntoa() と呼ばれるものでした。これも時代遅れで、IPv6 では動きません。)\n最後に、これらの関数は数値の IP アドレスに対してのみ動作します。\u0026quot;www.example.com\u0026quot; のようなホスト名に対してネームサーバの DNS ルックアップは行いません。後ほど説明するように、そのためには getaddrinfo() を使用します。\n3.4.1 Private (Or Disconnected) Networks #  多くの場所では、自分たちを守るために、ネットワークを他の地域から隠すファイアウォールがあります。そして多くの場合、ファイアウォールは、ネットワークアドレス変換（NAT）と呼ばれるプロセスを使って、\u0026ldquo;内部\u0026rdquo; IP アドレスを\u0026quot;外部\u0026quot;（世界中の誰もが知っている）IP アドレスに変換しています。\nもう緊張してきましたか？\u0026ldquo;こんな変なことして どこへ行くんだろう？\u0026rdquo;\nまあ、ノンアルコール飲料でも買ってリラックスしてください。初心者の場合、NAT は透過的に行われるので、心配する必要もありませんから。しかし、あなたが見ているネットワーク番号に混乱し始めた場合に備えて、ファイアウォールの背後にあるネットワークについて話したいと思います。\n例えば、私の自宅にはファイアウォールがあります。DSL 会社から割り当てられた2つの固定 IPv4 アドレスを持っていますが、ネットワーク上に7台のコンピューターがあります。どうしてこんなことが可能なのでしょうか？2台のコンピュータが同じ IP アドレスを共有することはできませんし、そうでなければデータはどちらに行けばいいのかわからなくなってしまいます。\n答えは、\u0026ldquo;同じIPアドレスを共有していない\u0026quot;です。2400万個の IP アドレスが割り当てられたプライベートネットワーク上にあるのです。それらはすべて私のためだけのものです。まあ、他の人たちから見れば、すべて私のためのものなのですが。ここで、何が起こっているのかを説明します。\nリモートコンピューターにログインすると、ISP から提供されたパブリック IP アドレスである 192.0.2.33 からログインしていると表示されるのです。しかし、ローカルコンピューターにその IP アドレスを尋ねると、10.0.0.5 と答えるのです。誰が IP アドレスを変換しているのでしょうか？そうです、ファイアウォールです。ファイアウォールが NAT しているのです。\n10.x.x.x は、完全に切断されたネットワークか、ファイアウォールの内側にあるネットワークでのみ使用される、数少ない予約ネットワークの1つです。どのプライベート・ネットワーク番号が使用できるかの詳細は、 RFC 1918 に概説されていますが、一般的によく目にするのは、10.x.x.x と 192.168.x.x で、x は通常 0 ～ 255 です。一般的ではないのは、172.y.x.x で、y は16から31の間です。\nNAT するファイアウォールの内側のネットワークは、これらの予約されたネットワークのいずれかにある必要はありませんが、一般的にはそうなっています。\n(楽しい事実！私の外部 IP アドレスは、本当は 192.0.2.33 ではないのです。192.0.2.x ネットワークは、このガイドのように、ドキュメントで使用するための架空の\u0026quot;本当の\u0026rdquo; IP アドレスのために予約されているのです！わーい、すごい！)\nIPv6 にも、ある意味プライベートネットワークがあります。 RFC 4193 にあるように、fdXX:（将来的には fcXX:）で始まります。しかし、NAT と IPv6 は一般的に混ざりません(このドキュメントの範囲外である IPv6 から IPv4 へのゲートウェイを行う場合を除きます)。理論的には、自由に使えるアドレスが非常に多くなるため、NAT を使用する必要はなくなるはずです。しかし、外部にルーティングしないネットワーク上で自分のためにアドレスを割り当てたい場合は、このようにします。\n"},{"id":3,"href":"/bgnet/docs/jumping-from-ipv4-to-ipv6/","title":"4 Jumping from IPv4 to IPv6","section":"Docs","content":"4 Jumping from IPv4 to IPv6 #  しかし、IPv6 で動作させるためには、私のコードのどこを変えればいいのか知りたいのです！今すぐ教えてください！\nOk! Ok!\nここに書かれていることはほとんどすべて、私が上で説明したことですが、せっかちな人のためのショートバージョンです。(もちろん、これ以外にもありますが、このガイドに該当するのはこれです)。\n  まず、構造体を手で詰めるのではなく、 getaddrinfo() を使ってすべての sockaddr 構造体の情報を取得するようにしてください。こうすることで、IP のバージョンに左右されず、また、その後の多くのステップを省くことができます。\n  IP バージョンに関連する何かをハードコーディングしていることが分かったら、ヘルパー関数でラップするようにします。\n  AF_INET を AF_INET6 に変更します。\n  PF_INET を PF_INET6 に変更します。\n  INADDR_ANY の割り当てを in6addr_any の割り当てに変更し、若干の差異が生じます。\nstruct sockaddr_in sa; struct sockaddr_in6 sa6; sa.sin_addr.s_addr = INADDR_ANY; // use my IPv4 address sa6.sin6_addr = in6addr_any; // use my IPv6 address Also, the value IN6ADDR_ANY_INIT can be used as an initializer when the struct in6_addr is declared, like so:\nstruct in6_addr ia6 = IN6ADDR_ANY_INIT;   struct sockaddr_in の代わりに struct sockaddr_in6 を使用し、必要に応じてフィールドに \u0026ldquo;6\u0026rdquo; を追加してください（上記の structs を参照）。sin6_zero フィールドはありません。\n  struct in_addr の代わりに struct in6_addr を使用し、必要に応じてフィールドに \u0026ldquo;6\u0026rdquo; を追加してください（上記の structs を参照）。\n  inet_aton() や inet_addr() の代わりに、inet_apton() を使用してください。\n  inet_ntoa() の代わりに inet_ntop() を使用してください。\n  gethostbyname() の代わりに、優れた getaddrinfo() を使用してください。\n  gethostbyaddr() の代わりに、優れた getnameinfo() を使用してください（gethostbyaddr()は IPv6 でも動作可能です）。\n  INADDR_BROADCAST は動作しなくなりました。代わりに IPv6 マルチキャストを使用してください。\n  出来上がり！\n"}]