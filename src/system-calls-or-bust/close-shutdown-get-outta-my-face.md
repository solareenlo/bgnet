# 5.9 `close()` and `shutdown()`---私の前から失せな！

ふぅー、一日中データの送受信（`send()`ing と `recv()`ing）をしていて、もう限界です。ソケットディスクリプタの接続を閉じる準備ができました。これは簡単です。通常の Unix ファイルディスクリプタの `close()` 関数を使えばいいのです。

```c
close(sockfd);
```

これにより、それ以上のソケットへの読み書きができなくなります。リモート側でソケットの読み書きをしようとすると、エラーが発生します。

ソケットの閉じ方をもう少し制御したい場合は、`shutdown()` 関数を使用します。この関数では、特定の方向、あるいは両方の通信を遮断することができます（ちょうど `close()` がそうであるように）。書式：

```c
int shutdown(int sockfd, int how);
```

`sockfd` はシャットダウンしたいソケットファイル記述子、`how` は以下のいずれかです。

| `how` | Effect                                       |
|:-----:|----------------------------------------------|
|  `0`  | それ以上の受信は不可                         |
|  `1`  | それ以上の送信は禁止                         |
|  `2`  | それ以上の送受信は禁止（`close()` のように） |

`shutdown()` は成功すると `0` を、エラーが発生すると `-1` を返します（`errno` は適宜設定されます）。

データグラムソケットが接続されていない状態で `shutdown()` を使用すると、それ以降の `send()` および `recv()` 呼び出しに使用できなくなります（データグラムソケットを `connect()` した場合、これらを使用できることを忘れないでください）。

`shutdown()` は実際にはファイルディスクリプタを閉じないことに注意することが重要です。ソケットディスクリプタを解放するには、`close()` を使用する必要があります。

何もないんだけどね。

（ただし、Windows と Winsock を使用している場合は、`close()` ではなく `closesocket()` を呼び出すべきであることを忘れないでください。）
