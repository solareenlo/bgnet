# 2.2 低レベルのナンセンスとネットワーク理論

先ほどプロトコルの階層化について触れましたので、そろそろネットワークが実際にどのように動作するのか、そして `SOCK_DGRAM` パケットがどのように構築されるのかについて、いくつかの例を挙げて説明しましょう。実際のところ、この章は読み飛ばしても大丈夫でしょう。しかし、良い背景にはなります。

<figure>
  <img
  src="images/dataencap.svg"
  alt="[Encapsulated Protocols Diagram]">
  <figcaption>データのカプセル化</figcaption>
</figure>

子供たちよ、データカプセル化について学ぶ時間だ！これはとても重要なことです。あまりに重要なので、このチコステでネットワークの授業を受けると、このことを学ぶことになるかもしれません `;-)`。基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えば TFTP プロトコル）によってヘッダー（まれにフッターも）でラップ（"カプセル化"）され、次のプロトコル（例えば UDP）によって全体（TFTP ヘッダーも含む）が再びカプセル化され、さらに次のプロトコル（IP）によってカプセル化され、ハードウェア（物理）層（例えば Ethernet）の最終プロトコルによって再びカプセル化されます。

他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルが IP と UDP ヘッダを、TFTP プログラムが TFTP ヘッダを取り除き、ようやくデータを手に入れることができます。

これでやっと悪名高いレイヤードネットワークモデル（通称 "ISO/OSI"）について語れるようになりました。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。

さっそくですが、本格的なモデルのレイヤーを紹介します。ネットワーククラスの試験のために覚えておいてください。

* アプリケーション層
* プレゼンテーション層
* セッション層
* トランスポート層
* ネットワーク層
* データリンク層
* 物理層

物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと相互作用する場所です。

さて、このモデルは、本当にやろうと思えば、自動車の修理ガイドとして使えるほど一般的なものです。Unix とより整合性のあるレイヤーモデルは、次のようなものでしょう。

* アプリケーション層 (_telnet, ftp, etc._)
* ホスト間トランスポート層 (_TCP, UDP_)
* インターネット層 (_IP and routing_)
* ネットワークアクセス層 (_Ethernet, wi-fi, or whatever_)

この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。

シンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ！そして、"`cat`" を使って自分でパケットヘッダを入力しなければならないのです！冗談です。ストリームソケットでやるべきことは、データを `send()` することだけです。データグラムソケットでは、あなたが選んだメソッドでパケットをカプセル化し、`sendto()` で送り出すだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築します。ああ、現代の技術ですね。

というわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていました：何もありません！（笑）。その通り、全く話すつもりはありません。ルータはパケットを IP ヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、[IP RFC](https://datatracker.ietf.org/doc/html/rfc791) をチェックしてみてください。もしあなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。
