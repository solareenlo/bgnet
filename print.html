<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <link rel="preload" as="font" type="../font/woff2" href="fonts/noto-serif-jp-v15-japanese-200.woff2" crossorigin>
        <link rel="preload" as="font" type="../font/woff2" href="fonts/noto-serif-jp-v15-japanese-300.woff2" crossorigin>
        <link rel="preload" as="font" type="../font/woff2" href="fonts/noto-serif-jp-v15-japanese-500.woff2" crossorigin>
        <link rel="preload" as="font" type="../font/woff2" href="fonts/noto-serif-jp-v15-japanese-600.woff2" crossorigin>
        <link rel="preload" as="font" type="../font/woff2" href="fonts/noto-serif-jp-v15-japanese-700.woff2" crossorigin>
        <link rel="preload" as="font" type="../font/woff2" href="fonts/noto-serif-jp-v15-japanese-900.woff2" crossorigin>
        <link rel="preload" as="font" type="../font/woff2" href="fonts/noto-serif-jp-v15-japanese-regular.woff2" crossorigin>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Beej のネットワークプログラミング入門</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <link rel="stylesheet" href="fonts/font.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/theme/solarized-light-hljs.css">
        <link rel="stylesheet" href="src/theme/solarized-dark-hljs.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Home</a></li><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> 序説</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/audience.html"><strong aria-hidden="true">1.1.</strong> 対象読者</a></li><li class="chapter-item expanded "><a href="intro/platform-and-compiler.html"><strong aria-hidden="true">1.2.</strong> プラットフォームとコンパイラ</a></li><li class="chapter-item expanded "><a href="intro/official-homepage-and-books-for-sale.html"><strong aria-hidden="true">1.3.</strong> 公式ホームページと販売書籍</a></li><li class="chapter-item expanded "><a href="intro/note-for-solaris-sunos-programmers.html"><strong aria-hidden="true">1.4.</strong> Solaris/SunOS プログラマへの注意事項</a></li><li class="chapter-item expanded "><a href="intro/note-for-windows-programmers.html"><strong aria-hidden="true">1.5.</strong> Windows プログラマへの注意事項</a></li><li class="chapter-item expanded "><a href="intro/email-policy.html"><strong aria-hidden="true">1.6.</strong> メールポリシー</a></li><li class="chapter-item expanded "><a href="intro/mirroring.html"><strong aria-hidden="true">1.7.</strong> ミラーリング</a></li><li class="chapter-item expanded "><a href="intro/note-for-translators.html"><strong aria-hidden="true">1.8.</strong> 翻訳者への注意事項</a></li><li class="chapter-item expanded "><a href="intro/copyright-distribution-and-legal.html"><strong aria-hidden="true">1.9.</strong> 著作権・配布・法的事項</a></li><li class="chapter-item expanded "><a href="intro/dedication.html"><strong aria-hidden="true">1.10.</strong> 献辞</a></li><li class="chapter-item expanded "><a href="intro/publishing-information.html"><strong aria-hidden="true">1.11.</strong> 出版情報</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-a-socket/index.html"><strong aria-hidden="true">2.</strong> ソケットとは？</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-a-socket/two-types-of-internet-sockets.html"><strong aria-hidden="true">2.1.</strong> 2種類のインターネットソケット</a></li><li class="chapter-item expanded "><a href="what-is-a-socket/low-level-nonsense-and-network-theory.html"><strong aria-hidden="true">2.2.</strong> 低レベルのナンセンスとネットワーク理論</a></li></ol></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/index.html"><strong aria-hidden="true">3.</strong> IP アドレス, 構造体, データマンジング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/ip-addresses-versions-4-and-6.html"><strong aria-hidden="true">3.1.</strong> IP アドレス、バージョン4と6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/subnets.html"><strong aria-hidden="true">3.1.1.</strong> サブネット</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/port-munbers.html"><strong aria-hidden="true">3.1.2.</strong> ポート番号</a></li></ol></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/byte-order.html"><strong aria-hidden="true">3.2.</strong> バイトオーダー</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/structs.html"><strong aria-hidden="true">3.3.</strong> 構造体</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/ip-addresses-part-deux.html"><strong aria-hidden="true">3.4.</strong> IP アドレス、パート2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/private-or-disconnected-networks.html"><strong aria-hidden="true">3.4.1.</strong> プライベート（またはディスコネクト）ネットワーク</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="jumping-from-ipv4-to-ipv6/index.html"><strong aria-hidden="true">4.</strong> IPv4 から IPv6 へのジャンプ</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/index.html"><strong aria-hidden="true">5.</strong> システムコールかバスト</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="system-calls-or-bust/getaddrinfo-prepare-to-launch.html"><strong aria-hidden="true">5.1.</strong> getaddrinfo()---起動の準備をしよう！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/socket-get-the-file-descriptor.html"><strong aria-hidden="true">5.2.</strong> socket()---ファイル記述子を取得しよう！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/bind-what-port-am-i-on.html"><strong aria-hidden="true">5.3.</strong> bind()---私はどのポートにいるのでしょうか？</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/connect-hey-you.html"><strong aria-hidden="true">5.4.</strong> connect()---やあ、こんにちは！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/listen-will-somebody-please-call-me.html"><strong aria-hidden="true">5.5.</strong> listen()---誰かコールしてくれない？</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/accept-thank-you-for-calling-port-3490.html"><strong aria-hidden="true">5.6.</strong> accept()---&quot;3490番ポートにコールいただきありがとうございます。&quot;</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/send-and-recv-talk-to-me-baby.html"><strong aria-hidden="true">5.7.</strong> send() と recv()---話せよ、ベイビー！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/sendto-and-recvfrom-talk-to-me-GDRAM-style.html"><strong aria-hidden="true">5.8.</strong> sendto() と recvfrom()---DGRAM スタイルで話して。</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/close-and-shutdown-get-outta-my-face.html"><strong aria-hidden="true">5.9.</strong> close() と shutdown()---私の前から失せな！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/getpeername-who-are-you.html"><strong aria-hidden="true">5.10.</strong> getpeername()---あなたは誰ですか？</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/gethostname-who-am-i.html"><strong aria-hidden="true">5.11.</strong> gethostname()---私は誰なのか？</a></li></ol></li><li class="chapter-item expanded "><a href="client-server-background/index.html"><strong aria-hidden="true">6.</strong> クライアント-サーバの背景</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client-server-background/a-simple-stream-server.html"><strong aria-hidden="true">6.1.</strong> シンプルなストリームサーバ</a></li><li class="chapter-item expanded "><a href="client-server-background/a-simple-stream-client.html"><strong aria-hidden="true">6.2.</strong> シンプルなストリームクライアント</a></li><li class="chapter-item expanded "><a href="client-server-background/datagram-sockets.html"><strong aria-hidden="true">6.3.</strong> データグラムソケット</a></li></ol></li><li class="chapter-item expanded "><a href="slightly-advanced-techniques/index.html"><strong aria-hidden="true">7.</strong> 少し高度なテクニック</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="slightly-advanced-techniques/blocking.html"><strong aria-hidden="true">7.1.</strong> ブロッキング</a></li><li class="chapter-item expanded "><a href="slightly-advanced-techniques/poll-synchronous-io-multiplexing.html"><strong aria-hidden="true">7.2.</strong> poll()---同期式 I/O 多重化</a></li><li class="chapter-item expanded "><a href="slightly-advanced-techniques/select-synchronous-io-multiplexing-old-school.html"><strong aria-hidden="true">7.3.</strong> select()---同期式 I/O 多重化、旧式</a></li><li class="chapter-item expanded "><a href="slightly-advanced-techniques/handling-partial-sends.html"><strong aria-hidden="true">7.4.</strong> 部分的な send()s の処理</a></li><li class="chapter-item expanded "><a href="slightly-advanced-techniques/serialization-how-to-pack-data.html"><strong aria-hidden="true">7.5.</strong> シリアライゼーション---データの詰め方</a></li><li class="chapter-item expanded "><a href="slightly-advanced-techniques/son-of-data-encapsulation.html"><strong aria-hidden="true">7.6.</strong> データカプセル化の子</a></li><li class="chapter-item expanded "><a href="slightly-advanced-techniques/broadcast-packets-hello-world.html"><strong aria-hidden="true">7.7.</strong> ブロードキャストパケット---Hello, World!</a></li></ol></li><li class="chapter-item expanded "><a href="common-questions/index.html"><strong aria-hidden="true">8.</strong> よくある質問</a></li><li class="chapter-item expanded "><a href="man-pages/index.html"><strong aria-hidden="true">9.</strong> Man ページ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="man-pages/accept.html"><strong aria-hidden="true">9.1.</strong> accept()</a></li><li class="chapter-item expanded "><a href="man-pages/bind.html"><strong aria-hidden="true">9.2.</strong> bind()</a></li><li class="chapter-item expanded "><a href="man-pages/connect.html"><strong aria-hidden="true">9.3.</strong> connect()</a></li><li class="chapter-item expanded "><a href="man-pages/close.html"><strong aria-hidden="true">9.4.</strong> close()</a></li><li class="chapter-item expanded "><a href="man-pages/getaddrinfo-freeaddrinfo-gai_strerror.html"><strong aria-hidden="true">9.5.</strong> getaddrinfo(), freeaddrinfo(), gai_strerror()</a></li><li class="chapter-item expanded "><a href="man-pages/gethostname.html"><strong aria-hidden="true">9.6.</strong> gethostname()</a></li><li class="chapter-item expanded "><a href="man-pages/gethostbyname-gethostbyaddr.html"><strong aria-hidden="true">9.7.</strong> gethostbyname(), gethostbyaddr()</a></li><li class="chapter-item expanded "><a href="man-pages/getnameinfo.html"><strong aria-hidden="true">9.8.</strong> getnameinfo()</a></li><li class="chapter-item expanded "><a href="man-pages/getpeername.html"><strong aria-hidden="true">9.9.</strong> getpeername()</a></li><li class="chapter-item expanded "><a href="man-pages/errno.html"><strong aria-hidden="true">9.10.</strong> errno</a></li><li class="chapter-item expanded "><a href="man-pages/fcntl.html"><strong aria-hidden="true">9.11.</strong> fcntl()</a></li><li class="chapter-item expanded "><a href="man-pages/htons-htonl-ntohs-ntohl.html"><strong aria-hidden="true">9.12.</strong> htons(), htonl(), ntohs(), ntohl()</a></li><li class="chapter-item expanded "><a href="man-pages/inet_ntoa-inet_aton-inet_addr.html"><strong aria-hidden="true">9.13.</strong> inet_ntoa(), inet_aton(), inet_addr</a></li><li class="chapter-item expanded "><a href="man-pages/inet_ntop-inet-pton.html"><strong aria-hidden="true">9.14.</strong> inet_ntop(), inet_pton()</a></li><li class="chapter-item expanded "><a href="man-pages/listen.html"><strong aria-hidden="true">9.15.</strong> listen()</a></li><li class="chapter-item expanded "><a href="man-pages/perror-strerror.html"><strong aria-hidden="true">9.16.</strong> perror(), strerror()</a></li><li class="chapter-item expanded "><a href="man-pages/poll.html"><strong aria-hidden="true">9.17.</strong> poll()</a></li><li class="chapter-item expanded "><a href="man-pages/recv-recvfrom.html"><strong aria-hidden="true">9.18.</strong> recv(), recvfrom()</a></li><li class="chapter-item expanded "><a href="man-pages/select.html"><strong aria-hidden="true">9.19.</strong> select()</a></li><li class="chapter-item expanded "><a href="man-pages/setsockopt-getsockopt.html"><strong aria-hidden="true">9.20.</strong> setsockopt(), getsockopt()</a></li><li class="chapter-item expanded "><a href="man-pages/send-sendto.html"><strong aria-hidden="true">9.21.</strong> send(), sendto()</a></li><li class="chapter-item expanded "><a href="man-pages/shutdown.html"><strong aria-hidden="true">9.22.</strong> shutdown()</a></li><li class="chapter-item expanded "><a href="man-pages/socket.html"><strong aria-hidden="true">9.23.</strong> socket()</a></li><li class="chapter-item expanded "><a href="man-pages/struct-sockaddr-and-pals.html"><strong aria-hidden="true">9.24.</strong> struct sockaddr and pals</a></li></ol></li><li class="chapter-item expanded "><a href="more-references/index.html"><strong aria-hidden="true">10.</strong> その他の参考文献</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="more-references/books.html"><strong aria-hidden="true">10.1.</strong> 書籍</a></li><li class="chapter-item expanded "><a href="more-references/web-references.html"><strong aria-hidden="true">10.2.</strong> Web 参考文献</a></li><li class="chapter-item expanded "><a href="more-references/rfcs.html"><strong aria-hidden="true">10.3.</strong> RFCs</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="solarized-light">Solarized Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="solarized-dark">Solarized Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Beej のネットワークプログラミング入門</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/solareenlo/bgnet" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 align="center">Beej のインターネットソケットを利用したネットワークプログラミング入門</h1>
<p align="center">
Brian “Beej Jorgensen” Hall
</p>
<p align="center">
v3.1.5, Copyright © November 20, 2020
</p>
<h2 id="ここは何"><a class="header" href="#ここは何">ここは何？</a></h2>
<p><a href="https://beej.us/guide/bgnet/html/">https://beej.us/guide/bgnet/html/</a> の日本語訳</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://beej.us/guide/bgnet/">https://beej.us/guide/bgnet/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-序説"><a class="header" href="#1-序説">1 序説</a></h1>
<p>おいおい、ソケットプログラミングで参ってるのか？このようなことは <code>man</code> ページから理解するには少し難しすぎるのではありませんか？クールなインターネットプログラミングをしたいけど、<code>connect()</code> の前に <code>bind()</code> を呼ばないといけないのか、などなど、<code>struct</code> のゴブをかき分けている時間はないでしょう。</p>
<p>さて、どうでしょう！？私はもうこの厄介なビジネスをやり遂げました。そして、この情報をみんなと共有したくてたまらないのです！あなたは正しい場所に来たのです。この文書は、平均的な有能なCプログラマーが、このネットワーク・ノイズに対処するために必要なエッジを与えてくれるはずです。</p>
<p>そして、チェックしてみてください。私はついに未来に追いつき、（ちょうどいいタイミングで！）IPv6 用にガイドを更新しました。お楽しみに！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-対象読者"><a class="header" href="#11-対象読者">1.1 対象読者</a></h1>
<p>このドキュメントは、完全なリファレンスではなく、チュートリアルとして書かれています。 ソケットプログラミングを始めたばかりで、足がかりを探している人が読むと、おそらく最適なものになるでしょう。ソケットプログラミングの完全なガイドではありません。</p>
<p>でも、うまくいけば、あのマニュアルページが意味を持ち始めるかもしれませんね...。<code>:-)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-プラットフォームとコンパイラ"><a class="header" href="#12-プラットフォームとコンパイラ">1.2 プラットフォームとコンパイラ</a></h1>
<p>この文書に含まれるコードは、Gnu の <code>gcc</code> コンパイラを使用して Linux PC でコンパイルされています。しかし、<code>gcc</code> を使うプラットフォームであれば、ほぼ全てのプラットフォームでビルドできるはずです。当然ながら、Windows 用のプログラミングには適用されません。以下の <a href="intro/note-for-windows-programmers.html">Windows プログラマへの注意事項</a>の章を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-公式ホームページと販売書籍"><a class="header" href="#13-公式ホームページと販売書籍">1.3 公式ホームページと販売書籍</a></h1>
<p>このドキュメントの正式な所在地は</p>
<ul>
<li><a href="https://beej.us/guide/bgnet/"><code>https://beej.us/guide/bgnet/</code></a></li>
</ul>
<p>また、サンプルコードや様々な言語への翻訳も掲載されています。</p>
<p>製本された印刷物（&quot;本&quot;と呼ぶ人もいる）を購入するには、以下をご覧ください。</p>
<ul>
<li><a href="https://beej.us/guide/url/bgbuy"><code>https://beej.us/guide/url/bgbuy</code></a></li>
</ul>
<p>文書作成生活の維持に役立つので、購入はありがたいです！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-solarissunos-プログラマへの注意事項"><a class="header" href="#14-solarissunos-プログラマへの注意事項">1.4 Solaris/SunOS プログラマへの注意事項</a></h1>
<p>Solaris または SunOS 用にコンパイルする場合、適切なライブラリをリンクするために、いくつかの特別なコマンドラインスイッチを指定する必要があります。これを行うには、コンパイルコマンドの最後に &quot;<code>-lnsl -lsocket -lresolv</code>&quot; を以下のように追加するだけです。</p>
<pre><code>$ cc -o server server.c -lnsl -lsocket -lresolv
</code></pre>
<p>それでもエラーが出るようなら、さらにそのコマンドラインの最後に <code>-lxnet</code> を追加してみるといいでしょう。それが何をするのか正確にはわかりませんが、必要な人もいるようです。</p>
<p>もう一つ問題がありそうなのは、<code>setsockopt()</code> の呼び出しのところです。プロトタイプは私の Linux ボックスのものとは異なるので、代わりに</p>
<pre><code class="language-c">int yes=1;
</code></pre>
<pre><code class="language-c">char yes='1';
</code></pre>
<p>を入力します。</p>
<p>私は Sunbox を持っていないので、上記の情報を検証したわけではありません---あくまでメールで教えてもらったことです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-windows-プログラマへの注意事項"><a class="header" href="#15-windows-プログラマへの注意事項">1.5 Windows プログラマへの注意事項</a></h1>
<p>このガイドの時点では、歴史的に、私が Windows をあまり好きではないという事実のために、Windows を少し非難しています。しかし、Windows は膨大なインストールベースがあり、明らかに完璧なオペレーティングシステムであることを公平にお伝えする必要があります。</p>
<p>不在は心を豊かにすると言いますが、この場合、私はそれが真実であると信じています。(ただ、言えることは、10数年前から個人的な仕事ではマイクロソフトの OS を使っていなかったので、ずっと幸せだということです だから、安心して、&quot;どうぞ、ご自由に Windows を使ってください！&quot; と言えるのです。 ...そう、歯ぎしりしながら言うんですけどね。</p>
<p>ですから私は、<a href="https://www.linux.com/">Linux</a> や <a href="https://bsd.org/">BSD</a>、あるいは Unix のいくつかのフレーバーを、代わりに試してみることをお勧めします。</p>
<p>しかし、人は好きなものを好きになるものです。Windows の皆さんは、この情報が、もしあれば、いくつかの小さな変更を加えて、あなた方にも一般的に適用できることを知って喜んでいることでしょう。</p>
<p>Windows 用の Unix ツールの集合体である <a href="https://cygwin.com/">Cygwin</a> をインストールするのもいい方法です。そうすると、これらのプログラムはすべて修正なしでコンパイルできるようになると、人づてに聞いたことがあります。</p>
<p>もうひとつ、<a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux</a> も検討してみてください。これは基本的に、Windows 10 に Linux の VM 的なものをインストールすることができます。これもまた、間違いなく位置づけられるでしょう。</p>
<p>しかし、中には純粋な Windows のやり方で物事を進めたいと思う人もいるかもしれません。それはとてもガッツのあることで、こうすればいいんです。すぐに Unix を買ってきてください! いやいや---冗談です。最近は Windows フレンドリー(笑)なはずなんですが...。</p>
<p>これは、あなたがしなければならないことです（<a href="https://cygwin.com/">Cygwin</a>をインストールしない限り！）：まず、ここで私が言及するシステムヘッダーファイルのほとんどを無視してください。あなたがインクルードする必要があるのは、以下のものだけです。</p>
<pre><code class="language-c">#include &lt;winsock.h&gt;
</code></pre>
<p>待ってください！ソケットライブラリで何かする前に <code>WSAStartup()</code> を呼び出す必要があります。これを行うためのコードは以下のようなものです。</p>
<pre><code class="language-c editable">#include &lt;winsock.h&gt;

{
    WSADATA wsaData;   // if this doesn't work
    //WSAData wsaData; // then try this instead

    // MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:

    if (WSAStartup(MAKEWORD(1,1), &amp;wsaData) != 0) {
        fprintf(stderr, &quot;WSAStartup failed.\n&quot;);
        exit(1);
    }
</code></pre>
<p>また、Winsock ライブラリをリンクするようにコンパイラに指示する必要があります。通常、<code>wsock32.lib</code> または <code>winsock32.lib</code>、Winsock 2.0 の場合は <code>ws2_32.lib</code> と呼ばれます。VC++ では、これは <code>Project</code> メニューの <code>Settings...</code> から行うことができます。<code>Link</code> タブをクリックし、&quot;Object/library modules&quot; というタイトルのボックスを探します。そのリストに &quot;wsock32.lib&quot;（または、お好みの lib）を追加してください。</p>
<p>とか聞いています。</p>
<p>最後に、ソケットライブラリを使い終わったら、<code>WSACleanup()</code> を呼び出す必要があります。詳しくはオンラインヘルプを参照してください。</p>
<p>一度これを行えば、このチュートリアルの残りの例は、いくつかの例外を除いて、概ね適用できるはずです。ひとつは、ソケットを閉じるために <code>close()</code> を使うことができません。また、<code>select()</code> はソケット記述子に対してのみ動作し、ファイル記述子に対しては動作しません（<code>stdin</code> に対する <code>0</code> のように）。</p>
<p>また、<code>CSocket</code> というソケットクラスもあります。詳細はコンパイラのヘルプを参照してください。</p>
<p>Winsock についての詳しい情報は、<a href="https://tangentsoft.net/wskfaq/">Winsock FAQ</a> を読んで、そこから進んでください。</p>
<p>最後に、Windows には <code>fork()</code> システムコールがないそうですが、これは残念ながら私の例のいくつかで使われているものです。多分、POSIX ライブラリか何かをリンクしないと動かないでしょうし、代わりに <code>CreateProcess()</code> を使ってもいいでしょう。<code>fork()</code> は引数を取らず、<code>CreateProcess()</code> は約480億の引数を取ります。もし、そこまで気が回らないのであれば、<code>CreateThread()</code> の方が少し消化しやすいでしょう。残念ながら、マルチスレッドに関する議論はこのドキュメントの範囲外です。私が語れることは限られているのですからね!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-メールポリシー"><a class="header" href="#16-メールポリシー">1.6 メールポリシー</a></h1>
<p>メールでの質問には基本的に対応しますので、気軽に書き込んでください。ただし、返事を保証するものではありません。私はかなり忙しい生活を送っているので、どうしても質問に答えられないことがあります。そのような場合は、メッセージを削除します。個人的なことではなく、あなたが必要とする詳細な回答をする時間がないだけなのです。</p>
<p>原則として、質問が複雑であればあるほど、回答できる可能性は低くなります。質問を送る前に質問を絞り込み、関連する情報（プラットフォーム、コンパイラ、表示されるエラーメッセージなど、トラブルシューティングに役立ちそうなもの）を必ず記載していただければ、回答が得られる可能性は高くなります。より詳しい情報は、ESRのドキュメント、<a href="http://www.catb.org/%7Eesr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a> をお読みください。</p>
<p>返事がない場合は、もう少し調べてみて、答えが見つからなければ、また調べてみてください。そして調べたことまたを書き込んでください。その結果、私がお手伝いできるようになることを期待しています。</p>
<p>さて、手紙の書き方、書き方についておせっかいを焼いてしまいましたが、このガイドが何年にもわたって賞賛されてきたことに、私は十分に感謝していることをお伝えしておきたいと思います。このガイドが良いことに使われていると聞いて、私はとても嬉しくなりました。<code>:-)</code> ありがとうございます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-ミラーリング"><a class="header" href="#17-ミラーリング">1.7 ミラーリング</a></h1>
<p>このサイトをミラーリングすることは、公的にも私的にも大歓迎です。もし、あなたがこのサイトを公的にミラーリングし、メインページからリンクしてほしい場合は、<code>beej@beej.us</code> までご連絡ください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-翻訳者への注意事項"><a class="header" href="#18-翻訳者への注意事項">1.8 翻訳者への注意事項</a></h1>
<p>もし、このガイドを他の言語に翻訳したい場合は、<code>beej@beej.us</code> までメールをいただければ、メインページからあなたの翻訳をリンクさせていただきます。翻訳にはあなたの名前と連絡先を自由に追加してください。</p>
<p>このソースマークダウン文書は UTF-8 エンコーディングを使用しています。</p>
<p>後述の <a href="intro/copyright-distribution-and-legal.html">著作権・配布・法的事項</a> の章に記載されている使用許諾条件にご注意ください。</p>
<p>もし私に翻訳をホストして欲しいのであれば、言ってください。また、あなたがホストすることを望むなら、私はそれにリンクします；どちらでも構いません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-著作権配布法的事項"><a class="header" href="#19-著作権配布法的事項">1.9 著作権・配布・法的事項</a></h1>
<pre><code class="language-text">Beej's Guide to Network Programming is Copyright © 2019 Brian &quot;Beej Jorgensen&quot; Hall.
</code></pre>
<p>この作品は、以下のソースコードと翻訳に関する特定の例外を除き、クリエイティブ・コモンズ 表示-非営利-改変禁止 3.0 ライセンスの下に提供されています。このライセンスのコピーを見るには、以下をご覧ください。</p>
<p><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/"><code>https://creativecommons.org/licenses/by-nc-nd/3.0/</code></a></p>
<p>または、Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA に手紙を送ってください。</p>
<p>本使用許諾の &quot;二次的著作物の禁止&quot; 部分の具体的な例外は、次のとおりです：このガイドは、翻訳が正確である限り、どの言語にも自由に翻訳でき、ガイド全体を再印刷することができます。翻訳には、オリジナルのガイドと同じライセンスの制約が適用されます。翻訳には、翻訳者の名前と連絡先も含めることができます。</p>
<p>本書で紹介する C 言語のソースコードは、パブリックドメインとして許諾され、いかなるライセンス制限もありません。</p>
<p>教育関係者は、このガイドを生徒に勧めたり、コピーを提供したりすることを自由に推奨します。</p>
<p>書面による相互の合意がない限り、著者は作品を現状のまま提供し、作品に関して、明示的、黙示的、法定またはその他のいかなる種類の表明または保証（権利、商品性、特定目的への適合性、非侵害、潜在的またはその他の欠陥の不在、精度、または発見可能かどうかにかかわらず誤りの有無の保証を含むが、これに限定されない）も行わないものとします。</p>
<p>適用される法律で要求される範囲を除き、いかなる場合においても、著作者は、著作物の使用から生じる特別損害、付随的損害、結果的損害、懲罰的損害または典型的損害について、たとえ著作者がその損害の可能性を知らされていたとしても、いかなる法的理論によってもお客様に対して責任を負うことはないものとします。</p>
<p>お問い合わせは <code>beej@beej.us</code> までお願いします。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="110-献辞"><a class="header" href="#110-献辞">1.10 献辞</a></h1>
<p>このガイドを書くにあたり、過去から未来にわたって協力してくださった皆様に感謝します。そして、私がこのガイドを作るために使っているフリーソフトやパッケージを制作しているすべての人に感謝します。GNU、Linux、Slackware、vim、Python、Inkscape、pandoc、その他多数。そして最後に、文字通り何千もの人々が、改善の提案や励ましの言葉を書いてくれたことに、大きな感謝を捧げます。</p>
<p>このガイドを、コンピュータの世界における私の最大のヒーローであり、インスピレーターである何人かに捧げます。Donald Knuth、Bruce Schneier、W. Richard Stevens、The Woz、そして私の読者、さらにフリーおよびオープンソースソフトウェアのコミュニティ全体に捧げます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-出版情報"><a class="header" href="#111-出版情報">1.11 出版情報</a></h1>
<p>この本は、GNU ツールを搭載した Arch Linux のマシン上で vim エディタを使って、Markdown で書かれています。表紙の &quot;アート&quot; とダイアグラムは Inkscape で作成されています。Markdown は Python、Pandoc および XeLaTeX により、Liberation フォントを用いて HTML および LaTex/PDF に変換されます。このツールチェーンは 100% フリーおよびオープンソースソフトウェアで構成されています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-ソケットとは"><a class="header" href="#2-ソケットとは">2 ソケットとは？</a></h1>
<p>&quot;ソケット&quot; という言葉をよく耳にしますが、そもそも &quot;ソケット&quot; とは何なのでしょうか？それは、標準的な Unix のファイル記述子を使って他のプログラムと会話するための方法です。</p>
<p>なんと？</p>
<p>Ok--- Unix のハッカーが &quot;Unix では何でもファイルなんだ！&quot; と言ったのを聞いたことがあるかもしれません。その人が言っているのは、Unix のプログラムが何らかの I/O を行うとき、ファイル記述子に対して読み書きを行うという事実のことかもしれません。ファイル記述子は、単純に、開いているファイルに関連する整数です。しかし、このファイルは、ネットワーク接続、FIFO、パイプ、ターミナル、ディスク上のファイルなど、あらゆるものになり得ます（ここが重要）。Unix ではすべてがファイルなのです！だから、インターネット上で他のプログラムと通信したいときは、ファイル記述子を介して行うことになるんだ。と思ってください。</p>
<p>&quot;ネットワーク通信のためのファイル記述子はどこで手に入るのですか、お利口さん？&quot; というのが、今あなたが考えている最後の質問でしょうが、とにかくそれに答えてあげましょう。あなたは <code>socket()</code> システムルーチンを呼び出すのです。このルーチンはソケット記述子を返すので、それを使って <code>send()</code> と <code>recv()</code>（<a href="what-is-a-socket/../man-pages/send-sendto.html"><code>man send</code></a>, <a href="what-is-a-socket/../man-pages/recv-recvfrom.html"><code>man recv</code></a>）という特別なソケットコールを使って通信を行います。</p>
<p>&quot;でもね！&quot; あなたは今頃、そう叫んでいるかもしれません。&quot; ファイル記述子なら、どうしてネプチューンの名において、通常の <code>read()</code> と <code>write()</code> の呼び出しでソケットを通して通信できないんだ？&quot; と。短い答えは、&quot;できる！&quot; です。もっと長い答えは、&quot;できるけど、<code>send()</code> と <code>recv()</code> はデータ転送をより大きく制御できる&quot; です。</p>
<p>次は何？どうでしょう、ソケットにはいろいろな種類がありますね。DARPA インターネットアドレス（インターネットソケット）、ローカルノード上のパス名（Unix ソケット）、CCITT X.25 アドレス（X.25 ソケット、無視しても大丈夫）、そしておそらくあなたが実行する Unix のフレーバーに応じて他の多くの種類があります。この文書では、最初の &quot;インターネットソケット&quot; のみを扱います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-2種類のインターネットソケット"><a class="header" href="#21-2種類のインターネットソケット">2.1 2種類のインターネットソケット</a></h1>
<p>これは何？インターネットソケットには2種類ある？そうです。まあ、違うけど。嘘です。もっとあるんだけど、怖がらせたくなかったんだ。ここでは2種類しか話しません。ただし、この文章では、&quot;Raw Sockets&quot; も非常に強力なので、ぜひ調べてみてくださいと言うつもりです。</p>
<p>わかったよ、もう。この2つのタイプは何ですか？一つは &quot;ストリームソケット&quot;、もう一つは &quot;データグラムソケット&quot; で、以下、それぞれ &quot;<code>SOCK_STREAM</code>&quot; &quot;<code>SOCK_DGRAM</code>&quot; と呼ぶことがあります。データグラムソケットは &quot;コネクションレス型ソケット&quot; と呼ばれることもあります 。（ただし、本当に必要であれば <code>connect()</code> を使用することができます。後述の <a href="what-is-a-socket/../system-calls-or-bust/connect-hey-you.html"><code>connect()</code></a> を参照してください。）</p>
<p>ストリームソケットは、信頼性の高い双方向接続の通信ストリームです。ソケットに2つのアイテムを &quot;1, 2&quot; という順序で出力すると、反対側にも &quot;1, 2&quot; という順序で届きます。また、エラーも発生しません。実際、私はエラーフリーであることを確信しています。もし、そうでないと主張する人がいたら、耳に指を突っ込んで &quot;ララララ&quot; と唱えてやりたいくらいです。</p>
<p>何がストリーム・ソケットを使うのでしょうか？さて、皆さんは <code>telnet</code> というアプリケーションをご存知でしょうか？あれはストリームソケットを使っているんです。あなたが入力した文字は、すべて入力した順番に到着する必要がありますよね？また、Webブラウザは HTTP（Hypertext Transfer Protocol）を使っていますが、これはストリームソケットを使ってページを取得します。実際、80番ポートで Web サイトに telnet して、&quot;<code>GET / HTTP/1.0</code>&quot; と入力してリターンを2回押すと、HTML がダンプされて戻ってきますよ。</p>
<p>もし <code>telnet</code> がインストールされておらず、インストールもしたくない場合、あるいは <code>telnet</code> がクライアントとの接続にうるさい場合、ガイドには <a href="https://beej.us/guide/bgnet/examples/telnot.c"><code>telnot</code></a> という <code>telnet</code> に似たプログラムが付属しています。これは、このガイドで必要なものすべてに対してうまく機能するはずです。（なお、telnet は実際には <a href="https://datatracker.ietf.org/doc/html/rfc854">spec'd networking protocol</a> であり、<code>telnot</code> はこのプロトコルを全く実装していません。）</p>
<p>ストリームソケットは、どのようにしてこの高いレベルのデータ伝送品質を実現しているのでしょうか。 それは、&quot;TCP&quot; として知られる &quot;伝送制御プロトコル&quot;（TCP の詳細については <a href="https://datatracker.ietf.org/doc/html/rfc793">RFC 793</a> を参照）というプロトコルを使用しているからです。TCP はデータが順次、エラーなく到着することを確認します。&quot;TCP&quot; は &quot;TCP/IP&quot; の半分で、&quot;IP&quot; は &quot;Internet Protocol&quot;（<a href="https://datatracker.ietf.org/doc/html/rfc791">RFC 791</a> を参照）の略だと聞いたことがあるかもしれません。IP は主にインターネット・ルーティングを扱い、一般にデータの完全性には責任を持ちません。</p>
<p>かっこいい。データグラムソケットについてはどうでしょうか？なぜコネクションレス型と呼ばれるのでしょうか？どうなっているんだ？なぜ信頼性が低いのでしょうか？データグラムを送ると、それが届くかもしれません。データグラムを送信すると、それは到着するかもしれません。もし到着すれば、パケット内のデータはエラーフリーです。</p>
<p>データグラムソケットもルーティングに IP を使いますが、TCP は使わず、&quot;User Datagram Protocol&quot;、つまり &quot;UDP&quot; を使います（<a href="https://datatracker.ietf.org/doc/html/rfc768">RFC 768</a> を参照）。</p>
<p>なぜコネクションレスレスなのか？まあ、基本的には、ストリームソケットのようにオープンな接続を維持する必要がないからです。パケットを作り、その上に宛先情報を含む IP ヘッダを貼り付け、送信するだけでいいのです。コネクションは必要ありません。一般的には、TCP スタックが利用できないときや、パケットをいくつか落としても宇宙の終わりを意味しないときに使用されます。サンプルアプリケーション：<code>tftp</code>（FTP の弟分のようなファイル転送プロトコル）、<code>dhcpcd</code>（DHCP クライアント）、マルチプレイヤーゲーム、ストリーミングオーディオ、ビデオ会議、などなど。</p>
<p>&quot;ちょっと待った！<code>tftp</code> と <code>dhcpcd</code> はバイナリアプリケーションをあるホストから別のホストに転送するために使われるんだ！アプリケーションが到着したときに動作することを期待するならば、データが失われることはありえない！これはどんな黒魔術なんだ？&quot;</p>
<p>さて、私の人間の友人である <code>tftp</code> やそれに類するプログラムは、UDP の上に独自のプロトコルを載せています。たとえば、tftp プロトコルは、送信されたパケットごとに、受信者は &quot;受け取ったよ！&quot; というパケット（&quot;ACK&quot; パケット）を送り返さなければなりません。元のパケットの送信者は、例えば5秒間返信がない場合、最終的に ACK を得るまでパケットを再送信することになります。この確認手続きは、信頼性の高い <code>SOCK_DGRAM</code> アプリケーションを実装する際に非常に重要です。</p>
<p>ゲーム、オーディオ、ビデオなどの信頼性の低いアプリケーションでは、ドロップしたパケットを無視するか、あるいは巧みに補うようにします。（Quake プレイヤーは、この効果の発現を呪われたラグという専門用語で知っていることでしょう。この場合の &quot;呪われた&quot; という単語は、非常に不敬な発言を意味します。）</p>
<p>なぜ信頼性の低い基礎プロトコルを使うのでしょうか？理由は2つ、速度とスピードです。何が無事に到着したかを追跡し、順序立てて確認したりするよりも、発射して忘れる方がずっと速いのです。チャットメッセージを送るなら、TCP は素晴らしいです。世界中のプレイヤーの位置情報を毎秒40件送るなら、1件や2件が落ちてもそれほど問題ではないので、UDP は良い選択だと思います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-低レベルのナンセンスとネットワーク理論"><a class="header" href="#22-低レベルのナンセンスとネットワーク理論">2.2 低レベルのナンセンスとネットワーク理論</a></h1>
<p>先ほどプロトコルの階層化について触れましたので、そろそろネットワークが実際にどのように動作するのか、そして <code>SOCK_DGRAM</code> パケットがどのように構築されるのかについて、いくつかの例を挙げて説明しましょう。実際のところ、この章は読み飛ばしても大丈夫でしょう。しかし、良い背景にはなります。</p>
<figure>
  <img
  src="images/dataencap.svg"
  alt="[Encapsulated Protocols Diagram]">
  <figcaption>データのカプセル化</figcaption>
</figure>
<p>子供たちよ、データカプセル化について学ぶ時間だ！これはとても重要なことです。あまりに重要なので、このチコステでネットワークの授業を受けると、このことを学ぶことになるかもしれません <code>;-)</code>。基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えば TFTP プロトコル）によってヘッダー（まれにフッターも）でラップ（&quot;カプセル化&quot;）され、次のプロトコル（例えば UDP）によって全体（TFTP ヘッダーも含む）が再びカプセル化され、さらに次のプロトコル（IP）によってカプセル化され、ハードウェア（物理）層（例えば Ethernet）の最終プロトコルによって再びカプセル化されます。</p>
<p>他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルが IP と UDP ヘッダを、TFTP プログラムが TFTP ヘッダを取り除き、ようやくデータを手に入れることができます。</p>
<p>これでやっと悪名高いレイヤードネットワークモデル（通称 &quot;ISO/OSI&quot;）について語れるようになりました。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。</p>
<p>さっそくですが、本格的なモデルのレイヤーを紹介します。ネットワーククラスの試験のために覚えておいてください。</p>
<ul>
<li>アプリケーション層</li>
<li>プレゼンテーション層</li>
<li>セッション層</li>
<li>トランスポート層</li>
<li>ネットワーク層</li>
<li>データリンク層</li>
<li>物理層</li>
</ul>
<p>物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと相互作用する場所です。</p>
<p>さて、このモデルは、本当にやろうと思えば、自動車の修理ガイドとして使えるほど一般的なものです。Unix とより整合性のあるレイヤーモデルは、次のようなものでしょう。</p>
<ul>
<li>アプリケーション層 (<em>telnet, ftp, etc.</em>)</li>
<li>ホスト間トランスポート層 (<em>TCP, UDP</em>)</li>
<li>インターネット層 (<em>IP and routing</em>)</li>
<li>ネットワークアクセス層 (<em>Ethernet, wi-fi, or whatever</em>)</li>
</ul>
<p>この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。</p>
<p>シンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ！そして、&quot;<code>cat</code>&quot; を使って自分でパケットヘッダを入力しなければならないのです！冗談です。ストリームソケットでやるべきことは、データを <code>send()</code> することだけです。データグラムソケットでは、あなたが選んだメソッドでパケットをカプセル化し、<code>sendto()</code> で送り出すだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築します。ああ、現代の技術ですね。</p>
<p>というわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていました：何もありません！（笑）。その通り、全く話すつもりはありません。ルータはパケットを IP ヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、<a href="https://datatracker.ietf.org/doc/html/rfc791">IP RFC</a> をチェックしてみてください。もしあなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-ip-アドレス-構造体-データマンジング"><a class="header" href="#3-ip-アドレス-構造体-データマンジング">3 IP アドレス, 構造体, データマンジング</a></h1>
<p>ここからは気分転換にコードの話をするところです。</p>
<p>その前に、もっとノンコードの話をしましょう！イエーイ！まず最初に IP アドレスとポートについて少しお話したいと思いますので、それを整理します。それからソケット API がどのように IP アドレスや他のデータを保存し、操作するかについて話します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-ip-アドレスバージョン4と6"><a class="header" href="#31-ip-アドレスバージョン4と6">3.1 IP アドレス、バージョン4と6</a></h1>
<p>ベン・ケノービがまだオビワン・ケノービと呼ばれていた頃、インターネット・プロトコル・バージョン4（IPv4）と呼ばれる素晴らしいネットワーク・ルーティング・システムが存在しました。IPv4 は 4 バイト（4オクテット）で構成されるアドレスで、一般に &quot;ドットと数字&quot; で表記されるのが一般的でした。<code>192.0.2.111</code> のように。</p>
<p>皆さんも一度は目にしたことがあるのではないでしょうか。</p>
<p>実際、この記事を書いている時点では、インターネット上のほぼすべてのサイトが IPv4 を使っています。</p>
<p>オビ・ワンをはじめ、誰もが幸せでした。しかし、ヴィント・サーフという名の否定的な人物が、IPv4 アドレスが足りなくなると警告を発したのです！</p>
<p>（<a href="https://en.wikipedia.org/wiki/Vint_Cerf">ヴィント・サーフ</a>氏は、IPv4 による &quot;破滅と暗黒の黙示録&quot; の到来を警告するとともに、&quot;インターネットの父&quot; としても有名です。だから、私は彼の判断に二の足を踏む立場にはないのです。）</p>
<p>アドレスが足りなくなる？そんなことがあるのでしょうか？つまり、32ビットの IPv4 アドレスには何十億もの IP アドレスが存在するのです。本当に何十億台ものコンピュータがあるのでしょうか？</p>
<p>Yes.</p>
<p>また、コンピュータが数台しかなく、10億という数字があり得ないほど大きいと誰もが思っていた当初、いくつかの大きな組織は、自分たちが使うために何百万という IP アドレスを惜しげもなく割り当てていたのです。（ゼロックス、MIT、フォード、HP、IBM、GE、AT&amp;T、そしてアップルという小さな会社などです。）</p>
<p>実際、いくつかの応急処置がなかったら、とっくに使い果たしていたでしょう。</p>
<p>しかし今は、すべての人間が IP アドレスを持ち、すべてのコンピュータ、電卓、電話、パーキングメーター、そして（なぜか）子犬も、という時代です。</p>
<p>そして、IPv6 が誕生したのです。ヴィント・サーフはおそらく不死身なので（たとえ肉体がこの世を去ったとしても、おそらく彼はすでにインターネット2の奥深くにある超知的な <a href="https://en.wikipedia.org/wiki/ELIZA">ELIZA</a> プログラムとして存在しているはずです）、もし次のバージョンのインターネットプロトコルで十分なアドレスが確保できなければ、誰も彼の &quot;だから言っただろう&quot; という言葉を再び聞きたくはないでしょう。</p>
<p>これは何を示唆しているのでしょうか？</p>
<p>もっとたくさんのアドレスが必要だということです。2倍どころか10億倍でもなく1000兆倍でもなく 7900万ビリオン・トリリオンの数のアドレスが必要なのです！そうこなくちゃ！</p>
<p>&quot;Beej、それは本当なの？大きな数字を信じない理由があるんだ。&quot; 32ビットと128ビットの差は大したことないように聞こえるかもしれない、96ビット多いだけだろ？しかし、私たちはここで累乗の話をしていることを忘れてはなりません。32ビットは約40億の数字（\(2^{32}\)）を表し、128ビットは約340兆の数字（\(2^{128}\)）を表します。これは、宇宙の星1つに対して、100万個の IPv4 インターネットがあるようなものです。</p>
<p>IPv4 のドットや数字も忘れて、16進数では、2バイトの塊をコロンで区切って、このように表現しています。</p>
<pre><code>2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551
</code></pre>
<p>それだけではありません！多くの場合、IP アドレスにはたくさんのゼロが含まれていますが、それらを2つのコロンで区切って圧縮することができます。そして、各バイトペアの先頭のゼロを省くことができます。例えば、次のようなアドレスのペアは、それぞれ等価です。</p>
<pre><code>2001:0db8:c9d2:0012:0000:0000:0000:0051
2001:db8:c9d2:12::51

2001:0db8:ab00:0000:0000:0000:0000:0000
2001:db8:ab00::

0000:0000:0000:0000:0000:0000:0000:0001
::1
</code></pre>
<p>アドレス <code>::1</code> はループバックアドレスです。常に &quot;今使っているこのマシン&quot; という意味です。IPv4 では、ループバックアドレスは <code>127.0.0.1</code> です。</p>
<p>最後に、IPv6 アドレスの IPv4 互換モードですが、これは皆さんが遭遇する可能性のあるものです。例えば、<code>192.0.2.33</code>という IPv4 アドレスを IPv6 アドレスとして表現したい場合、次のような表記をします。&quot;<code>::ffff:192.0.2.33</code>&quot;。</p>
<p>本気で楽しみたいんです。</p>
<p>実際、IPv6 の開発者たちは、何兆個ものアドレスを軽率にも予約用に切り捨てたほど、IPv6 は楽しいものなのですが、数が多すぎて、正直言って、もう誰が数えているのでしょうか？銀河系のすべての惑星のすべての男性、女性、子供、子犬、そしてパーキングメーターのために十分な数が残されています。 信じてくれ、銀河系のどの星にもパーキングメーターはあるんだ。本当なんだ。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="311-サブネット"><a class="header" href="#311-サブネット">3.1.1 サブネット</a></h1>
<p>組織の都合上、&quot;この IP アドレスの先頭からこのビットまでがネットワーク部分、それ以外がホスト部分&quot; と宣言するのが便利な場合があります。</p>
<p>例えば、IPv4 では <code>192.0.2.12</code> というように、最初の3バイトがネットワークで、最後の1バイトがホストと言えるでしょう。あるいは、別の言い方をすれば、ネットワーク <code>192.0.2.0</code> 上のホスト <code>12</code> について話していることになります（ホストであるバイトをゼロにしているところをご覧ください）。</p>
<p>そして、さらに時代遅れの情報を！準備はいいですか？古代では、サブネットには &quot;クラス&quot; があり、アドレスの最初の1バイト、2バイト、3バイトがネットワーク部分でした。運良く1バイトがネットワーク、3バイトがホストの場合、ネットワーク上に24ビット分のホスト（1600万程度）を持つことができます。これが &quot;クラス A&quot; のネットワークです。一方、&quot;クラス C&quot; は、ネットワークが3バイト、ホストが1バイトで、256台のホスト（ただし、予約された数台は除く）を持ちます。</p>
<p>ご覧のように、クラス A がほんの少し、クラス C が大量に、そして真ん中にクラス B が何個かある状態でした。</p>
<p>IP アドレスのネットワーク部分は、ネットマスクと呼ばれるもので記述されており、IP アドレスとビット単位で AND することでネットワーク番号を取得します。ネットマスクは通常 <code>255.255.255.0</code> のような形をしています。（例えば、このネットマスクでは、あなたの IP が <code>192.0.2.12</code> なら、あなたのネットワークは <code>192.0.2.12</code> AND <code>255.255.255.0</code> で、 <code>192.0.2.0</code> となります。）</p>
<p>しかし、残念ながら、これではインターネットの最終的なニーズに対応できないことが判明した。C クラスのネットワークはすぐになくなってしまいました。そして、クラス A は間違いなく不足していました。ということは、わざわざ聞くまでもないでしょう。この問題を解決するために、権力者たちはネットマスクを 8、16、24 のどれでもなく、任意のビット数にすることを許可しました。例えば <code>255.255.255.252</code> というネットマスクは、30ビットのネットワークと2ビットのホストで、 ネットワーク上に4つのホストを置くことができます。（ネットマスクは常に1ビットの束と0ビットの束からなることに注意してください。）</p>
<p>しかし、<code>255.192.0.0</code> のような大きな数字の羅列をネットマスクとして使うのは、少し扱いにくいです。まず、それが何ビットなのかが直感的にわからないし、コンパクトでもありません。そこで新スタイルが登場したのですが、これはもっとすっきりしています。IP アドレスの後にスラッシュを付けて、その後に10進数でネットワークのビット数を指定するだけです。こんな感じです。<code>192.0.2.12/30</code>。</p>
<p>あるいは、IPv6 の場合、このようなものです。<code>2001:db8::/32</code> または <code>2001:db8:5413:4028::9db9/64</code> です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="312-ポート番号"><a class="header" href="#312-ポート番号">3.1.2 ポート番号</a></h1>
<p>以前、インターネット層（IP）とホスト間トランスポート層（TCP と UDP）を分離した<a href="ip-addresses-structs-and-data-munging/../what-is-a-socket/low-level-nonsense-and-network-theory.html">レイヤードネットワークモデル</a>をご紹介しましたが、覚えていらっしゃいますか？次の段落の前に、そのことをしっかり覚えておいてください。</p>
<p>IP アドレス（IP 層で使われる）の他に、TCP（ストリームソケット）や、同時に UDP（データグラムソケット）で使われるアドレスがあることが判明したのです。それは、ポート番号です。これは16ビットの数字で、接続のためのローカルアドレスのようなものです。</p>
<p>IP アドレスはホテルの番地、ポート番号は部屋番号だと思ってください。後で自動車業界の例も考えてみましょう。</p>
<p>例えば、受信メールとウェブサービスの両方を扱うコンピュータを用意したい場合、1つの IP アドレスを持つコンピュータでその2つを区別する方法はあるでしょうか？</p>
<p>さて、インターネット上のサービスには、それぞれ異なるウェルノウン・ポート番号が設定されています。<a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">IANA のポート一覧</a>か、Unix であれば <code>/etc/services</code> ファイルで確認することができます。HTTP（ウェブ）はポート80、telnet はポート23、SMTP はポート25、ゲーム <a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)">DOOM</a> はポート666、などなど。1024以下のポートはしばしば特殊とみなされ、通常、使用するには OS の特別な権限が必要です。</p>
<p>といったところでしょうか。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-バイトオーダー"><a class="header" href="#32-バイトオーダー">3.2 バイトオーダー</a></h1>
<p>レルムの命令で！バイトの並び順は2種類とします。今後、Lame and Magnificent と呼ばれるようになります。</p>
<p>というのは冗談ですが、本当にどちらか一方が優れているのです。<code>:-)</code></p>
<p>あなたのコンピュータは、あなたの背後でバイトを逆順に保存しているかもしれないのです。そうなんです。誰もあなたに言いたくはなかったのです。</p>
<p>つまり、2バイトの16進数、たとえば <code>b34f</code> を表現する場合、<code>b3</code> と <code>4f</code> の2バイトに続けて格納する、というのがインターネットの世界の共通認識になっているのです。これは理にかなっているし、<a href="https://en.wikipedia.org/wiki/Wilford_Brimley">ウィルフォード・ブリムリー</a>も言うように、正しい行為です。このように、大きい方の端が先になるように格納された数字をビッグエンディアン（Big-Endian）と呼びます。</p>
<p>残念ながら、世界中に散在する一部のコンピュータ、すなわちインテルまたはインテル互換のプロセッサを搭載したものは、バイトを逆に格納しているため、<code>b34f</code> は <code>4f</code> と <code>b3</code> の連続したバイトとしてメモリに格納されることになります。この記憶方式をリトルエンディアン（Little-Endian）と呼びます。</p>
<p>でも、ちょっと待ってください！用語の説明はまだ終わっていないのです。もっとまともなビッグエンディアンはネットワークバイトオーダーとも呼ばれ、私たちネットワーク系が好む順序だからです。</p>
<p>コンピュータはホストバイトオーダーで数字を記憶しています。インテル 80x86 であれば、ホストバイト順はリトルエンディアンです。モトローラ 68K の場合は、ビッグエンディアンです。PowerPC なら、ホストバイトの並びは......まあ、人それぞれですね。</p>
<p>パケットを作成するときやデータ構造を埋めるときに、2バイトや4バイトの数値がネットワークバイトオーダーになっていることを確認する必要があることがよくあります。しかし、ネイティブなホストバイトオーダーがわからない場合、どのようにすればよいのでしょうか。</p>
<p>朗報です。ホストのバイトオーダーが正しくないと仮定して、値をネットワークバ イトオーダーに設定するための関数を常に実行するようにすればよいのです。この関数は、必要であれば魔法のような変換を行い、エンディアンが異なるマシンにもコードを移植することができます。</p>
<p>よしよし。変換できる数値は、<code>short</code>（2バイト）と <code>long</code>（4バイト）の2種類です。これらの関数は、符号なしのバリエーションでも動作します。例えば、<code>short</code> をホストバイトオーダーからネットワークバイトオーダーに変換したいとします。まず &quot;h&quot; でホスト、その後に &quot;to&quot; をつけます。そして、&quot;n&quot; は &quot;network&quot;、&quot;s&quot; は &quot;short&quot; を表します。h-to-n-s または <code>htons()</code>（読み方: &quot;ホストからネットワークへのショート&quot;）です。</p>
<p>簡単すぎるくらいに...。</p>
<p>&quot;n&quot;、&quot;h&quot;、&quot;s&quot;、&quot;l&quot; の組み合わせは、本当にくだらないものを除いて、すべて使うことができるのです。たとえば、<code>stolh()</code>（&quot;Short to Long Host&quot;）という関数はありません---とにかく、このパーティーでは。しかし、あるのです。</p>
<table><thead><tr><th>関数</th><th>説明</th></tr></thead><tbody>
<tr><td><code>htons()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>s</code>hort</td></tr>
<tr><td><code>htonl()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>l</code>ong</td></tr>
<tr><td><code>ntohs()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>s</code>hort</td></tr>
<tr><td><code>ntohl()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>l</code>ong</td></tr>
</tbody></table>
<p>基本的には、送出する前にネットワークバイトオーダーに変換し、送出後にホストバイトオーダーに変換します。</p>
<p>64bit のバリエーションは知らないです、すみません。また、浮動小数点をやりたい場合は、ずっと下の<a href="ip-addresses-structs-and-data-munging/../slightly-advanced-techniques/serialization-how-to-pack-data.html">シリアライゼーション</a>の章をチェックしてください。</p>
<p>この文書では、特に断らない限り、数値はホストバイトオーダーであると仮定しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-構造体"><a class="header" href="#33-構造体">3.3 構造体</a></h1>
<p>さて、ついにここまで来ました。そろそろプログラミングの話をしましょう。この章では、ソケットインターフェイスで使用される様々なデータ型について説明します。</p>
<p>まず、簡単なものからです。ソケット記述子です。ソケット記述子は以下のような型です。</p>
<pre><code class="language-c">int
</code></pre>
<p>普通の <code>int</code> です。</p>
<p>ここからは変な話なので、我慢して読んでください。</p>
<p>My First Struct™---<code>struct addrinfo</code>。この構造体は最近開発されたもので、ソケットアドレス構造体を後で使用するために準備するために使用されます。また、ホスト名のルックアップやサービス名のルックアップにも使用されます。これは、後で実際の使い方を説明するときに、より意味をなすと思いますが、今は、接続を行うときに最初に呼び出されるものの1つであることを知っておいてください。</p>
<pre><code class="language-c">struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for &quot;any&quot;
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
};
</code></pre>
<p>この構造体を少し読み込んでから、<code>getaddrinfo()</code> を呼び出します。この構造体のリンクリストへのポインタが返され、必要なものがすべて満たされます。</p>
<p><code>ai_family</code> フィールドで IPv4 か IPv6 を使うように強制することもできますし、<code>AF_UNSPEC</code> のままにして何でも使えるようにすることも可能です。これは、あなたのコードが IP バージョンに依存しないので、クールです。</p>
<p>これはリンクされたリストであることに注意してください：<code>ai_next</code> は次の要素を指しています---そこから選択するためにいくつかの結果があるかもしれません。私は最初にうまくいった結果を使いますが、あなたは異なるビジネスニーズを持っているかもしれません。何でもかんでも知ってるわけじゃないんです！</p>
<p><code>struct addrinfo</code> の <code>ai_addr</code> フィールドは <code>struct sockaddr</code> へのポインタであることがわかります。ここからが、IP アドレス構造体の中身についての細かい話になります。</p>
<p>通常、これらの構造体に書き込む必要はありません。多くの場合、<code>addrinfo</code> 構造体を埋めるために <code>getaddrinfo()</code> を呼び出すだけでよいでしょう。しかし、これらの構造体の内部を覗いて値を取得する必要があるため、ここでそれらを紹介します。</p>
<p>（また、構造体 <code>addrinfo</code> が発明される前に書かれたコードはすべて、これらのものをすべて手作業で梱包していたので、まさにそのような IPv4 コードを多く見かけることができます。このガイドの古いバージョンなどでもそうです。）</p>
<p>ある構造体は IPv4 で、ある構造体は IPv6 で、ある構造体はその両方です。どれが何なのか、メモしておきます。</p>
<p>とにかく、構造体 <code>sockaddr</code> は、多くの種類のソケットのためのソケットアドレス情報を保持します。</p>
<pre><code class="language-c">struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
};
</code></pre>
<p><code>sa_family</code> には様々なものを指定できますが、この文書ではすべて <code>AF_INET</code>（IPv4）または <code>AF_INET6</code>（IPv6）とします。<code>sa_data</code> にはソケットの宛先アドレスとポート番号を指定します。<code>sa_data</code> にアドレスを手で詰め込むのは面倒なので、これはかなり扱いにくいです。</p>
<p>構造体 <code>sockaddr</code> を扱うために、プログラマは IPv4 で使用する構造体 <code>sockaddr_in</code>（&quot;in&quot; は &quot;Internet&quot; の意）を並列に作成しました。</p>
<p><code>sockaddr_in</code> 構造体へのポインタは <code>sockaddr</code> 構造体へのポインタにキャストすることができ、その逆も可能です。つまり、<code>connect()</code> が <code>struct sockaddr*</code> を要求しても、<code>struct sockaddr_in</code> を使用して、最後の最後でキャストすることができるのです！</p>
<pre><code class="language-c">// (IPv4 only--see struct sockaddr_in6 for IPv6)

struct sockaddr_in {
    short int          sin_family;  // Address family, AF_INET
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
};
</code></pre>
<p>この構造体により、ソケットアドレスの要素を簡単に参照することができます。<code>sin_zero</code>（構造体を <code>struct sockaddr</code> の長さに合わせるために含まれます）は、関数 <code>memset()</code> ですべて <code>0</code> に設定する必要があることに注意してください。また、<code>sin_family</code> は <code>struct sockaddr</code> の <code>sa_family</code> に相当し、&quot;<code>AF_INET</code>&quot; に設定されることに注意します。最後に、<code>sin_port</code> はネットワークバイトオーダーでなければなりません（<code>htons()</code> を使用することで！）。</p>
<p>もっと掘り下げましょう！<code>sin_addr</code> フィールドは <code>in_addr</code> 構造体であることがわかりますね。あれは何なんだ？まあ、大げさではなく、史上最も恐ろしい組合せの1つです。</p>
<pre><code class="language-c">// (IPv4 only--see struct in6_addr for IPv6)

// Internet address (a structure for historical reasons)
struct in_addr {
    uint32_t s_addr; // that's a 32-bit int (4 bytes)
};
</code></pre>
<p>うおぉ まあ、昔はユニオンだったんだけど、今はもうそういう時代じゃないみたいだね。おつかれさまでした。つまり、<code>ina</code> を <code>struct sockaddr_in</code> 型と宣言した場合、<code>ina.sin_addr.s_addr</code> は4バイトの IP アドレス（ネットワークバイトオーダー）を参照することになります。あなたのシステムがまだ <code>struct in_addr</code> のための神々しいユニオンを使用している場合でも、あなたはまだ私が上記のように全く同じ方法で4バイトの IP アドレスを参照することができます（これは <code>#defines</code> によるものです）ことに注意してください。</p>
<p>IPv6 ではどうでしょうか。これについても同様の構造体が存在します。</p>
<pre><code class="language-c">// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)

struct sockaddr_in6 {
    u_int16_t       sin6_family;   // address family, AF_INET6
    u_int16_t       sin6_port;     // port number, Network Byte Order
    u_int32_t       sin6_flowinfo; // IPv6 flow information
    struct in6_addr sin6_addr;     // IPv6 address
    u_int32_t       sin6_scope_id; // Scope ID
};

struct in6_addr {
    unsigned char   s6_addr[16];   // IPv6 address
};
</code></pre>
<p>IPv4 が IPv4 アドレスとポート番号を持つように、IPv6 も IPv6 アドレスとポート番号を持つことに注意してください。</p>
<p>また、IPv6 フロー情報やスコープ ID のフィールドについては、今のところ触れないことに注意してください。<code>:-)</code></p>
<p>最後になりますが、こちらもシンプルな構造体である <code>struct sockaddr_storage</code> は、IPv4 と IPv6 の両方の構造体を保持できるように十分な大きさに設計されています。コールによっては、<code>struct sockaddr</code> に IPv4 と IPv6 のどちらのアドレスが記入されるのか事前にわからないことがありますよね。そこで、この並列構造体を渡しますが、サイズが大きい以外は <code>struct sockaddr</code> とよく似ており、必要な型にキャストします。</p>
<pre><code class="language-c">struct sockaddr_storage {
    sa_family_t  ss_family;     // address family

    // all this is padding, implementation specific, ignore it:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};
</code></pre>
<p>重要なのは、<code>ss_family</code> フィールドでアドレスファミリーを確認できることで、これが <code>AF_INET</code> か <code>AF_INET6</code>（IPv4 か IPv6 か）かを確認することです。それから、必要なら <code>struct sockaddr_in</code> や <code>struct sockaddr_in6</code> にキャストすることができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-ip-アドレスパート2"><a class="header" href="#34-ip-アドレスパート2">3.4 IP アドレス、パート2</a></h1>
<p>幸いなことに、IP アドレスを操作するための関数がたくさんあります。手書きで把握して <code>&lt;&lt;</code> 演算子で <code>long</code> に詰め込む必要はありません。</p>
<p>まず、<code>struct sockaddr_in ina</code> があり、そこに格納したい IP アドレスが <code>10.12.110.57</code> または <code>2001:db8:63b3:1::3490</code> だとしましょう。<code>inet_pton()</code> という関数は、数字とドットで表記された IP アドレスを、<code>AF_INET</code> か <code>AF_INET6</code> の指定によって、<code>struct in_addr</code> か <code>sturct in6_addr</code> に変換する関数です。（&quot;<code>pton</code>&quot; は &quot;presentation to network&quot; の略で、覚えやすければ &quot;printable to network&quot; と呼んでも構いません。）変換は次のように行うことができます。</p>
<pre><code class="language-c">struct sockaddr_in sa; // IPv4
struct sockaddr_in6 sa6; // IPv6

inet_pton(AF_INET, &quot;10.12.110.57&quot;, &amp;(sa.sin_addr)); // IPv4
inet_pton(AF_INET6, &quot;2001:db8:63b3:1::3490&quot;, &amp;(sa6.sin6_addr)); // IPv6
</code></pre>
<p>（クイックメモ：古い方法では、<code>inet_addr()</code> という関数や <code>inet_aton()</code> という別の関数を使っていましたが、これらはもう時代遅れで IPv6 では動きません。）</p>
<p>さて、上記のコードスニペットは、エラーチェックがないため、あまり堅牢ではありません。<code>inet_pton()</code> はエラー時に <code>-1</code> を返し、アドレスがめちゃくちゃになった場合は <code>0</code> を返します。ですから、使用する前に結果が <code>0</code> よりも大きいことを確認してください！</p>
<p>さて、これで文字列の IP アドレスをバイナリ表現に変換することができるようになりました。では、その逆はどうでしょうか？<code>in_addr</code> 構造体を持っていて、それを数字とドットの表記で印刷したい場合はどうでしょうか。この場合、関数 <code>inet_ntop()</code>（&quot;<code>ntop</code>&quot; は &quot;network to presentation&quot; という意味です。覚えやすければ &quot;network to printable&quot; と呼んでも構いません）を次のように使用します。</p>
<pre><code class="language-c">// IPv4:

char ip4[INET_ADDRSTRLEN];  // space to hold the IPv4 string
struct sockaddr_in sa;      // pretend this is loaded with something

inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);

printf(&quot;The IPv4 address is: %s\n&quot;, ip4);


// IPv6:

char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string
struct sockaddr_in6 sa6;    // pretend this is loaded with something

inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);

printf(&quot;The address is: %s\n&quot;, ip6);
</code></pre>
<p>呼び出す際には、アドレスの種類（IPv4 または IPv6）、アドレス、結果を格納する文字列へのポインタ、その文字列の最大長を渡すことになります。（2つのマクロは、最大の IPv4 または IPv6 アドレスを保持するために必要な文字列のサイズを都合よく保持します。<code>INET_ADDRSTRLEN</code> と <code>INET6_ADDRSTRLEN</code> です。）</p>
<p>（古いやり方についてもう一度簡単に触れておくと、この変換を行う歴史的な関数は <code>inet_ntoa()</code> と呼ばれるものでした。これも時代遅れで、IPv6 では動きません。）</p>
<p>最後に、これらの関数は数値の IP アドレスに対してのみ動作します。&quot;<code>www.example.com</code>&quot; のようなホスト名に対してネームサーバの DNS ルックアップは行いません。後ほど説明するように、そのためには <code>getaddrinfo()</code> を使用します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="341-プライベートまたはディスコネクトネットワーク"><a class="header" href="#341-プライベートまたはディスコネクトネットワーク">3.4.1 プライベート（またはディスコネクト）ネットワーク</a></h1>
<p>多くの場所では、自分たちを守るために、ネットワークを他の地域から隠すファイアウォールがあります。そして多くの場合、ファイアウォールは、ネットワークアドレス変換（NAT）と呼ばれるプロセスを使って、&quot;内部&quot; IP アドレスを &quot;外部&quot;（世界中の誰もが知っている）IP アドレスに変換しています。</p>
<p>もう緊張してきましたか？ &quot;こんな変なことしてどこへ行くんだろう？&quot;</p>
<p>まあ、ノンアルコール飲料でも買ってリラックスしてください。初心者の場合、NAT は透過的に行われるので、心配する必要もありませんから。しかし、あなたが見ているネットワーク番号に混乱し始めた場合に備えて、ファイアウォールの背後にあるネットワークについて話したいと思います。</p>
<p>例えば、私の自宅にはファイアウォールがあります。DSL 会社から割り当てられた2つの固定 IPv4 アドレスを持っていますが、ネットワーク上に7台のコンピューターがあります。どうしてこんなことが可能なのでしょうか？2台のコンピュータが同じ IP アドレスを共有することはできませんし、そうでなければデータはどちらに行けばいいのかわからなくなってしまいます。</p>
<p>答えは、&quot;同じ IP アドレスを共有していない&quot; です。2400万個の IP アドレスが割り当てられたプライベートネットワーク上にあるのです。それらはすべて私のためだけのものです。まあ、他の人たちから見れば、すべて私のためのものなのですが。ここで、何が起こっているのかを説明します。</p>
<p>リモートコンピューターにログインすると、ISP から提供されたパブリック IP アドレスである <code>192.0.2.33</code> からログインしていると表示されるのです。しかし、ローカルコンピューターにその IP アドレスを尋ねると、<code>10.0.0.5</code> と答えるのです。誰が IP アドレスを変換しているのでしょうか？そうです、ファイアウォールです。ファイアウォールが NAT しているのです。</p>
<p><code>10.x.x.x</code> は、完全に切断されたネットワークか、ファイアウォールの内側にあるネットワークでのみ使用される、数少ない予約ネットワークの1つです。どのプライベート・ネットワーク番号が使用できるかの詳細は、<a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a> に概説されていますが、一般的によく目にするのは、<code>10.x.x.x</code> と <code>192.168.x.x</code> で、<code>x</code> は通常 0 ～ 255 です。一般的ではないのは、<code>172.y.x.x</code> で、<code>y</code> は16から31の間です。</p>
<p>NAT するファイアウォールの内側のネットワークは、これらの予約されたネットワークのいずれかにある必要はありませんが、一般的にはそうなっています。</p>
<p>（楽しい事実！私の外部 IP アドレスは、本当は <code>192.0.2.33</code> ではないのです。<code>192.0.2.x</code> ネットワークは、このガイドのように、ドキュメントで使用するための架空の &quot;本当の&quot; IP アドレスのために予約されているのです！わーい、すごい！）</p>
<p>IPv6 にも、ある意味プライベートネットワークがあります。<a href="https://datatracker.ietf.org/doc/html/rfc4193">RFC 4193</a> にあるように、<code>fdXX:</code>（将来的には <code>fcXX:</code>）で始まります。しかし、NAT と IPv6 は一般的に混ざりません（このドキュメントの範囲外である IPv6 から IPv4 へのゲートウェイを行う場合を除きます）。理論的には、自由に使えるアドレスが非常に多くなるため、NAT を使用する必要はなくなるはずです。しかし、外部にルーティングしないネットワーク上で自分のためにアドレスを割り当てたい場合は、このようにします。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-ipv4-から-ipv6-へのジャンプ"><a class="header" href="#4-ipv4-から-ipv6-へのジャンプ">4 IPv4 から IPv6 へのジャンプ</a></h1>
<p>しかし、IPv6 で動作させるためには、私のコードのどこを変えればいいのか知りたいのです！今すぐ教えてください！</p>
<p>Ok! Ok!</p>
<p>ここに書かれていることはほとんどすべて、私が上で説明したことですが、せっかちな人のためのショートバージョンです。（もちろん、これ以外にもありますが、このガイドに該当するのはこれです。）</p>
<ol>
<li>
<p>まず、構造体を手動で詰めるのではなく、<a href="jumping-from-ipv4-to-ipv6/../ip-addresses-structs-and-data-munging/structs.html"><code>getaddrinfo()</code></a> を使ってすべての <code>struct sockaddr</code> の情報を取得するようにしてください。こうすることで、IP のバージョンに左右されず、また、その後の多くのステップを省くことができます。</p>
</li>
<li>
<p>IP バージョンに関連する何かをハードコーディングしていることが分かったら、ヘルパー関数でラップするようにします。</p>
</li>
<li>
<p><code>AF_INET</code> を <code>AF_INET6</code> に変更します。</p>
</li>
<li>
<p><code>PF_INET</code> を <code>PF_INET6</code> に変更します。</p>
</li>
<li>
<p><code>INADDR_ANY</code> の割り当てを <code>in6addr_any</code> の割り当てに変更し、若干の差異が生じます。</p>
<pre><code class="language-c">struct sockaddr_in sa;
struct sockaddr_in6 sa6;

sa.sin_addr.s_addr = INADDR_ANY;  // use my IPv4 address
sa6.sin6_addr = in6addr_any; // use my IPv6 address
</code></pre>
<p>また、<code>IN6ADDR_ANY_INIT</code> という値は、<code>struct in6_addr</code> を宣言する際にイニシャライザーとして以下のように使用することができます。</p>
<pre><code class="language-c">struct in6_addr ia6 = IN6ADDR_ANY_INIT;
</code></pre>
</li>
<li>
<p><code>struct sockaddr_in</code> の代わりに <code>struct sockaddr_in6</code> を使用し、必要に応じてフィールドに &quot;6&quot; を追加してください（上記の <a href="jumping-from-ipv4-to-ipv6/../ip-addresses-structs-and-data-munging/structs.html">構造体の章</a>を参照）。<code>sin6_zero</code> フィールドはありません。</p>
</li>
<li>
<p><code>struct in_addr</code> の代わりに <code>struct in6_addr</code> を使用し、必要に応じてフィールドに &quot;6&quot; を追加してください（上記の <a href="jumping-from-ipv4-to-ipv6/../ip-addresses-structs-and-data-munging/structs.html">構造体の章</a>を参照）。</p>
</li>
<li>
<p><code>inet_aton()</code> や <code>inet_addr()</code> の代わりに、<code>inet_apton()</code> を使用してください。</p>
</li>
<li>
<p><code>inet_ntoa()</code> の代わりに <code>inet_ntop()</code> を使用してください。</p>
</li>
<li>
<p><code>gethostbyname()</code> の代わりに、優れた <code>getaddrinfo()</code> を使用してください。</p>
</li>
<li>
<p><code>gethostbyaddr()</code> の代わりに、優れた <code>getnameinfo()</code> を使用してください（<code>gethostbyaddr()</code> は IPv6 でも動作可能です）。</p>
</li>
<li>
<p><code>INADDR_BROADCAST</code> は動作しなくなりました。代わりに IPv6 マルチキャストを使用してください。</p>
</li>
</ol>
<p>出来上がり！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-システムコールかバスト"><a class="header" href="#5-システムコールかバスト">5 システムコールかバスト</a></h1>
<p>この章では、Unix マシンのネットワーク機能にアクセスするためのシステムコールやその他のライブラリコールに触れることができますし、ソケット API をサポートしているあらゆるマシン（BSD, Windows, Linux, Mac, など）も同様です。これらの関数を呼び出すと、カーネルが引き継ぎ、すべての作業を自動で行ってくれます。</p>
<p>このあたりで多くの人がつまづくのは、これらのものをどのような順序で呼び出すかということです。これについては、皆さんもお分かりのように、<code>man</code> ページが役に立ちません。そこで、この恐ろしい状況を改善するために、以下の章のシステムコールを、あなたがプログラムの中で呼び出す必要があるのと全く（おおよそ）同じ順序で並べることにしました。</p>
<p>これに、あちこちにあるサンプルコード、ミルクとクッキー（自分で用意しなければならないのが怖い）、そして生粋のガッツと勇気があれば、ジョン・ポステルの息子のようにインターネット上でデータを発信することができるのです！</p>
<p>（なお、以下の多くのコードでは、簡潔にするため、必要なエラーチェックは行っていません。また、<code>getaddrinfo()</code> の呼び出しが成功し、リンクリストの有効なエントリを返すと仮定することが非常に一般的です。これらの状況はいずれもスタンドアロン・プログラムで適切に対処されているので、それらをモデルとして使用してください。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="51-getaddrinfo---起動の準備をしよう"><a class="header" href="#51-getaddrinfo---起動の準備をしよう">5.1 <code>getaddrinfo()</code>---起動の準備をしよう！</a></h1>
<p>この関数は多くのオプションを持つ真の主力関数ですが、使い方はいたってシンプルです。後で必要な構造体をセットアップするのに役立ちます。</p>
<p>昔は、<code>gethostbyname()</code> という関数を使って DNS のルックアップを行っていました。そして、その情報を <code>sockaddr_in</code> 構造体に手作業でロードし、それを呼び出しに使用するのです。</p>
<p>これは、ありがたいことに、もう必要ありません。（IPv4 と IPv6 の両方で動作するコードを書きたいのであれば、望ましいことではありません！）現代では、DNS やサービス名のルックアップなど、あらゆる種類の良いことをやってくれる <code>getaddrinfo()</code> という関数があり、さらに必要な <code>struct</code> も埋めてくれます！</p>
<p>それでは、ご覧ください！</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *node,     // e.g. &quot;www.example.com&quot; or IP
                const char *service,  // e.g. &quot;http&quot; or port number
                const struct addrinfo *hints,
                struct addrinfo **res);
</code></pre>
<p>この関数に3つの入力パラメータを与えると、結果のリンクリストである <code>res</code> へのポインタが得られます。</p>
<p><code>node</code> パラメータには、接続先のホスト名、または IP アドレスを指定します。</p>
<p>次にパラメータ <code>service</code> ですが、これは &quot;80&quot; のようなポート番号か、&quot;http&quot;, &quot;ftp&quot;, &quot;telnet&quot;, &quot;smtp&quot; などの特定のサービスの名前（<a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">IANAポートリスト</a>や Unix マシンの <code>/etc/services</code> ファイルで見つけることができます）であることができます。</p>
<p>最後に、<code>hints</code> パラメータは、関連情報をすでに記入した <code>struct addrinfo</code> を指します。</p>
<p>以下は、自分のホストの IP アドレス、ポート 3490 をリッスンしたいサーバの場合の呼び出し例です。これは実際にはリスニングやネットワークの設定を行っていないことに注意してください。</p>
<pre><code class="language-c">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

if ((status = getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, &quot;getaddrinfo error: %s\n&quot;, gai_strerror(status));
    exit(1);
}

// servinfo now points to a linked list of 1 or more struct addrinfos

// ... do everything until you don't need servinfo anymore ....

freeaddrinfo(servinfo); // free the linked-list
</code></pre>
<p><code>ai_family</code> を <code>AF_UNSPEC</code> に設定することで、IPv4 や IPv6 を使うかどうかを気にしないことを表明していることに注意してください。もし、どちらか一方だけを使いたい場合は、<code>AF_INET</code> または <code>AF_INET6</code> に設定することができます。</p>
<p>また、<code>AI_PASSIVE</code> フラグがあるのがわかると思いますが、これは <code>getaddrinfo()</code> にローカルホストのアドレスをソケット構造体に割り当てるように指示しています。これは、ハードコードする必要がないのがいいところです。(あるいは、<code>getaddrinfo()</code> の最初のパラメータとして特定のアドレスを入れることもできます。私は現在 <code>NULL</code> を持っています。)</p>
<p>そして、呼び出しを行います。エラー（<code>getaddrinfo()</code> が <code>0</code> 以外を返します）があれば、ご覧のように関数 <code>gai_strerror()</code> を使ってそれを表示することができます。しかし、すべてがうまくいけば、<code>servinfo</code> は <code>struct addrinfos</code> のリンクリストを指し、それぞれのリストには後で使用できる何らかの <code>sturct sockaddr</code> が含まれています！素晴らしい！</p>
<p>最後に、<code>getaddrinfo()</code> が快く割り当ててくれたリンクリストをすべて使い終わったら、<code>freeaddrinfo()</code> を呼び出してすべてを解放することができます（そうすべきです）。</p>
<p>ここでは、クライアントが特定のサーバ、例えば &quot;www.example.net&quot; ポート 3490 に接続したい場合のサンプルコールを紹介します。繰り返しますが、これは実際には接続しませんが、後で使用する構造をセットアップしています。</p>
<pre><code class="language-c">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets

// get ready to connect
status = getaddrinfo(&quot;www.example.net&quot;, &quot;3490&quot;, &amp;hints, &amp;servinfo);

// servinfo now points to a linked list of 1 or more struct addrinfos

// etc.
</code></pre>
<p><code>servinfo</code> は、あらゆるアドレス情報を持つリンクリストだと言い続けています。この情報を披露するために、簡単なデモプログラムを書いてみよう。<a href="https://beej.us/guide/bgnet/examples/showip.c">この短いプログラム</a>は、コマンドラインで指定された任意のホストの IP アドレスを表示します。</p>
<pre><code class="language-c">/*
** showip.c -- show IP addresses for a host given on the command line
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;

int main(int argc, char *argv[])
{
    struct addrinfo hints, *res, *p;
    int status;
    char ipstr[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,&quot;usage: showip hostname\n&quot;);
        return 1;
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // AF_INET or AF_INET6 to force version
    hints.ai_socktype = SOCK_STREAM;

    if ((status = getaddrinfo(argv[1], NULL, &amp;hints, &amp;res)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(status));
        return 2;
    }

    printf(&quot;IP addresses for %s:\n\n&quot;, argv[1]);

    for(p = res; p != NULL; p = p-&gt;ai_next) {
        void *addr;
        char *ipver;

        // get the pointer to the address itself,
        // different fields in IPv4 and IPv6:
        if (p-&gt;ai_family == AF_INET) { // IPv4
            struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-&gt;ai_addr;
            addr = &amp;(ipv4-&gt;sin_addr);
            ipver = &quot;IPv4&quot;;
        } else { // IPv6
            struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-&gt;ai_addr;
            addr = &amp;(ipv6-&gt;sin6_addr);
            ipver = &quot;IPv6&quot;;
        }

        // convert the IP to a string and print it:
        inet_ntop(p-&gt;ai_family, addr, ipstr, sizeof ipstr);
        printf(&quot;  %s: %s\n&quot;, ipver, ipstr);
    }

    freeaddrinfo(res); // free the linked list

    return 0;
}
</code></pre>
<p>ご覧のように、このコードはコマンドラインで渡されたものに対して <code>getaddrinfo()</code> を呼び出し、<code>res</code> が指すリンクリストを埋めて、そのリストを繰り返し表示して何かを出力したりすることができます。</p>
<p>（そこには、IP バージョンによって異なるタイプの <code>struct sockaddrs</code> を掘り下げなければならない、ちょっとした醜さがあります。申し訳ありません。他にいい方法はないかなぁ...）</p>
<p>サンプル走行！みんな大好きスクリーンショット。</p>
<pre><code>$ showip www.example.net
IP addresses for www.example.net:

  IPv4: 192.0.2.88

$ showip ipv6.example.com
IP addresses for ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171
</code></pre>
<p>これで、<code>getaddrinfo()</code> の結果を他のソケット関数に渡して、ついにネットワーク接続を確立することができます。引き続きお読みください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="52-socket---ファイル記述子を取得しよう"><a class="header" href="#52-socket---ファイル記述子を取得しよう">5.2 <code>socket()</code>---ファイル記述子を取得しよう！</a></h1>
<p>もう先延ばしにはできません。<code>socket()</code> システムコールの話をしなければならないのです。以下はその書式です。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
</code></pre>
<p>しかし、これらの引数は何なのでしょうか？これらは、どのようなソケットが欲しいか（IPv4 か IPv6 か、ストリームかデータグラムか、TCP か UDP か）を指定することができます。</p>
<p>以前は、これらの値をハードコードする人がいましたが、今でも絶対にそうすることができます。（ドメインは <code>PF_INET</code> または <code>PF_INET6</code>、タイプは <code>SOCK_STREAM</code> または <code>SOCK_DGRAM</code>、プロトコルは <code>0</code> に設定すると、与えられたタイプに適したプロトコルを選択することができます。あるいは <code>getprotobyname()</code> を呼んで、&quot;tcp&quot; や &quot;udp&quot; などの欲しいプロトコルを調べることもできます。）</p>
<p>（この <code>PF_INET</code> は、<code>struct sockaddr_in</code> の <code>sin_family</code> フィールドを初期化するときに使用できる <code>AF_INET</code> の近縁種です。実際、両者は非常に密接な関係にあり、実際に同じ値を持っているので、多くのプログラマは <code>socket()</code> を呼び出して <code>PF_INET</code> の代わりに <code>AF_INET</code> を第一引数に渡しています。さて、ミルクとクッキーを用意して、お話の時間です。昔々、あるアドレスファミリ（<code>AF_INET</code> の AF）が、プロトコルファミリ（<code>PF_INET</code> の PF）で参照される複数のプロトコルをサポートするかもしれないと考えられたことがあります。しかし、そうはなりませんでした。そして、みんな幸せに暮らした、ザ・エンド。というわけで、最も正しいのは <code>struct sockaddr_in</code> で <code>AF_INET</code> を使い、<code>socket()</code> の呼び出しで <code>PF_INET</code> を使うことです。）</p>
<p>とにかく、もう十分です。本当にやりたいことは、<code>getaddrinfo()</code> の呼び出しの結果の値を使い、以下のように直接 <code>socket()</code> に送り込むことです。</p>
<pre><code class="language-c">int s;
struct addrinfo hints, *res;

// do the lookup
// [pretend we already filled out the &quot;hints&quot; struct]
getaddrinfo(&quot;www.example.com&quot;, &quot;http&quot;, &amp;hints, &amp;res);

// again, you should do error-checking on getaddrinfo(), and walk
// the &quot;res&quot; linked list looking for valid entries instead of just
// assuming the first one is good (like many of these examples do).
// See the section on client/server for real examples.

s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
</code></pre>
<p><code>socket()</code> は単に、後のシステムコールで使用できるソケット記述子を返すか、エラーの場合は <code>-1</code> を返します。グローバル変数 <code>errno</code> にはエラーの値が設定されます（詳細については <a href="system-calls-or-bust/../man-pages/errno.html"><code>errno</code></a> のマニュアルページを参照してください。また、マルチスレッドプログラムで <code>errno</code> を使用する際の簡単な注意も参照してください。）</p>
<p>でも、このソケットは何の役に立つのでしょうか？答えは、これだけでは本当に意味がなく、もっと読み進めてシステムコールを作らないと意味がないのです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="53-bind---私はどのポートにいるのでしょうか"><a class="header" href="#53-bind---私はどのポートにいるのでしょうか">5.3 <code>bind()</code>---私はどのポートにいるのでしょうか？</a></h1>
<p>ソケットを取得したら、そのソケットをローカルマシンのポートに関連付ける必要があるかもしれません。（これは、特定のポートへの接続を <code>listen()</code> する場合によく行われます。多人数参加型ネットワークゲームで &quot;192.168.5.10 ポート 3490 に接続&quot; と指示されたときに行います。）ポート番号はカーネルが受信パケットを特定のプロセスのソケット記述子にマッチさせるために使用されます。もしあなたが <code>connect()</code> を行うだけなら（あなたはクライアントであり、サーバではないので）、これはおそらく不要でしょう。とにかく読んでみてください。</p>
<p><code>bind()</code> システムコールの書式は以下のとおりです。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
</code></pre>
<p><code>sockfd</code> は <code>socket()</code> が返すソケットファイル記述子です。<code>my_addr</code> は自分のアドレスに関する情報、すなわちポートおよび IP アドレスを含む <code>struct sockaddr</code> へのポインタです。</p>
<p>ふぅー。一度に吸収するのはちょっと無理がありますね。ソケットをプログラムが実行されているホスト、ポート 3490 にバインドする例を見てみましょう。</p>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<p><code>AI_PASSIVE</code> フラグを使うことで、プログラムが動作しているホストの IP にバインドするように指示しているのです。もし、特定のローカル IP アドレスにバインドしたい場合は、<code>AI_PASSIVE</code> を削除して、<code>getaddrinfo()</code> の最初の引数に IP アドレスを入れてください。</p>
<p><code>bind()</code> もエラー時には <code>-1</code> を返し、<code>errno</code> にエラーの値を設定します。</p>
<p>多くの古いコードでは、<code>bind()</code> を呼び出す前に、<code>struct sockaddr_in</code> を手動でパックしています。これは明らかに IPv4 特有のものですが、IPv6 で同じことをするのを止めるものは何もありません。ただし、一般的には <code>getaddrinfo()</code> を使う方が簡単になりそうです。とにかく、古いコードは次のようなものです。</p>
<pre><code class="language-c">// !!! THIS IS THE OLD WAY !!!

int sockfd;
struct sockaddr_in my_addr;

sockfd = socket(PF_INET, SOCK_STREAM, 0);

my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(MYPORT);     // short, network byte order
my_addr.sin_addr.s_addr = inet_addr(&quot;10.12.110.57&quot;);
memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);

bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof my_addr);
</code></pre>
<p>上記のコードでは、ローカルの IP アドレスにバインドしたい場合、<code>s_addr</code> フィールドに <code>INADDR_ANY</code> を代入することもできます（上記の <code>AI_PASSIVE</code> フラグのようなものです）。<code>INADDR_ANY</code> の IPv6 バージョンはグローバル変数 <code>in6addr_any</code> で、<code>struct sockaddr_in6</code> の <code>sin6_addr</code> フィールドに代入されます。（変数の初期化で使用できるマクロ <code>IN6ADDR_ANY_INIT</code> も存在します。）また、<code>IN6ADDR_ANY_INIT</code> を使用することで、IPv6 の IP アドレスにバインドできます。</p>
<p><code>bind()</code> を呼ぶときにもうひとつ気をつけなければならないのは、ポート番号で下手を打たないことです。1024 以下のポートはすべて予約済みです（あなたがスーパーユーザでない限り）！それ以上のポート番号は、（他のプログラムによってすでに使われていなければ） 65535 までの任意のポート番号を使用することができます。</p>
<p>時々、サーバを再実行しようとすると、<code>bind()</code> が &quot;Address already in use&quot; と言って失敗することに気がつくかもしれません。これはどういうことでしょう？それは、接続されたソケットの一部がまだカーネル内に残っていて、ポートを占有しているのです。それが消えるのを待つか（1分くらい）、次のようにポートが再利用できるようなコードをプログラムに追加します。</p>
<pre><code class="language-c">int yes=1;
//char yes='1'; // Solaris people use this

// lose the pesky &quot;Address already in use&quot; error message
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof yes) == -1) {
    perror(&quot;setsockopt&quot;);
    exit(1);
}
</code></pre>
<p><code>bind()</code> について、最後にちょっとした注意点があります。<code>bind()</code> を絶対に呼び出す必要がない場合があります。リモートマシンに <code>connect()</code> する際に、ローカルポートを気にしない場合（telnet のようにリモートポートだけを気にする場合）は、単に <code>connect()</code> をコールすれば、ソケットが未 bind かどうかをチェックし、必要なら未使用のローカルポートに <code>bind()</code> してくれます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="54-connect---やあこんにちは"><a class="header" href="#54-connect---やあこんにちは">5.4 <code>connect()</code>---やあ、こんにちは！</a></h1>
<p>ちょっとだけ、あなたが telnet アプリケーションであることを仮定してみましょう。ユーザが（映画 TRON のように）ソケットファイル記述子を取得するように命令します。あなたはそれに応じ、<code>socket()</code> を呼び出します。次に、ユーザはポート &quot;<code>23</code>&quot;（標準的な telnet ポート）で &quot;<code>10.12.110.57</code>&quot; に接続するように指示します。やったー！どうするんだ？</p>
<p>幸運なことに、あなたは今、<code>connect()</code> の章---リモートホストに接続する方法を読んでいるところです。だから、猛烈に読み進めましょう！時間がない！</p>
<p><code>connect()</code> の書式は以下の通りです。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
</code></pre>
<p><code>sockfd</code> は <code>socket()</code> コールで返される、我々の身近なソケットファイル記述子、<code>serv_addr</code> は宛先ポートと IP アドレスを含む <code>struct sockaddr</code>、<code>addrlen</code> はサーバアドレス構造体のバイト長です。</p>
<p>これらの情報はすべて、<code>getaddrinfo()</code> の呼び出しの結果から得ることができ、これはロックします。</p>
<p>だんだん分かってきたかな？ここからは聞こえないので、そうであることを祈るしかないですね。ポート <code>3490</code> の &quot;<code>www.example.com</code>&quot; にソケット接続する例を見てみましょう。</p>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo(&quot;www.example.com&quot;, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// connect!

connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<p>繰り返しになりますが、古いタイプのプログラムでは、独自の <code>struct sockaddr_ins</code> を作成して <code>connect()</code> に渡していました。必要であれば、そうすることができます。上の <a href="system-calls-or-bust/..//system-calls-or-bust/bind-what-port-am-i-on.html"><code>bind()</code>の章</a> で同様のことを書いています。</p>
<p><code>connect()</code> の戻り値を必ず確認してください。エラー時に <code>-1</code> が返され、<code>errno</code> という変数がセットされます。</p>
<p>また、<code>bind()</code> を呼んでいないことに注意してください。基本的に、私たちはローカルのポート番号には関心がありません。カーネルは私たちのためにローカルポートを選択し、接続先のサイトは自動的にこの情報を取得します。心配はいりません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="55-listen---誰かコールしてくれない"><a class="header" href="#55-listen---誰かコールしてくれない">5.5 <code>listen()</code>---誰かコールしてくれない？</a></h1>
<p>よし、気分転換の時間です。リモートホストに接続したくない場合はどうすればいいのでしょう。例えば、接続が来るのを待ち、何らかの方法でそれを処理したいとします。この処理は2段階です。まず <code>listen()</code> を行い、次に <code>accept()</code> を行います（後述）。</p>
<p><code>listen()</code> の書式はかなり単純ですが、少し説明が必要です。</p>
<pre><code class="language-c">int listen(int sockfd, int backlog);
</code></pre>
<p><code>sockfd</code> は <code>socket()</code> システムコールから得られる通常のソケットファイル記述子です。<code>backlog</code> は、受信キューで許可される接続の数です。これはどういう意味でしょうか？着信した接続は、<code>accept()</code>（後述）するまでこのキューで待機することになりますが、このキューに入れることができる数の上限を表しているのです。ほとんどのシステムでは、この数を黙って約 20 に制限しています。おそらく、<code>5</code> や <code>10</code> に設定しても大丈夫でしょう。</p>
<p>ここでも、いつものように <code>listen()</code> はエラー時に <code>-1</code> を返し、<code>errno</code> をセットします。</p>
<p>さて、想像がつくと思いますが、サーバが特定のポートで動作するように <code>listen()</code> を呼び出す前に <code>bind()</code> を呼び出す必要があります。（どのポートに接続するかを仲間に伝えることができなければなりません！）ですから、もし接続を待ち受けるのであれば、一連のシステムコールは次のようになります。</p>
<pre><code class="language-c">getaddrinfo();
socket();
bind();
listen();
/* accept() goes here */
</code></pre>
<p>かなり自明なので、サンプルコードの代わりに置いておきます。（以下の <a href="system-calls-or-bust/./accept-thank-you-for-calling-port-3490.html"><code>accept()</code> の章</a>のコードはより完全なものです。）この全体の中で本当に厄介なのは、<code>accept()</code> の呼び出しです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="56-accept---3490番ポートにコールいただきありがとうございます"><a class="header" href="#56-accept---3490番ポートにコールいただきありがとうございます">5.6 <code>accept()</code>---&quot;3490番ポートにコールいただきありがとうございます。&quot;</a></h1>
<p><code>accept()</code> の呼び出しはちょっと変です。これから起こることはこうです。遠く離れた誰かが、あなたが <code>listen()</code> しているポートであなたのマシンに <code>connect()</code> しようとするでしょう。その接続は、<code>accept()</code> されるのを待つためにキューに入れられることになります。あなたは <code>accept()</code> をコールし、保留中の接続を取得するように指示します。すると、この接続に使用する新しいソケットファイル記述子が返されます！そうです、1つの値段で2つのソケットファイル記述子を手に入れたことになります。元のソケットファイル記述子はまだ新しい接続を待ち続けており、新しく作成されたソケットファイル記述子はようやく <code>send()</code> と <code>recv()</code> を行う準備が整いました。着いたぞ！</p>
<p>書式は以下の通りです。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>
<p><code>sockfd</code> は <code>listen()</code> するソケット記述子です。簡単ですね。<code>addr</code> は通常、ローカルの <code>struct sockaddr_storage</code> へのポインタになります。この構造体には、着信接続に関する情報が格納されます（これにより、どのホストがどのポートからコールをかけてきたかを判断することができます）。<code>addrlen</code> はローカルの整数型変数で、そのアドレスが <code>accept()</code> に渡される前に <code>sizeof(struct sockaddr_storage)</code> に設定されなければなりません。<code>accept()</code> は、<code>addr</code> に <code>addrlen</code> 以上のバイト数を入れることはありません。もし、それ以下のバイト数であれば、それを反映するように <code>addrlen</code> の値を変更します。</p>
<p>何だと思いますか？<code>accept()</code> はエラーが発生した場合は <code>-1</code> を返し、<code>errno</code> をセットします。そうだったんですか。</p>
<p>前回と同様、一度に吸収するのは大変なので、サンプルコードの一部をご覧ください。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

#define MYPORT &quot;3490&quot;  // the port users will be connecting to
#define BACKLOG 10     // how many pending connections queue will hold

int main(void)
{
    struct sockaddr_storage their_addr;
    socklen_t addr_size;
    struct addrinfo hints, *res;
    int sockfd, new_fd;

    // !! don't forget your error checking for these calls !!

    // first, load up address structs with getaddrinfo():

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

    getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

    // make a socket, bind it, and listen on it:

    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
    listen(sockfd, BACKLOG);

    // now accept an incoming connection:

    addr_size = sizeof their_addr;
    new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

    // ready to communicate on socket descriptor new_fd!
    .
    .
    .
</code></pre>
<p>ここでも、すべての <code>send()</code> と <code>recv()</code> の呼び出しに、ソケット記述子 <code>new_fd</code> を使用することに注意してください。もし、一度しか接続がないのであれば、同じポートからの接続を防ぐために、<code>listen</code> している <code>sockfd</code> を <code>close()</code> することができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="57-send-と-recv---話せよベイビー"><a class="header" href="#57-send-と-recv---話せよベイビー">5.7 <code>send()</code> と <code>recv()</code>---話せよ、ベイビー！</a></h1>
<p>この2つの関数は、ストリームソケットまたは接続されたデータグラムソケットで通信を行うためのものです。通常の非接続型データグラムソケットを使いたい場合は、以下の <a href="system-calls-or-bust/./sendto-and-recvfrom-talk-to-me-GDRAM-style.html"><code>sendto()</code> と <code>recvfrom()</code> の章</a>を参照する必要があります。</p>
<p><code>send()</code> の書式。</p>
<pre><code class="language-c">int send(int sockfd, const void *msg, int len, int flags);
</code></pre>
<p><code>sockfd</code> はデータを送信したいソケット記述子（<code>socket()</code> で返されたものでも <code>accept()</code> で取得したものでも可）、<code>msg</code> は送信したいデータへのポインタ、<code>len</code> はそのデータの長さ（バイト数）です。<code>flags</code> を <code>0</code> に設定するだけです（フラグに関する詳しい情報は <a href="system-calls-or-bust/../man-pages/send-sendto.html"><code>send()</code> の man ページ</a>を参照してください）。</p>
<p>サンプルコードとしては、以下のようなものがあります。</p>
<pre><code class="language-c">char *msg = &quot;Beej was here!&quot;;
int len, bytes_sent;
.
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
.
</code></pre>
<p><code>send()</code> は実際に送信されたバイト数を返しますが、これは送信するように指示した数よりも少ないかもしれません！つまり、大量のデータを送信するように指示しても、それが処理しきれないことがあるのです。その場合、できる限りのデータを送信し、残りは後で送信するように指示します。<code>send()</code> が返す値が <code>len</code> の値と一致しない場合、残りの文字列を送信するかどうかはあなた次第だということを覚えておいてください。良いニュースはこれです。パケットが小さければ（1K以下とか）、おそらく全部を一度に送信することができるでしょう。ここでも、エラー時には <code>-1</code> が返され、 <code>errno</code> にはエラー番号がセットされます。</p>
<p><code>recv()</code> の書式は、多くの点で類似しています。</p>
<pre><code class="language-c">int recv(int sockfd, void *buf, int len, int flags);
</code></pre>
<p><code>sockfd</code> は読み込むソケット記述子、<code>buf</code> は情報を読み込むバッファ、<code>len</code> はバッファの最大長、<code>flags</code> は再び <code>0</code> に設定できます（フラグについては <a href="system-calls-or-bust/../man-pages/recv-recvfrom.html"><code>recv()</code> の man ページ</a>を参照してください）。</p>
<p><code>recv()</code> は、実際にバッファに読み込まれたバイト数を返し、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<p>待ってください！<code>recv()</code> は <code>0</code> を返すことがあります。これは、リモート側が接続を切断したことを意味します！<code>0</code> という返り値は、<code>recv()</code> がこのような事態が発生したことをあなたに知らせるためのものです。</p>
<p>ほら、簡単だったでしょう？これでストリームソケットでデータのやり取りができるようになったぞ。やったー！あなたは Unix ネットワークプログラマーです！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="58-sendto-と-recvfrom---dgram-スタイルで話して"><a class="header" href="#58-sendto-と-recvfrom---dgram-スタイルで話して">5.8 <code>sendto()</code> と <code>recvfrom()</code>---DGRAM スタイルで話して。</a></h1>
<p>&quot;これはすべて素晴らしく、ダンディーです&quot;、&quot;しかし、データグラムソケットを接続しないままにしておくのはどうなんだ？&quot;、という声が聞こえてきそうです。大丈夫だ、アミーゴ。ちょうどいいものがありますよ。</p>
<p>データグラムソケットはリモートホストに接続されていないので、パケットを送信する前にどのような情報を与える必要があるか分かりますか？そうです！宛先アドレスです！これがそのスコープです。</p>
<pre><code class="language-c">int sendto(int sockfd, const void *msg, int len, unsigned int flags,
           const struct sockaddr *to, socklen_t tolen);
</code></pre>
<p>見ての通り、この呼び出しは基本的に <code>send()</code> の呼び出しと同じで、他に2つの情報が追加されています。<code>to</code> は <code>struct sockaddr</code> へのポインタで（おそらく直前にキャストした別の <code>struct sockaddr_in</code> や <code>struct sockaddr_in6</code>、<code>struct sockaddr_storage</code> になるでしょう）、送信先の IP アドレスとポートが含まれています。<code>tolen</code> は <code>int</code> 型ですが、単純に <code>sizeof *to</code> または <code>sizeof(struct sockaddr_storage)</code> に設定することができます。</p>
<p>宛先アドレスの構造体を手に入れるには、<code>getaddrinfo()</code> や以下の <code>recvfrom()</code> から取得するか、手で記入することになると思います。</p>
<p><code>send()</code> と同様、<code>sendto()</code> は実際に送信したバイト数 (これも、送信するように指示したバイト数よりも少ないかもしれません！) を返し、エラーの場合は <code>-1</code> を返します。</p>
<p>同様に、<code>recv()</code> と <code>recvfrom()</code> も類似しています。<code>recvfrom()</code> の書式は以下の通りです。</p>
<pre><code class="language-c">int recvfrom(int sockfd, void *buf, int len, unsigned int flags,
             struct sockaddr *from, int *fromlen);
</code></pre>
<p>これも <code>recv()</code> と同様であるが、いくつかのフィールドが追加されています。<code>from</code> はローカルの <code>struct sockaddr_storage</code> へのポインタで、送信元のマシンの IP アドレスとポートが格納されます。<code>fromlen</code> はローカルの <code>int</code> へのポインタであり、<code>sizeof *from</code> または <code>sizeof(struct sockaddr_storage)</code> に初期化する必要があります。この関数が戻ったとき、<code>fromlen</code> は実際に <code>from</code> に格納されたアドレスの長さを含みます。</p>
<p><code>recvfrom()</code> は受信したバイト数を返し、エラーの場合は <code>-1</code> を返します（<code>errno</code> はそれに応じて設定されます）。</p>
<p>そこで質問ですが、なぜソケットの型として <code>struct sockaddr_storage</code> を使うのでしょうか？なぜ、<code>struct sockaddr_in</code> ではないのでしょうか？なぜなら、私たちは IPv4 や IPv6 に縛られたくないからです。そこで、汎用的な構造体である <code>sockaddr_storage</code> を使用するのですが、これはどちらにも十分な大きさであることが分かっています。</p>
<p>（そこで...ここでまた疑問なのですが、なぜ <code>struct sockaddr</code> 自体はどんなアドレスに対しても十分な大きさがないのでしょうか？汎用 <code>struct sockaddr_storage</code> を汎用 <code>struct sockaddr</code> にキャストしているくらいなのに！？余計なことをしたような気がしますね。答えは、十分な大きさがなく、この時点で変更するのは問題がある、ということでしょう。だから新しいのを作ったんだ。）</p>
<p>データグラムソケットを <code>connect()</code> すれば、すべてのトランザクションに <code>send()</code> と <code>recv()</code> を使用できることを覚えておいてください。ソケット自体はデータグラムソケットであり、パケットは UDP を使用しますが、ソケットインターフェイスが自動的に宛先と送信元の情報を追加してくれるのです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="59-close-と-shutdown---私の前から失せな"><a class="header" href="#59-close-と-shutdown---私の前から失せな">5.9 <code>close()</code> と <code>shutdown()</code>---私の前から失せな！</a></h1>
<p>ふぅー、一日中データの送受信（<code>send()</code>ing と <code>recv()</code>ing）をしていて、もう限界です。ソケット記述子の接続を閉じる準備ができました。これは簡単です。通常の Unix ファイル記述子の <code>close()</code> 関数を使えばいいのです。</p>
<pre><code class="language-c">close(sockfd);
</code></pre>
<p>これにより、それ以上のソケットへの読み書きができなくなります。リモート側でソケットの読み書きをしようとすると、エラーが発生します。</p>
<p>ソケットの閉じ方をもう少し制御したい場合は、<code>shutdown()</code> 関数を使用します。この関数では、特定の方向、あるいは両方の通信を遮断することができます（ちょうど <code>close()</code> がそうであるように）。書式：</p>
<pre><code class="language-c">int shutdown(int sockfd, int how);
</code></pre>
<p><code>sockfd</code> はシャットダウンしたいソケットファイル記述子、<code>how</code> は以下のいずれかです。</p>
<table><thead><tr><th style="text-align: center"><code>how</code></th><th>Effect</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>0</code></td><td>それ以上の受信は不可</td></tr>
<tr><td style="text-align: center"><code>1</code></td><td>それ以上の送信は禁止</td></tr>
<tr><td style="text-align: center"><code>2</code></td><td>それ以上の送受信は禁止（<code>close()</code> のように）</td></tr>
</tbody></table>
<p><code>shutdown()</code> は成功すると <code>0</code> を、エラーが発生すると <code>-1</code> を返します（<code>errno</code> は適宜設定されます）。</p>
<p>データグラムソケットが接続されていない状態で <code>shutdown()</code> を使用すると、それ以降の <code>send()</code> および <code>recv()</code> 呼び出しに使用できなくなります（データグラムソケットを <code>connect()</code> した場合、これらを使用できることを忘れないでください）。</p>
<p><code>shutdown()</code> は実際にはファイル記述子を閉じないことに注意することが重要です。ソケット記述子を解放するには、<code>close()</code> を使用する必要があります。</p>
<p>何もないんだけどね。</p>
<p>（ただし、Windows と Winsock を使用している場合は、<code>close()</code> ではなく <code>closesocket()</code> を呼び出すべきであることを忘れないでください。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="510-getpeername---あなたは誰ですか"><a class="header" href="#510-getpeername---あなたは誰ですか">5.10 <code>getpeername()</code>---あなたは誰ですか？</a></h1>
<p>この関数はとても簡単です。</p>
<p>あまりに簡単なので、ほとんど独自の章を設けなかったほどです。でも、とりあえずここに書いておきます。</p>
<p><code>getpeername()</code> 関数は、接続されたストリームソケットのもう一方の端にいるのが誰であるかを教えてくれます。その書式は</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);
</code></pre>
<p><code>sockfd</code> は接続したストリームソケットの記述子、<code>addr</code> は接続の相手側の情報を保持する <code>struct sockaddr</code>（または <code>struct sockaddr_in</code>）へのポインタ、<code>addrlen</code> は <code>int</code> へのポインタであり、 <code>sizeof *addr</code> または <code>sizeof(struct sockaddr)</code> で初期化される必要があります。</p>
<p>この関数は，エラーが発生すると <code>-1</code> を返し，それに応じて <code>errno</code> を設定します。</p>
<p>アドレスがわかれば、<code>inet_ntop()</code>、<code>getnameinfo()</code>、<code>gethostbyaddr()</code> を使って、より詳しい情報を表示したり取得したりすることができます。いいえ、ログイン名を取得することはできません。（OK、OK。相手のコンピュータで ident デーモンが動いていれば、可能です。しかし、これはこのドキュメントの範囲外です。詳しくは <a href="https://datatracker.ietf.org/doc/html/rfc1413">RFC 1413</a> をチェックしてください。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="511-gethostname---私は誰なのか"><a class="header" href="#511-gethostname---私は誰なのか">5.11 <code>gethostname()</code>---私は誰なのか？</a></h1>
<p><code>getpeername()</code> よりもさらに簡単なのは、<code>gethostname()</code> という関数です。これは、あなたのプログラムが動作しているコンピュータの名前を返します。この名前は、後述の <code>gethostbyname()</code> でローカルマシンの IP アドレスを決定するために使用されます。</p>
<p>これ以上楽しいことはないでしょう？いくつか思いつきましたが、ソケットプログラミングには関係ないですね。とにかく、書式はこんな感じです。</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int gethostname(char *hostname, size_t size);
</code></pre>
<p>引数は単純で、<code>hostname</code> はこの関数が戻ったときにホスト名を格納する文字列の配列へのポインタ、<code>size</code> はホスト名配列のバイト長です。</p>
<p>この関数は，正常に終了した場合は <code>0</code> を，エラーの場合は <code>-1</code> を返し，通常通り <code>errno</code> を設定します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-クライアント-サーバの背景"><a class="header" href="#6-クライアント-サーバの背景">6 クライアント-サーバの背景</a></h1>
<p>クライアント-サーバの世界なのです。ネットワーク上のあらゆることが、クライアント・プロセスとサーバ・プロセスとの対話、またはその逆を扱っています。たとえば、<code>telnet</code> を考えてみよう。ポート 23 のリモートホストに <code>telnet</code> で接続すると（クライアント）、そのホスト上のプログラム（telnetd と呼ばれるサーバ）が起動します。このプログラムは、送られてきた <code>telnet</code> 接続を処理し、ログインプロンプトを表示するなどの設定を行います。</p>
<figure>
  <img
  src="images/cs.svg"
  alt="[Client-Server Interaction Diagram]">
  <figcaption>クライアント-サーバの相互作用</figcaption>
</figure>
<p>クライアントとサーバ間の情報のやりとりは、上の図のようにまとめられます。</p>
<p>クライアントとサーバのペアは、<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、その他（同じことを話している限り）何でも話すことができることに注意してください。クライアントとサーバのペアの良い例としては、<code>telnet</code>/<code>telnetd</code>、<code>ftp</code>/<code>ftpd</code>、<code>Firefox</code>/<code>Apache</code> などがあります。<code>ftp</code> を使うときはいつも、リモートプログラム <code>ftpd</code> があなたにサービスを提供します。</p>
<p>多くの場合、1つのマシンには1つのサーバしかなく、そのサーバは <code>fork()</code> を使用して複数のクライアントを処理します。基本的なルーチンは、サーバが接続を待ち、それを <code>accept()</code> し、それを処理するために子プロセスを <code>fork()</code> する、というものです。これが、次の章で紹介するサンプルサーバが行っていることです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="61-シンプルなストリームサーバ"><a class="header" href="#61-シンプルなストリームサーバ">6.1 シンプルなストリームサーバ</a></h1>
<p>このサーバがすることは、ストリーム接続で <code>Hello, world!</code> という文字列を送り出すだけです。このサーバをテストするために必要なことは、あるウィンドウでこのサーバを実行し、別のウィンドウからこのサーバに telnet でアクセスすることだけです。</p>
<pre><code>$ telnet remotehostname 3490
</code></pre>
<p>ここで、<code>remotehostname</code> は実行するマシンの名前です。</p>
<p><a href="https://beej.us/guide/bgnet/examples/server.c">サーバコード</a></p>
<pre><code class="language-c">/*
** server.c -- a stream socket server demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define PORT &quot;3490&quot;  // the port users will be connecting to

#define BACKLOG 10   // how many pending connections queue will hold

void sigchld_handler(int s)
{
    // waitpid() might overwrite errno, so we save and restore it:
    int saved_errno = errno;

    while(waitpid(-1, NULL, WNOHANG) &gt; 0);

    errno = saved_errno;
}


// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct addrinfo hints, *servinfo, *p;
    struct sockaddr_storage their_addr; // connector's address information
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;
    char s[INET6_ADDRSTRLEN];
    int rv;

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
        return 1;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror(&quot;server: socket&quot;);
            continue;
        }

        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                sizeof(int)) == -1) {
            perror(&quot;setsockopt&quot;);
            exit(1);
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror(&quot;server: bind&quot;);
            continue;
        }

        break;
    }

    freeaddrinfo(servinfo); // all done with this structure

    if (p == NULL)  {
        fprintf(stderr, &quot;server: failed to bind\n&quot;);
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror(&quot;listen&quot;);
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
        perror(&quot;sigaction&quot;);
        exit(1);
    }

    printf(&quot;server: waiting for connections...\n&quot;);

    while(1) {  // main accept() loop
        sin_size = sizeof their_addr;
        new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
        if (new_fd == -1) {
            perror(&quot;accept&quot;);
            continue;
        }

        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s);
        printf(&quot;server: got connection from %s\n&quot;, s);

        if (!fork()) { // this is the child process
            close(sockfd); // child doesn't need the listener
            if (send(new_fd, &quot;Hello, world!&quot;, 13, 0) == -1)
                perror(&quot;send&quot;);
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
}
</code></pre>
<p>一応、構文的にわかりやすいように、1つの大きな <code>main()</code> 関数にまとめてあります。もし、その方が良いと思われるなら、自由に小さな関数に分割してください。</p>
<p>（また、この <code>sigaction()</code> 全体は、あなたにとって新しいものかもしれません---それは大丈夫です。このコードは、<code>fork()</code> された子プロセスが終了するときに現れるゾンビプロセスを刈り取る役割を担っているのです。ゾンビをたくさん作ってそれを刈り取らないと、システム管理者が怒りますよ。）</p>
<p>このサーバからデータを取得するには、次の節に記載されているクライアントを使用します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="62-シンプルなストリームクライアント"><a class="header" href="#62-シンプルなストリームクライアント">6.2 シンプルなストリームクライアント</a></h1>
<p>こいつはサーバよりもっと簡単です。このクライアントがすることはコマンドラインで指定したホスト、ポート 3490 に接続するだけです。サーバが送信する文字列を取得します。</p>
<p><a href="https://beej.us/guide/bgnet/examples/client.c">クライアントソース</a>。</p>
<pre><code class="language-c">/*
** client.c -- a stream socket client demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#define PORT &quot;3490&quot; // the port client will be connecting to

#define MAXDATASIZE 100 // max number of bytes we can get at once

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(int argc, char *argv[])
{
    int sockfd, numbytes;
    char buf[MAXDATASIZE];
    struct addrinfo hints, *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,&quot;usage: client hostname\n&quot;);
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(argv[1], PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
        return 1;
    }

    // loop through all the results and connect to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror(&quot;client: socket&quot;);
            continue;
        }

        if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror(&quot;client: connect&quot;);
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, &quot;client: failed to connect\n&quot;);
        return 2;
    }

    inet_ntop(p-&gt;ai_family, get_in_addr((struct sockaddr *)p-&gt;ai_addr),
            s, sizeof s);
    printf(&quot;client: connecting to %s\n&quot;, s);

    freeaddrinfo(servinfo); // all done with this structure

    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror(&quot;recv&quot;);
        exit(1);
    }

    buf[numbytes] = '\0';

    printf(&quot;client: received '%s'\n&quot;,buf);

    close(sockfd);

    return 0;
}
</code></pre>
<p>クライアントを実行する前にサーバを実行しない場合、<code>connect()</code> は &quot;Connection refused&quot; を返すことに注意してください。非常に便利です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="63-データグラムソケット"><a class="header" href="#63-データグラムソケット">6.3 データグラムソケット</a></h1>
<p>UDP データグラムソケットの基本は、上記の <a href="client-server-background/../system-calls-or-bust/sendto-and-recvfrom-talk-to-me-GDRAM-style.html">5.8 sendto() and recvfrom()</a> ですでに説明しましたので、ここでは <code>talker.c</code> と <code>listener.c</code> という2つのサンプルプログラムのみを紹介します。</p>
<p><code>listener</code> は、ポート 4950 で入ってくるパケットを待つマシンに座っています。<code>talker</code> は、指定されたマシンのそのポートに、ユーザがコマンドラインに入力したものを含むパケットを送信します。</p>
<p>データグラムソケットはコネクションレス型であり、パケットを無慈悲に発射するだけなので、クライアントとサーバには IPv6 を使用するように指示することにしています。こうすることで、サーバが IPv6 でリッスンしていて、クライアントが IPv4 で送信するような状況を避けることができます。（接続された TCP ストリームソケットの世界では、まだ不一致があるかもしれませんが、一方のアドレスファミリーの <code>connect()</code> でエラーが発生すると、他方のアドレスファミリーの再試行が行われます。）</p>
<p><a href="https://beej.us/guide/bgnet/examples/listener.c">listener.c ソースコード</a></p>
<pre><code class="language-c">/*
** listener.c -- a datagram sockets &quot;server&quot; demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define MYPORT &quot;4950&quot;	// the port users will be connecting to

#define MAXBUFLEN 100

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
	if (sa-&gt;sa_family == AF_INET) {
		return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
	}

	return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
	int sockfd;
	struct addrinfo hints, *servinfo, *p;
	int rv;
	int numbytes;
	struct sockaddr_storage their_addr;
	char buf[MAXBUFLEN];
	socklen_t addr_len;
	char s[INET6_ADDRSTRLEN];

	memset(&amp;hints, 0, sizeof hints);
	hints.ai_family = AF_INET6; // set to AF_INET to use IPv4
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_PASSIVE; // use my IP

	if ((rv = getaddrinfo(NULL, MYPORT, &amp;hints, &amp;servinfo)) != 0) {
		fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
		return 1;
	}

	// loop through all the results and bind to the first we can
	for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
		if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
				p-&gt;ai_protocol)) == -1) {
			perror(&quot;listener: socket&quot;);
			continue;
		}

		if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
			close(sockfd);
			perror(&quot;listener: bind&quot;);
			continue;
		}

		break;
	}

	if (p == NULL) {
		fprintf(stderr, &quot;listener: failed to bind socket\n&quot;);
		return 2;
	}

	freeaddrinfo(servinfo);

	printf(&quot;listener: waiting to recvfrom...\n&quot;);

	addr_len = sizeof their_addr;
	if ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN-1 , 0,
		(struct sockaddr *)&amp;their_addr, &amp;addr_len)) == -1) {
		perror(&quot;recvfrom&quot;);
		exit(1);
	}

	printf(&quot;listener: got packet from %s\n&quot;,
		inet_ntop(their_addr.ss_family,
			get_in_addr((struct sockaddr *)&amp;their_addr),
			s, sizeof s));
	printf(&quot;listener: packet is %d bytes long\n&quot;, numbytes);
	buf[numbytes] = '\0';
	printf(&quot;listener: packet contains \&quot;%s\&quot;\n&quot;, buf);

	close(sockfd);

	return 0;
}
</code></pre>
<p><code>getaddrinfo()</code> の呼び出しで、最終的に <code>SOCK_DGRAM</code> を使用していることに注意してください。また、<code>listen()</code> や <code>accept()</code> は必要ないことに注意してください。これは非接続型データグラムソケットを使用する利点の1つです！</p>
<p><a href="https://beej.us/guide/bgnet/examples/talker.c">talker.c ソースコード</a></p>
<pre><code class="language-c">/*
** talker.c -- a datagram &quot;client&quot; demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT &quot;4950&quot;	// the port users will be connecting to

int main(int argc, char *argv[])
{
	int sockfd;
	struct addrinfo hints, *servinfo, *p;
	int rv;
	int numbytes;

	if (argc != 3) {
		fprintf(stderr,&quot;usage: talker hostname message\n&quot;);
		exit(1);
	}

	memset(&amp;hints, 0, sizeof hints);
	hints.ai_family = AF_INET6; // set to AF_INET to use IPv4
	hints.ai_socktype = SOCK_DGRAM;

	if ((rv = getaddrinfo(argv[1], SERVERPORT, &amp;hints, &amp;servinfo)) != 0) {
		fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
		return 1;
	}

	// loop through all the results and make a socket
	for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
		if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
				p-&gt;ai_protocol)) == -1) {
			perror(&quot;talker: socket&quot;);
			continue;
		}

		break;
	}

	if (p == NULL) {
		fprintf(stderr, &quot;talker: failed to create socket\n&quot;);
		return 2;
	}

	if ((numbytes = sendto(sockfd, argv[2], strlen(argv[2]), 0,
			 p-&gt;ai_addr, p-&gt;ai_addrlen)) == -1) {
		perror(&quot;talker: sendto&quot;);
		exit(1);
	}

	freeaddrinfo(servinfo);

	printf(&quot;talker: sent %d bytes to %s\n&quot;, numbytes, argv[1]);
	close(sockfd);

	return 0;
}
</code></pre>
<p>と、これだけです！<code>listener</code> をあるマシンで実行し、次に <code>takler</code> を別のマシンで実行します。それらのコミュニケーションをご覧ください！核家族で楽しめる G 級興奮体験です！</p>
<p>今回はサーバを動かす必要もありません。<code>talker</code> はただ楽しくパケットをエーテルに発射し、相手側に <code>recvfrom()</code> の準備が出来ていなければ消えてしまうのです。UDP データグラムソケットを使用して送信されたデータは、到着が保証されていないことを思い出してください！</p>
<p>過去に何度も述べた、もうひとつの小さなディテールを除いては、コネクテッド・データグラム・ソケットです。このドキュメントのデータグラムの章にいるので、ここでこれについて話す必要があります。例えば、<code>talker</code> が <code>connect()</code> を呼び出して <code>listener</code> のアドレスを指定したとします。それ以降、<code>talker</code> は <code>connect()</code> で指定されたアドレスにのみ送信と受信ができます。このため、<code>sendto()</code> と <code>recvfrom()</code> を使う必要はなく、単に <code>send()</code> と <code>recv()</code> を使えばいいのです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-少し高度なテクニック"><a class="header" href="#7-少し高度なテクニック">7 少し高度なテクニック</a></h1>
<p>これらは本当に高度なものではありませんが、私たちがすでにカバーしたより基本的なレベルから抜け出したものです。実際、ここまでくれば、Unix ネットワークプログラミングの基本をかなり習得したと考えてよいでしょう！おめでとうございます！</p>
<p>さて、ここからは、より難解な事柄の勇敢な新世界に突入します。ソケットについて学ぶことができます。どうぞお楽しみに！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="71-ブロッキング"><a class="header" href="#71-ブロッキング">7.1 ブロッキング</a></h1>
<p>ブロッキング。聞いたことがあると思います---さて、一体何でしょう？一言で言えば、&quot;ブロック&quot;は技術用語で&quot;スリープ&quot;のことです。上で <code>listener</code> を実行したとき、パケットが到着するまでただそこに座っていることに気付いたと思います。何が起こったかというと、<code>recvfrom()</code> を呼び出したのですが、データがなかったので、<code>recvfrom()</code> はデータが到着するまで &quot;block&quot;（つまり、そこで眠る）と言われているのです。</p>
<p>多くの関数がブロックします。<code>accept()</code> がブロックします。すべての <code>recv()</code> 関数がブロックします。このようなことができるのは、ブロックすることが許されているからです。最初に <code>socket()</code> でソケット記述子を作成するとき、カーネルはそれをブロッキングに設定します。もし、ソケットをブロッキングさせたくなければ、<code>fcntl()</code> を呼び出す必要があります。</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
.
.
.
sockfd = socket(PF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
.
</code></pre>
<p>ソケットをノンブロッキングに設定することで、効果的にソケットの情報を&quot;ポーリング&quot;することができます。ノンブロッキングソケットから読み込もうとしたときに、そこにデータがない場合、ブロックすることは許されません---その際には <code>-1</code> が返り、<code>errno</code> には <code>EAGAIN</code> または <code>EWOULDBLOCK</code> がセットされます。</p>
<p>（待てよ--<code>EAGAIN</code> や <code>EWOULDBLOCK</code> を返すこともあるのか？どちらをチェックする？仕様では実際にあなたのシステムがどちらを返すかは指定されていないので、移植性のために両方チェックしましょう。）</p>
<p>しかし、一般的に言って、この種のポーリングは悪い考えです。ソケットのデータを探すためにプログラムをビジーウェイト状態にすると、流行遅れのように CPU 時間を吸い取られてしまうからです。読み込み待ちのデータがあるかどうかを確認するための、よりエレガントなソリューションが、次の <a href="slightly-advanced-techniques/./poll-synchronous-io-multiplexing.html"><code>poll()</code></a> の章で紹介されています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="72-poll---同期式-io-多重化"><a class="header" href="#72-poll---同期式-io-多重化">7.2 <code>poll()</code>---同期式 I/O 多重化</a></h1>
<p>本当にやりたいことは、一度にたくさんのソケットを監視して、データの準備ができたものを処理することです。そうすれば、すべてのソケットを継続的にポーリングして、どれが読み込み可能な状態にあるかを確認する必要がなくなります。</p>
<blockquote>
<p>警告：<code>poll()</code> は膨大な数のコネクションを持つ場合、恐ろしく遅くなります。そのような状況では、システムで利用可能な最も高速なメソッドを使用しようとする <a href="https://libevent.org/">libevent</a> のようなイベントライブラリの方が良いパフォーマンスを得ることができるでしょう。</p>
</blockquote>
<p>では、どうすればポーリングを回避できるのでしょうか。少し皮肉なことに、<code>poll()</code> システムコールを使えばポーリングを避けることができます。簡単に言うと、オペレーティングシステムにすべての汚い仕事を代行してもらい、どのソケットでデータが読めるようになったかだけを知らせてもらうのです。その間、我々のプロセスはスリープして、システムリソースを節約することができます。</p>
<p>一般的なゲームプランは、どのソケット記述子を監視したいか、どのような種類のイベントを監視したいかという情報を <code>struct pollfd</code> の配列として保持することです。OS は、これらのイベントのいずれかが発生するか（例えば &quot;socket ready to read!&quot;）またはユーザが指定したタイムアウトが発生するまで <code>poll()</code> 呼び出しでブロックします。</p>
<p>便利なことに、 <code>listen()</code>しているソケットは、新しい接続が <code>accept()</code> される準備ができたときに &quot;ready to read&quot; を返します。</p>
<p>雑談はこのくらいにして。これをどう使うかです？</p>
<pre><code class="language-c">#include &lt;poll.h&gt;

int poll(struct pollfd fds[], nfds_t nfds, int timeout);
</code></pre>
<p><code>fds</code> は情報の配列（どのソケットの何を監視するか）、<code>nfds</code> は配列の要素数、そして <code>timeout</code> はミリ秒単位のタイムアウトです。<code>timeout</code> はミリ秒単位のタイムアウトで、<code>poll</code> はイベントが発生した配列の要素数を返します。</p>
<p><code>struct pollfd</code> を見てみましょう。</p>
<pre><code class="language-c">struct pollfd {
    int fd;         // the socket descriptor
    short events;   // bitmap of events we're interested in
    short revents;  // when poll() returns, bitmap of events that occurred
};
</code></pre>
<p>そして、その配列を用意するんだ。各要素の <code>fd</code> フィールドに、監視したいソケット記述子を指定します。そして、<code>events</code> フィールドには、監視するイベントの種類を指定します。</p>
<p><code>events</code> フィールドは、以下のビット単位の OR です。</p>
<table><thead><tr><th>Macro</th><th>説明</th></tr></thead><tbody>
<tr><td><code>POLLIN</code></td><td>このソケットで <code>recv()</code> のためのデータが準備できたときに警告を出す。</td></tr>
<tr><td><code>POLLOUT</code></td><td>このソケットにブロックせずにデータを <code>send()</code> できるようになったら警告します。</td></tr>
</tbody></table>
<p>一旦 <code>struct pollfd</code> の配列を整えたら、それを <code>poll()</code> に渡すことができます。配列のサイズと、ミリ秒単位のタイムアウト値も一緒に渡してください。（タイムアウトに負の値を指定すると、永遠に待つことができます。）</p>
<p><code>poll()</code> が返った後、<code>revents</code> フィールドをチェックして、<code>POLLIN</code> または <code>POLLOUT</code> がセットされているかどうかを確認し、イベントが発生したことを示すことができます。</p>
<p>（実際には <code>poll()</code> の呼び出しでできることはもっとたくさんあります。詳細は以下の <a href="slightly-advanced-techniques/../man-pages/poll.html"><code>poll()</code> man ページ</a>を参照してください。）</p>
<p>ここでは、標準入力からデータを読み込めるようになるまで、つまり <code>RETURN</code> を押したときに 2.5 秒間待つ<a href="https://beej.us/guide/bgnet/examples/poll.c">例</a>を示します。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;poll.h&gt;

int main(void)
{
    struct pollfd pfds[1]; // More if you want to monitor more

    pfds[0].fd = 0;          // Standard input
    pfds[0].events = POLLIN; // Tell me when ready to read

    // If you needed to monitor other things, as well:
    //pfds[1].fd = some_socket; // Some socket descriptor
    //pfds[1].events = POLLIN;  // Tell me when ready to read

    printf(&quot;Hit RETURN or wait 2.5 seconds for timeout\n&quot;);

    int num_events = poll(pfds, 1, 2500); // 2.5 second timeout

    if (num_events == 0) {
        printf(&quot;Poll timed out!\n&quot;);
    } else {
        int pollin_happened = pfds[0].revents &amp; POLLIN;

        if (pollin_happened) {
            printf(&quot;File descriptor %d is ready to read\n&quot;, pfds[0].fd);
        } else {
            printf(&quot;Unexpected event occurred: %d\n&quot;, pfds[0].revents);
        }
    }

    return 0;
}
</code></pre>
<p><code>poll()</code> が <code>pfds</code> 配列の中でイベントが発生した要素の数を返していることに再度注目してください。これは配列のどの要素かを教えてくれるわけではありませんが（そのためにはまだスキャンしなければなりません）、<code>revents</code> フィールドが <code>0</code> 以外のエントリがいくつあるかを教えてくれます（したがって、その数がわかったらスキャンをやめることができます。）</p>
<p>ここで、いくつかの疑問が出てくるかもしれません。<code>poll()</code> に渡したセットに新しいファイル記述子を追加するにはどうしたらいいのでしょうか？これについては、単に配列に必要なだけのスペースがあることを確認するか、必要に応じて <code>realloc()</code> でスペースを追加してください。</p>
<p>セットから項目を削除する場合はどうすればよいのでしょうか。この場合は、配列の最後の要素をコピーして、削除する要素の上に置くことができます。そして、その数をひとつ減らして <code>poll()</code> に渡します。もうひとつの方法として、<code>fd</code> フィールドに負の数を設定すると、<code>poll()</code> はそれを無視します。</p>
<p>どうすれば、<code>telnet</code> できるチャットサーバにまとめることができるのでしょうか？</p>
<p>これから行うのは、リスナーソケットを起動し、それをファイル記述子のセットに追加して <code>poll()</code> に送ることです。（これは、接続があったときに読み込み可能な状態を表示します。）</p>
<p>そして、新しい接続を <code>struct pollfd</code> 配列に追加していきます。そして、容量が足りなくなったら、動的にそれを増やしていきます。</p>
<p>接続が終了したら、その接続を配列から削除します。</p>
<p>そして、ある接続が読み取り可能になったら、そこからデータを読み取り、そのデータを他のすべての接続に送ることで、他のユーザが入力した内容を見ることができるようにします。</p>
<p>そこで、<a href="https://beej.us/guide/bgnet/examples/pollserver.c">このポール・サーバ</a>を試してみてください。あるウィンドウで実行し、他の多くのターミナルウィンドウから <code>telnet localhost 9034</code> を実行してみてください。一つのウィンドウで入力したものが他のウィンドウでも（RETURNを押した後で）見られるようになるはずです。</p>
<p>それだけでなく、<code>CTRL-]</code> を押して <code>quit</code> とタイプして <code>telnet</code> を終了すると、サーバは切断を検出し、ファイル記述子の配列からあなたを削除するはずです。</p>
<pre><code class="language-c">/*
** pollserver.c -- a cheezy multiperson chat server
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;poll.h&gt;

#define PORT &quot;9034&quot;   // Port we're listening on

// Get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

// Return a listening socket
int get_listener_socket(void)
{
    int listener;     // Listening socket descriptor
    int yes=1;        // For setsockopt() SO_REUSEADDR, below
    int rv;

    struct addrinfo hints, *ai, *p;

    // Get us a socket and bind it
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) {
        fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));
        exit(1);
    }

    for(p = ai; p != NULL; p = p-&gt;ai_next) {
        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        if (listener &lt; 0) {
            continue;
        }

        // Lose the pesky &quot;address already in use&quot; error message
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));

        if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) {
            close(listener);
            continue;
        }

        break;
    }

    freeaddrinfo(ai); // All done with this

    // If we got here, it means we didn't get bound
    if (p == NULL) {
        return -1;
    }

    // Listen
    if (listen(listener, 10) == -1) {
        return -1;
    }

    return listener;
}

// Add a new file descriptor to the set
void add_to_pfds(struct pollfd *pfds[], int newfd, int *fd_count, int *fd_size)
{
    // If we don't have room, add more space in the pfds array
    if (*fd_count == *fd_size) {
        *fd_size *= 2; // Double it

        *pfds = realloc(*pfds, sizeof(**pfds) * (*fd_size));
    }

    (*pfds)[*fd_count].fd = newfd;
    (*pfds)[*fd_count].events = POLLIN; // Check ready-to-read

    (*fd_count)++;
}

// Remove an index from the set
void del_from_pfds(struct pollfd pfds[], int i, int *fd_count)
{
    // Copy the one from the end over this one
    pfds[i] = pfds[*fd_count-1];

    (*fd_count)--;
}

// Main
int main(void)
{
    int listener;     // Listening socket descriptor

    int newfd;        // Newly accept()ed socket descriptor
    struct sockaddr_storage remoteaddr; // Client address
    socklen_t addrlen;

    char buf[256];    // Buffer for client data

    char remoteIP[INET6_ADDRSTRLEN];

    // Start off with room for 5 connections
    // (We'll realloc as necessary)
    int fd_count = 0;
    int fd_size = 5;
    struct pollfd *pfds = malloc(sizeof *pfds * fd_size);

    // Set up and get a listening socket
    listener = get_listener_socket();

    if (listener == -1) {
        fprintf(stderr, &quot;error getting listening socket\n&quot;);
        exit(1);
    }

    // Add the listener to set
    pfds[0].fd = listener;
    pfds[0].events = POLLIN; // Report ready to read on incoming connection

    fd_count = 1; // For the listener

    // Main loop
    for(;;) {
        int poll_count = poll(pfds, fd_count, -1);

        if (poll_count == -1) {
            perror(&quot;poll&quot;);
            exit(1);
        }

        // Run through the existing connections looking for data to read
        for(int i = 0; i &lt; fd_count; i++) {

            // Check if someone's ready to read
            if (pfds[i].revents &amp; POLLIN) { // We got one!!

                if (pfds[i].fd == listener) {
                    // If listener is ready to read, handle new connection

                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&amp;remoteaddr,
                        &amp;addrlen);

                    if (newfd == -1) {
                        perror(&quot;accept&quot;);
                    } else {
                        add_to_pfds(&amp;pfds, newfd, &amp;fd_count, &amp;fd_size);

                        printf(&quot;pollserver: new connection from %s on &quot;
                            &quot;socket %d\n&quot;,
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&amp;remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    // If not the listener, we're just a regular client
                    int nbytes = recv(pfds[i].fd, buf, sizeof buf, 0);

                    int sender_fd = pfds[i].fd;

                    if (nbytes &lt;= 0) {
                        // Got error or connection closed by client
                        if (nbytes == 0) {
                            // Connection closed
                            printf(&quot;pollserver: socket %d hung up\n&quot;, sender_fd);
                        } else {
                            perror(&quot;recv&quot;);
                        }

                        close(pfds[i].fd); // Bye!

                        del_from_pfds(pfds, i, &amp;fd_count);

                    } else {
                        // We got some good data from a client

                        for(int j = 0; j &lt; fd_count; j++) {
                            // Send to everyone!
                            int dest_fd = pfds[j].fd;

                            // Except the listener and ourselves
                            if (dest_fd != listener &amp;&amp; dest_fd != sender_fd) {
                                if (send(dest_fd, buf, nbytes, 0) == -1) {
                                    perror(&quot;send&quot;);
                                }
                            }
                        }
                    }
                } // END handle data from client
            } // END got ready-to-read from poll()
        } // END looping through file descriptors
    } // END for(;;)--and you thought it would never end!

    return 0;
}
</code></pre>
<p>次の章では、似たような古い関数である <code>select()</code> について見ていきます。<code>select()</code> と <code>poll()</code> はどちらも似たような機能とパフォーマンスを持っており、どのように使うかが違うだけです。<code>select()</code> の方が若干移植性が高いかもしれませんが、使い勝手は少し悪いかもしれません。あなたのシステムでサポートされている限り、一番好きなものを選んでください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="73-select---同期式-io-多重化旧式"><a class="header" href="#73-select---同期式-io-多重化旧式">7.3 <code>select()</code>---同期式 I/O 多重化、旧式</a></h1>
<p>この関数、ちょっと不思議なんですが、とても便利なんです。次のような状況を考えてみましょう。あなたはサーバで、入ってくるコネクションをリッスンするだけでなく、すでに持っているコネクションを読み続けたいのです。</p>
<p>問題ありません。<code>accept()</code> と <code>recv()</code> を数回実行するだけです。そうはいかないよ、バスター！もし <code>accept()</code> の呼び出しがブロックされていたらどうでしょう？どうやって <code>recv()</code> を同時に行うんだ？&quot;ノンブロッキングソケットを使いましょう！&quot;まさか！CPU を占有するようなことはしない方がいい。じゃあ、何？</p>
<p><code>select()</code> は同時に複数のソケットを監視する力を与えてくれます。どのソケットが読み込み可能で、どのソケットが書き込み可能か、そしてどのソケットが例外を発生させたか、本当に知りたければ教えてくれるでしょう。</p>
<blockquote>
<p>警告: <code>select()</code> は非常にポータブルですが、巨大な数の接続が発生した場合には恐ろしく遅くなります。そのような状況では、<a href="https://libevent.org/">libevent</a> のようなイベントライブラリの方が、あなたのシステムで利用可能な最も高速なメソッドを使用しようとするため、より良いパフォーマンスを得ることができることでしょう。</p>
</blockquote>
<p>さっそくですが、<code>select()</code>の概要を説明します。</p>
<pre><code class="language-c">#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select(int numfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
</code></pre>
<p>この関数は、ファイル記述子の&quot;集合&quot;、特に <code>readfds</code>、<code>writefds</code>、<code>exceptfds</code> を監視します。標準入力とソケット記述子 <code>sockfd</code> から読み込めるかどうかを確認したい場合、ファイル記述子 <code>0</code> と <code>sockfd</code> を <code>readfds</code> の集合に追加するだけでよいです。パラメータ <code>numfds</code> には、最も大きいファイル記述子の値に <code>1</code> を足した値を設定する必要があります。この例では、標準入力 (<code>0</code>) よりも確実に大きいので、<code>sockfd+1</code> に設定する必要があります。</p>
<p><code>select()</code> が戻ると、<code>readfds</code> は、選択したファイル記述子のうち、どれが読み込める状態にあるかを反映するように変更されます。以下のマクロ <code>FD_ISSET()</code> を用いて、それらをテストすることができます。</p>
<p>この先に進む前に、これらのセットを操作する方法について説明します。各セットは <code>fd_set</code> 型です。以下のマクロはこの型を操作します。</p>
<table><thead><tr><th>Function</th><th>説明</th></tr></thead><tbody>
<tr><td><code>FD_SET(int fd, fd_set *set);</code></td><td><code>set</code> に <code>fd</code> を追加します。</td></tr>
<tr><td><code>FD_CLR(int fd, fd_set *set);</code></td><td><code>set</code> から <code>fd</code> を削除します。</td></tr>
<tr><td><code>FD_ISSET(int fd, fd_set *set);</code></td><td><code>fd</code> が <code>set</code> に含まれる場合は true を返します。</td></tr>
<tr><td><code>FD_ZERO(fd_set *set);</code></td><td><code>set</code> からすべてのエントリをクリアします。</td></tr>
</tbody></table>
<p>最後に、この奇妙な <code>struct timeval</code> とは何でしょうか？まあ、誰かがデータを送ってくるのをいつまでも待っていたくない場合もあるでしょう。例えば、96 秒ごとに &quot;Still Going...&quot; とターミナルに表示させたい、でも何も起きていない。この time 構造体では、タイムアウト時間を指定することができます。タイムアウト時間を超えても <code>select()</code> がまだ準備のできたファイル記述子を見つけられなければ、処理を続行できるように返されます。</p>
<p><code>struct timeval</code> は以下のフィールドを持ちます。</p>
<pre><code class="language-c">struct timeval {
    int tv_sec;     // seconds
    int tv_usec;    // microseconds
};
</code></pre>
<p><code>tv_sec</code> に待ち時間の秒数を、<code>tv_usec</code> に待ち時間のマイクロ秒数を設定するだけです。そう、これはミリ秒ではなくマイクロ秒なのです。ミリ秒の中には 1000 マイクロ秒があり、1 秒の中には 1000 ミリ秒があります。したがって、1 秒の中には 1,000,000 マイクロ秒があることになります。なぜ &quot;usec&quot;なのか？&quot;u&quot;は、私たちが&quot;マイクロ&quot;に使っているギリシャ文字の μ（ミュー）に似ていると思われるからです。また、関数が戻ってきたとき、<code>timeout</code> はまだ残っている時間を表示するように更新されるかもしれません。これは、あなたが使っている Unix のフレーバーに依存します。</p>
<p>やったー！マイクロ秒の分解能のタイマーを手に入れたぞ！まあ、当てにしない方がいいです。どんなに小さな <code>struct timeval</code> を設定しても、おそらく標準的な Unix のタイムスライスの一部を待つ必要があります。</p>
<p>その他、気になること。もし <code>struct timeval</code> のフィールドを <code>0</code> に設定すると、<code>select()</code> は直ちにタイムアウトし、セット内のすべてのファイル記述子を効率よくポーリングします。パラメータ <code>timeout</code> を <code>NULL</code> に設定すると、決してタイムアウトせず、最初のファイル記述子が準備できるまで待ちます。最後に、特定のセットを待つことを気にしないのであれば、<code>select()</code> のコールでそれを <code>NULL</code> に設定することができます。</p>
<p><a href="https://beej.us/guide/bgnet/examples/select.c">次のコード</a>では、標準入力に何か表示されるまで 2.5 秒待ちます。</p>
<pre><code class="language-c">/*
** select.c -- a select() demo
*/

#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define STDIN 0  // file descriptor for standard input

int main(void)
{
    struct timeval tv;
    fd_set readfds;

    tv.tv_sec = 2;
    tv.tv_usec = 500000;

    FD_ZERO(&amp;readfds);
    FD_SET(STDIN, &amp;readfds);

    // don't care about writefds and exceptfds:
    select(STDIN+1, &amp;readfds, NULL, NULL, &amp;tv);

    if (FD_ISSET(STDIN, &amp;readfds))
        printf(&quot;A key was pressed!\n&quot;);
    else
        printf(&quot;Timed out.\n&quot;);

    return 0;
}
</code></pre>
<p>ラインバッファ端末の場合、押すキーは RETURN でないと、とにかくタイムアウトしてしまいます。</p>
<p>さて、この方法はデータグラムソケットでデータを待つのに最適な方法だと思う人もいるかもしれませんね。Unice の中にはこの方法で select を使えるものもあれば、使えないものもあります。試してみたいなら、ローカルの man ページに何が書いてあるか見てみるといいです。</p>
<p>Unices の中には、タイムアウトまでの残り時間を反映して、<code>struct timeval</code> の時間を更新するものがあります。しかし、そうでないものもあります。ポータブルにしたいのであれば、そのようなことが起こることを当てにしないでください。（経過時間を追跡する必要がある場合は、<code>gettimeofday()</code> を使ってください。残念なことですが、それが現実なのです。）</p>
<p>リードセット内のソケットがコネクションをクローズした場合はどうなるのでしょうか？その場合、<code>select()</code> はそのソケット記述子を &quot;ready to read&quot; に設定して返す。実際にそこから <code>recv()</code> を実行すると、<code>recv()</code> は <code>0</code> を返します。これが、クライアントが接続を閉じたことを知るための方法です。</p>
<p>もうひとつ <code>select()</code> について書いておくと、<code>listen()</code> しているソケットがある場合、そのソケットのファイル記述子を <code>readfds</code> セットに入れておけば、新しい接続があるかどうかチェックすることができます。</p>
<p>以上、全能の関数 <code>select()</code> の概要を簡単に説明しました。</p>
<p>しかし、ご要望の多かった、より詳細な例をご紹介します。残念ながら、上記のごく簡単な例と、こちらの例では、大きな違いがあります。しかし、ご覧になってから、その後に続く説明をお読みください。</p>
<p><a href="https://beej.us/guide/bgnet/examples/selectserver.c">このプログラム</a>は、簡単なマルチユーザチャットサーバのように動作します。一つのウィンドウで起動し、他の複数のウィンドウから <code>telnet</code> (&quot;<code>telnet hostname 9034</code>&quot;) で接続してください。ある <code>telnet</code> セッションで何かを入力すると、他のすべてのウィンドウに表示されるはずです。</p>
<pre><code class="language-c">/*
** selectserver.c -- a cheezy multiperson chat server
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define PORT &quot;9034&quot;   // port we're listening on

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    fd_set master;    // master file descriptor list
    fd_set read_fds;  // temp file descriptor list for select()
    int fdmax;        // maximum file descriptor number

    int listener;     // listening socket descriptor
    int newfd;        // newly accept()ed socket descriptor
    struct sockaddr_storage remoteaddr; // client address
    socklen_t addrlen;

    char buf[256];    // buffer for client data
    int nbytes;

    char remoteIP[INET6_ADDRSTRLEN];

    int yes=1;        // for setsockopt() SO_REUSEADDR, below
    int i, j, rv;

    struct addrinfo hints, *ai, *p;

    FD_ZERO(&amp;master);    // clear the master and temp sets
    FD_ZERO(&amp;read_fds);

    // get us a socket and bind it
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) {
        fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));
        exit(1);
    }

    for(p = ai; p != NULL; p = p-&gt;ai_next) {
        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        if (listener &lt; 0) {
            continue;
        }

        // lose the pesky &quot;address already in use&quot; error message
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));

        if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) {
            close(listener);
            continue;
        }

        break;
    }

    // if we got here, it means we didn't get bound
    if (p == NULL) {
        fprintf(stderr, &quot;selectserver: failed to bind\n&quot;);
        exit(2);
    }

    freeaddrinfo(ai); // all done with this

    // listen
    if (listen(listener, 10) == -1) {
        perror(&quot;listen&quot;);
        exit(3);
    }

    // add the listener to the master set
    FD_SET(listener, &amp;master);

    // keep track of the biggest file descriptor
    fdmax = listener; // so far, it's this one

    // main loop
    for(;;) {
        read_fds = master; // copy it
        if (select(fdmax+1, &amp;read_fds, NULL, NULL, NULL) == -1) {
            perror(&quot;select&quot;);
            exit(4);
        }

        // run through the existing connections looking for data to read
        for(i = 0; i &lt;= fdmax; i++) {
            if (FD_ISSET(i, &amp;read_fds)) { // we got one!!
                if (i == listener) {
                    // handle new connections
                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&amp;remoteaddr,
                        &amp;addrlen);

                    if (newfd == -1) {
                        perror(&quot;accept&quot;);
                    } else {
                        FD_SET(newfd, &amp;master); // add to master set
                        if (newfd &gt; fdmax) {    // keep track of the max
                            fdmax = newfd;
                        }
                        printf(&quot;selectserver: new connection from %s on &quot;
                            &quot;socket %d\n&quot;,
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&amp;remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    // handle data from a client
                    if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {
                        // got error or connection closed by client
                        if (nbytes == 0) {
                            // connection closed
                            printf(&quot;selectserver: socket %d hung up\n&quot;, i);
                        } else {
                            perror(&quot;recv&quot;);
                        }
                        close(i); // bye!
                        FD_CLR(i, &amp;master); // remove from master set
                    } else {
                        // we got some data from a client
                        for(j = 0; j &lt;= fdmax; j++) {
                            // send to everyone!
                            if (FD_ISSET(j, &amp;master)) {
                                // except the listener and ourselves
                                if (j != listener &amp;&amp; j != i) {
                                    if (send(j, buf, nbytes, 0) == -1) {
                                        perror(&quot;send&quot;);
                                    }
                                }
                            }
                        }
                    }
                } // END handle data from client
            } // END got new incoming connection
        } // END looping through file descriptors
    } // END for(;;)--and you thought it would never end!

    return 0;
}
</code></pre>
<p>このコードでは、2つのファイル記述子セットを持っていることに注意してください。<code>master</code> と <code>read_fds</code> です。最初の <code>master</code> は、現在接続されているすべてのソケット記述子と、新しい接続を待ち受けているソケット記述子を保持します。</p>
<p><code>master</code> のセットを持っている理由は、<code>select()</code> が実際に渡すセットを変更して、どのソケットが読み込み可能な状態にあるかを反映させるためです。ある <code>select()</code> から次の <code>select()</code> への呼び出しまでの接続を追跡する必要があるので、これらをどこかに安全に保存しておかなければなりません。最後の最後で、<code>master</code> を <code>read_fds</code> にコピーしてから <code>select()</code> を呼び出します。</p>
<p>しかし、これでは新しい接続を得るたびに、それを <code>master</code> セットに追加しなければならないのではありませんか？そうです。そして接続が終了するたびに、それを <code>master</code> セットから削除しなければならないのですか？はい、その通りです。</p>
<p>注目すべきは、<code>listener</code> ソケットが読み込み可能な状態になったかどうかをチェックしていることです。このとき、新しい接続が保留されていることを意味するので、それを <code>accept()</code> して <code>master</code> セットに追加します。同様に、クライアントの接続が読み込み可能な状態になったときに、<code>recv()</code> が <code>0</code> を返したら、クライアントが接続を閉じたことがわかるので、<code>master</code> セットからそれを削除しなければなりません。</p>
<p>しかし、クライアントの <code>recv()</code> がゼロ以外を返した場合、何らかのデータを受信したことが分かります。そこで私はそれを取得し、<code>master</code> リストを経由して、接続されている残りのすべてのクライアントにそのデータを送信します。</p>
<p>以上が、全能の関数 <code>select()</code> の簡単でない概要です。</p>
<p>Linux ファンの皆さんへ：まれに、Linux の <code>select()</code> が &quot;ready-to-read&quot; を返した後、実際には読み込む準備ができていないことがあります！これは、Linux の <code>select()</code> が &quot;ready-to-read&quot; を返した後、実際には読み込む準備ができていないことを意味します。これはつまり、<code>select()</code> が読まないと言っているのに、<code>read()</code> でブロックしてしまうということです！なぜだ、この野郎---！とにかく、回避策は受信側のソケットで <code>O_NONBLOCK</code> フラグをセットして、 <code>EWOULDBLOCK</code> でエラーにすることです（これは発生しても無視しても大丈夫です）。ソケットをノンブロッキングに設定する方法については、<a href="slightly-advanced-techniques/../man-pages/fcntl.html"><code>fcntl()</code> のリファレンスページ</a>を参照してください。</p>
<p>さらに、ここでボーナス的な余談ですが、<code>poll()</code> という別の関数があります。これは <code>select()</code> とほぼ同じ動作をしますが、ファイル記述子集合を管理するシステムが異なります。<a href="slightly-advanced-techniques/select-synchronous-io-multiplexing-old-school.html#pollman">チェックしてみてください！</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="74-部分的な-sends-の処理"><a class="header" href="#74-部分的な-sends-の処理">7.4 部分的な <code>send()</code>s の処理</a></h1>
<p>上の <a href="slightly-advanced-techniques/../system-calls-or-bust/send-and-recv-talk-to-me-baby.html"><code>send()</code> の章</a>で、<code>send()</code> はあなたが頼んだバイトをすべて送らないかもしれない、と言ったのを覚えていますか？つまり、512バイト送って欲しいのに、412バイトが返ってきたとします。残りの100バイトはどうなったのでしょうか？</p>
<p>さて、それらはまだあなたの小さなバッファの中で送信されるのを待っています。あなたがコントロールできない状況のために、カーネルはすべてのデータを1つのチャンクで送信しないことを決定しました、そして今、私の友人は、データを外に出すのはあなた次第です。</p>
<p>このような関数を書いてやってもいいんじゃないでしょうか。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int sendall(int s, char *buf, int *len)
{
    int total = 0;        // how many bytes we've sent
    int bytesleft = *len; // how many we have left to send
    int n;

    while(total &lt; *len) {
        n = send(s, buf+total, bytesleft, 0);
        if (n == -1) { break; }
        total += n;
        bytesleft -= n;
    }

    *len = total; // return number actually sent here

    return n==-1?-1:0; // return -1 on failure, 0 on success
}
</code></pre>
<p>この例では、<code>s</code> がデータを送信するソケット、<code>buf</code> がデータを格納するバッファ、<code>len</code> がバッファのバイト数を格納する <code>int</code> へのポインタです。</p>
<p>この関数は、エラーが発生すると <code>-1</code> を返します（また、<code>send()</code> の呼び出しによって <code>errno</code> が設定されたままです）。また、実際に送信されたバイト数は <code>len</code> として返されます。これは、エラーがない限り、あなたが送信するように頼んだバイト数と同じになります。<code>sendall()</code> はデータを送信するために最善を尽くし、ハァハァ言っていますが、もしエラーがあればすぐに返されます。</p>
<p>念のため、この関数の呼び出しのサンプルを示します。</p>
<pre><code class="language-c">char buf[10] = &quot;Beej!&quot;;
int len;

len = strlen(buf);
if (sendall(s, buf, &amp;len) == -1) {
    perror(&quot;sendall&quot;);
    printf(&quot;We only sent %d bytes because of the error!\n&quot;, len);
}
</code></pre>
<p>パケットの一部が到着した場合、受信側ではどのようなことが起こるのでしょうか？パケットの長さがまちまちな場合、あるパケットが終わり、別のパケットが始まるのを受信側はどうやって知るのでしょうか？そう、現実のシナリオはロバの王道なのです。あなたはおそらくカプセル化しなければならないでしょう（冒頭の<a href="slightly-advanced-techniques/../what-is-a-socket/low-level-nonsense-and-network-theory.html">データのカプセル化の章</a>を覚えていますか？）詳細はこちらをご覧ください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="75-シリアライゼーション---データの詰め方"><a class="header" href="#75-シリアライゼーション---データの詰め方">7.5 シリアライゼーション---データの詰め方</a></h1>
<p>ネットワーク上でテキストデータを送るのは簡単ですが、<code>int</code> や <code>float</code> のような&quot;バイナリ&quot;データを送りたい場合はどうしたらよいでしょうか？その結果、いくつかの選択肢があることがわかりました。</p>
<ol>
<li>
<p>数字を <code>sprintf()</code> などの関数でテキストに変換し、送信します。受信側は <code>strtol()</code> などの関数を使ってテキストを解析し、数値に戻します。</p>
</li>
<li>
<p><code>send()</code> にデータへのポインタを渡して、データをそのまま送信します。</p>
</li>
<li>
<p>数値を携帯可能な2進数にエンコードします。受信側はそれをデコードします。</p>
</li>
</ol>
<p>スニークプレビュー！今夜だけ！</p>
<p>[<em>カーテン上昇</em>]</p>
<p>Beejは、&quot;私は、上の方法3を好みます！&quot;と言っています。</p>
<p>[<em>終</em>]</p>
<p>（この章を本格的に始める前に、これを行うためのライブラリは世の中に存在し、自分でローリングして移植性とエラーのない状態を維持することはかなり困難であることをお伝えしておきます。ですから、自分で実装することを決める前に、いろいろと調べて下調べをしてください。私は、このようなことがどのように機能するのかに興味がある人のために、ここに情報を記載します。）</p>
<p>実は、上記の方法はどれも欠点と利点があるのですが、一般的には、先ほど言ったように、私は3番目の方法を好みます。しかし、まず、他の2つの方法の欠点と利点について説明しましょう。</p>
<p>最初の方法は、数字をテキストとしてエンコードしてから送信するもので、電線を伝わってくるデータを簡単に印刷して読むことができるという利点があります。<a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">インターネットリレーチャット（IRC）</a>のように、帯域幅を必要としない状況で使用するには、人間が読めるプロトコルが優れている場合もあります。しかし、変換に時間がかかるという欠点があり、その結果はほとんど常に元の数値よりも多くのスペースを取ってしまいます。</p>
<p>方法2：生データを渡します。これは非常に簡単です（しかし危険です！）。送信するデータへのポインタを取り、それを使って <code>send()</code> を呼び出すだけです。</p>
<pre><code class="language-c">double d = 3490.15926535;

send(s, &amp;d, sizeof d, 0);  /* DANGER--non-portable! */
</code></pre>
<p>受け手はこのように受け取ります。</p>
<pre><code class="language-c">double d;

recv(s, &amp;d, sizeof d, 0);  /* DANGER--non-portable! */
</code></pre>
<p>速くて、シンプルで、いいことずくめじゃないですか。しかし、すべてのアーキテクチャが <code>double</code>（あるいは <code>int</code>）を同じビット表現で、あるいは同じバイト順序で表現しているわけではないことがわかりました！このコードは明らかに非移植的です。（おいおい---もしかしたら移植性は必要ないかもしれない。その場合は、これはいいし、速い。）</p>
<p>整数型をパッキングするとき、<code>htons()</code> クラスの関数が、数値をネットワークバイトオーダーに変換することによって、いかに移植性を保つのに役立つか、そして、それがいかに正しい行為であるかをすでに見てきました。残念ながら、<code>float</code> 型に対する同様の関数はありません。希望は失われてしまったのでしょうか？</p>
<p>恐るべし！（一瞬、怖くなったか？いいえ？少しも？）私たちにできることがあります。データを既知のバイナリ形式にパックし（または&quot;マーシャル&quot;、&quot;シリアライズ&quot;、あるいは他の1億の名前のうちの1つ）、受信者がリモート側で解凍できるようにすることができるのです。</p>
<p>&quot;既知のバイナリ形式&quot;とはどういう意味でしょうか？さて、<code>htons()</code> の例はもう見ましたね？これは、ホスト側のフォーマットが何であれ、数値をネットワークバイトオーダーに変更（あるいは&quot;エンコード&quot;）します。数字を逆変換（アンエンコード）するために、受信側は <code>ntohs()</code> を呼び出します。</p>
<p>でも、他の非整数型にはそんな関数はないって、さっき言い終わったばかりじゃないですか。そうです。そうなんだ。そして、C 言語にはこれを行う標準的な方法がないので、ちょっと困ったことになります（Python ファンにとってはありがたいダジャレですね）。</p>
<p>そのためには、データを既知の形式にパックし、それを電送してデコードする必要があります。例えば、<code>float</code> をパックするために、以下は<a href="https://beej.us/guide/bgnet/examples/pack.c">迅速で汚い方法ですが、改善の余地はたくさんあります</a>。</p>
<pre><code class="language-c">#include &lt;stdint.h&gt;

uint32_t htonf(float f)
{
    uint32_t p;
    uint32_t sign;

    if (f &lt; 0) { sign = 1; f = -f; }
    else { sign = 0; }

    p = ((((uint32_t)f)&amp;0x7fff)&lt;&lt;16) | (sign&lt;&lt;31); // whole part and sign
    p |= (uint32_t)(((f - (int)f) * 65536.0f))&amp;0xffff; // fraction

    return p;
}

float ntohf(uint32_t p)
{
    float f = ((p&gt;&gt;16)&amp;0x7fff); // whole part
    f += (p&amp;0xffff) / 65536.0f; // fraction

    if (((p&gt;&gt;31)&amp;0x1) == 0x1) { f = -f; } // sign bit set

    return f;
}
</code></pre>
<p>上記のコードは、32 ビットの数値に <code>float</code> を格納する素朴な実装のようなものです。上位ビット（31）は数値の符号（&quot;1&quot;は負を意味します）を格納するために使用され、次の7ビット（30-16）は <code>float</code> の整数部を格納するために使用されます。最後に残りのビット（15-0）は、数値の小数部分を格納するために使用されます。</p>
<p>使い方はいたって簡単です。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    float f = 3.1415926, f2;
    uint32_t netf;

    netf = htonf(f);  // convert to &quot;network&quot; form
    f2 = ntohf(netf); // convert back to test

    printf(&quot;Original: %f\n&quot;, f);        // 3.141593
    printf(&quot; Network: 0x%08X\n&quot;, netf); // 0x0003243F
    printf(&quot;Unpacked: %f\n&quot;, f2);       // 3.141586

    return 0;
}
</code></pre>
<p>プラス面は、小さくてシンプル、そして速いことです。32767 より大きい数を格納しようとすると、とても満足できるものではありません！マイナス面は、スペースを有効活用できないことと、範囲が大きく制限されることです。上の例では、小数点以下の桁数が正しく保存されていないこともおわかりいただけると思います。</p>
<p>代わりに何ができるのか？浮動小数点数を保存するための標準規格は <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE-754</a> として知られています。ほとんどのコンピュータは内部でこのフォーマットを使って浮動小数点演算を行っているので、厳密に言えば変換する必要はないのです。しかし、ソースコードの移植性を重視するのであれば、必ずしもそのような前提は成り立ちません。（一方、高速に動作させたいのであれば、変換を行う必要のないプラットフォームでは最適化すべきです！それが <code>htons()</code> やその類いの処理です。）</p>
<p>以下は、<a href="https://beej.us/guide/bgnet/examples/ieee754.c">浮動小数点と倍数を IEEE-754 フォーマットにエンコードするコード</a>です。（ほとんど--- NaN や Infinity はエンコードしませんが、そのように修正することができます。）</p>
<pre><code class="language-c">#define pack754_32(f) (pack754((f), 32, 8))
#define pack754_64(f) (pack754((f), 64, 11))
#define unpack754_32(i) (unpack754((i), 32, 8))
#define unpack754_64(i) (unpack754((i), 64, 11))

uint64_t pack754(long double f, unsigned bits, unsigned expbits)
{
    long double fnorm;
    int shift;
    long long sign, exp, significand;
    unsigned significandbits = bits - expbits - 1; // -1 for sign bit

    if (f == 0.0) return 0; // get this special case out of the way

    // check sign and begin normalization
    if (f &lt; 0) { sign = 1; fnorm = -f; }
    else { sign = 0; fnorm = f; }

    // get the normalized form of f and track the exponent
    shift = 0;
    while(fnorm &gt;= 2.0) { fnorm /= 2.0; shift++; }
    while(fnorm &lt; 1.0) { fnorm *= 2.0; shift--; }
    fnorm = fnorm - 1.0;

    // calculate the binary form (non-float) of the significand data
    significand = fnorm * ((1LL&lt;&lt;significandbits) + 0.5f);

    // get the biased exponent
    exp = shift + ((1&lt;&lt;(expbits-1)) - 1); // shift + bias

    // return the final answer
    return (sign&lt;&lt;(bits-1)) | (exp&lt;&lt;(bits-expbits-1)) | significand;
}

long double unpack754(uint64_t i, unsigned bits, unsigned expbits)
{
    long double result;
    long long shift;
    unsigned bias;
    unsigned significandbits = bits - expbits - 1; // -1 for sign bit

    if (i == 0) return 0.0;

    // pull the significand
    result = (i&amp;((1LL&lt;&lt;significandbits)-1)); // mask
    result /= (1LL&lt;&lt;significandbits); // convert back to float
    result += 1.0f; // add the one back on

    // deal with the exponent
    bias = (1&lt;&lt;(expbits-1)) - 1;
    shift = ((i&gt;&gt;significandbits)&amp;((1LL&lt;&lt;expbits)-1)) - bias;
    while(shift &gt; 0) { result *= 2.0; shift--; }
    while(shift &lt; 0) { result /= 2.0; shift++; }

    // sign it
    result *= (i&gt;&gt;(bits-1))&amp;1? -1.0: 1.0;

    return result;
}
</code></pre>
<p>32 ビット（おそらく <code>float</code>）と 64 ビット（おそらく <code>double</code>）の数値のパッキングとアンパッキングのための便利なマクロをトップに置きましたが、<code>pack754()</code> 関数を直接呼んで <code>bits</code> 分のデータ（<code>expbits</code> は正規化した数値の指数用に予約されています）をエンコードするように指示することができます。</p>
<p>以下は使用例です。</p>
<pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt; // defines uintN_t types
#include &lt;inttypes.h&gt; // defines PRIx macros

int main(void)
{
    float f = 3.1415926, f2;
    double d = 3.14159265358979323, d2;
    uint32_t fi;
    uint64_t di;

    fi = pack754_32(f);
    f2 = unpack754_32(fi);

    di = pack754_64(d);
    d2 = unpack754_64(di);

    printf(&quot;float before : %.7f\n&quot;, f);
    printf(&quot;float encoded: 0x%08&quot; PRIx32 &quot;\n&quot;, fi);
    printf(&quot;float after  : %.7f\n\n&quot;, f2);

    printf(&quot;double before : %.20lf\n&quot;, d);
    printf(&quot;double encoded: 0x%016&quot; PRIx64 &quot;\n&quot;, di);
    printf(&quot;double after  : %.20lf\n&quot;, d2);

    return 0;
}
</code></pre>
<p>上記のコードでは、このように出力されます。</p>
<pre><code>float before : 3.1415925
float encoded: 0x40490FDA
float after  : 3.1415925

double before : 3.14159265358979311600
double encoded: 0x400921FB54442D18
double after  : 3.14159265358979311600
</code></pre>
<p>もう一つの疑問は、<code>struct</code> をどのようにパックするかということです。残念ながら、コンパイラは <code>struct</code> の中に自由にパディングを入れることができるので、全体を1つのチャンクでポータブルに送信することはできません。（&quot;これができない&quot;、&quot;あれができない&quot;というのはもう聞き飽きた？すみません。友人の言葉を借りれば、&quot;何か問題が起きると、いつもマイクロソフトのせいにする &quot;ということです。これは確かにマイクロソフトのせいではないかもしれませんが、友人の発言は完全に事実です。）</p>
<p>話を戻すと、<code>struct</code> を電線で送るには、各フィールドを独立してパックし、反対側に到着したらそれらを <code>struct</code> にアンパックするのが一番良い方法です。</p>
<p>それは大変なことだ、とお考えでしょう。そうなんです。ひとつは、データをパックするのを手伝ってくれるヘルパー関数を書くことです。これは楽しいぞ。本当に！？</p>
<p>Kernighan と Pike の <a href="https://www.amazon.com/gp/product/020161586X/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=020161586X&amp;linkId=b3ac9370d2df122adcce0316aed99924">The Practice of Programming</a> という本の中で、彼らは <code>printf()</code> に似た関数である <code>pack()</code> と <code>unpack()</code> を実装し、まさにこのようなことをやっています。リンクしたいのですが、どうやらこれらの関数はこの本の他のソースと一緒にオンラインにないようです。</p>
<p>（The Practice of Programming は素晴らしい読み物です。ゼウスは私が勧めるたびに子猫を救ってくれます。）</p>
<p>この時点で、私は使ったことはありませんが、完全に立派に見える <a href="https://github.com/protobuf-c/protobuf-c">Protocol Buffers implementation in C</a> へのポインタを落とすつもりです。Python や Perl のプログラマは、同じことを実現するために、それぞれの言語の <code>pack()</code> と <code>unpack()</code> 関数をチェックアウトしたいと思うでしょう。また、Java には大きな Serializable インターフェースがあり、同じような方法で使用することができます。</p>
<p>しかし、C言語で独自のパッキングユーティリティを書きたい場合、K&amp;P のトリックは、変数の引数リストを使って <code>printf()</code> 風の関数を作り、パケットを構築することです。 以下は、それを元に<a href="https://beej.us/guide/bgnet/examples/pack2.c">私が自作したバージョン</a>ですが、うまくいけば、このようなものがどのように動作するかのアイデアを与えるのに十分なものです。</p>
<p>（このコードは、上記の <code>pack754()</code> 関数を参照しています。<code>packi*()</code> 関数はおなじみの <code>htons()</code> ファミリーと同じように動作しますが、別の整数の代わりに <code>char</code> 配列にパックする点が異なります。）</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;

/*
** packi16() -- store a 16-bit int into a char buffer (like htons())
*/
void packi16(unsigned char *buf, unsigned int i)
{
    *buf++ = i&gt;&gt;8; *buf++ = i;
}

/*
** packi32() -- store a 32-bit int into a char buffer (like htonl())
*/
void packi32(unsigned char *buf, unsigned long int i)
{
    *buf++ = i&gt;&gt;24; *buf++ = i&gt;&gt;16;
    *buf++ = i&gt;&gt;8;  *buf++ = i;
}

/*
** packi64() -- store a 64-bit int into a char buffer (like htonl())
*/
void packi64(unsigned char *buf, unsigned long long int i)
{
    *buf++ = i&gt;&gt;56; *buf++ = i&gt;&gt;48;
    *buf++ = i&gt;&gt;40; *buf++ = i&gt;&gt;32;
    *buf++ = i&gt;&gt;24; *buf++ = i&gt;&gt;16;
    *buf++ = i&gt;&gt;8;  *buf++ = i;
}

/*
** unpacki16() -- unpack a 16-bit int from a char buffer (like ntohs())
*/
int unpacki16(unsigned char *buf)
{
    unsigned int i2 = ((unsigned int)buf[0]&lt;&lt;8) | buf[1];
    int i;

    // change unsigned numbers to signed
    if (i2 &lt;= 0x7fffu) { i = i2; }
    else { i = -1 - (unsigned int)(0xffffu - i2); }

    return i;
}

/*
** unpacku16() -- unpack a 16-bit unsigned from a char buffer (like ntohs())
*/
unsigned int unpacku16(unsigned char *buf)
{
    return ((unsigned int)buf[0]&lt;&lt;8) | buf[1];
}

/*
** unpacki32() -- unpack a 32-bit int from a char buffer (like ntohl())
*/
long int unpacki32(unsigned char *buf)
{
    unsigned long int i2 = ((unsigned long int)buf[0]&lt;&lt;24) |
                           ((unsigned long int)buf[1]&lt;&lt;16) |
                           ((unsigned long int)buf[2]&lt;&lt;8)  |
                           buf[3];
    long int i;

    // change unsigned numbers to signed
    if (i2 &lt;= 0x7fffffffu) { i = i2; }
    else { i = -1 - (long int)(0xffffffffu - i2); }

    return i;
}

/*
** unpacku32() -- unpack a 32-bit unsigned from a char buffer (like ntohl())
*/
unsigned long int unpacku32(unsigned char *buf)
{
    return ((unsigned long int)buf[0]&lt;&lt;24) |
           ((unsigned long int)buf[1]&lt;&lt;16) |
           ((unsigned long int)buf[2]&lt;&lt;8)  |
           buf[3];
}

/*
** unpacki64() -- unpack a 64-bit int from a char buffer (like ntohl())
*/
long long int unpacki64(unsigned char *buf)
{
    unsigned long long int i2 = ((unsigned long long int)buf[0]&lt;&lt;56) |
                                ((unsigned long long int)buf[1]&lt;&lt;48) |
                                ((unsigned long long int)buf[2]&lt;&lt;40) |
                                ((unsigned long long int)buf[3]&lt;&lt;32) |
                                ((unsigned long long int)buf[4]&lt;&lt;24) |
                                ((unsigned long long int)buf[5]&lt;&lt;16) |
                                ((unsigned long long int)buf[6]&lt;&lt;8)  |
                                buf[7];
    long long int i;

    // change unsigned numbers to signed
    if (i2 &lt;= 0x7fffffffffffffffu) { i = i2; }
    else { i = -1 -(long long int)(0xffffffffffffffffu - i2); }

    return i;
}

/*
** unpacku64() -- unpack a 64-bit unsigned from a char buffer (like ntohl())
*/
unsigned long long int unpacku64(unsigned char *buf)
{
    return ((unsigned long long int)buf[0]&lt;&lt;56) |
           ((unsigned long long int)buf[1]&lt;&lt;48) |
           ((unsigned long long int)buf[2]&lt;&lt;40) |
           ((unsigned long long int)buf[3]&lt;&lt;32) |
           ((unsigned long long int)buf[4]&lt;&lt;24) |
           ((unsigned long long int)buf[5]&lt;&lt;16) |
           ((unsigned long long int)buf[6]&lt;&lt;8)  |
           buf[7];
}

/*
** pack() -- store data dictated by the format string in the buffer
**
**   bits |signed   unsigned   float   string
**   -----+----------------------------------
**      8 |   c        C
**     16 |   h        H         f
**     32 |   l        L         d
**     64 |   q        Q         g
**      - |                               s
**
**  (16-bit unsigned length is automatically prepended to strings)
*/

unsigned int pack(unsigned char *buf, char *format, ...)
{
    va_list ap;

    signed char c;              // 8-bit
    unsigned char C;

    int h;                      // 16-bit
    unsigned int H;

    long int l;                 // 32-bit
    unsigned long int L;

    long long int q;            // 64-bit
    unsigned long long int Q;

    float f;                    // floats
    double d;
    long double g;
    unsigned long long int fhold;

    char *s;                    // strings
    unsigned int len;

    unsigned int size = 0;

    va_start(ap, format);

    for(; *format != '\0'; format++) {
        switch(*format) {
        case 'c': // 8-bit
            size += 1;
            c = (signed char)va_arg(ap, int); // promoted
            *buf++ = c;
            break;

        case 'C': // 8-bit unsigned
            size += 1;
            C = (unsigned char)va_arg(ap, unsigned int); // promoted
            *buf++ = C;
            break;

        case 'h': // 16-bit
            size += 2;
            h = va_arg(ap, int);
            packi16(buf, h);
            buf += 2;
            break;

        case 'H': // 16-bit unsigned
            size += 2;
            H = va_arg(ap, unsigned int);
            packi16(buf, H);
            buf += 2;
            break;

        case 'l': // 32-bit
            size += 4;
            l = va_arg(ap, long int);
            packi32(buf, l);
            buf += 4;
            break;

        case 'L': // 32-bit unsigned
            size += 4;
            L = va_arg(ap, unsigned long int);
            packi32(buf, L);
            buf += 4;
            break;

        case 'q': // 64-bit
            size += 8;
            q = va_arg(ap, long long int);
            packi64(buf, q);
            buf += 8;
            break;

        case 'Q': // 64-bit unsigned
            size += 8;
            Q = va_arg(ap, unsigned long long int);
            packi64(buf, Q);
            buf += 8;
            break;

        case 'f': // float-16
            size += 2;
            f = (float)va_arg(ap, double); // promoted
            fhold = pack754_16(f); // convert to IEEE 754
            packi16(buf, fhold);
            buf += 2;
            break;

        case 'd': // float-32
            size += 4;
            d = va_arg(ap, double);
            fhold = pack754_32(d); // convert to IEEE 754
            packi32(buf, fhold);
            buf += 4;
            break;

        case 'g': // float-64
            size += 8;
            g = va_arg(ap, long double);
            fhold = pack754_64(g); // convert to IEEE 754
            packi64(buf, fhold);
            buf += 8;
            break;

        case 's': // string
            s = va_arg(ap, char*);
            len = strlen(s);
            size += len + 2;
            packi16(buf, len);
            buf += 2;
            memcpy(buf, s, len);
            buf += len;
            break;
        }
    }

    va_end(ap);

    return size;
}

/*
** unpack() -- unpack data dictated by the format string into the buffer
**
**   bits |signed   unsigned   float   string
**   -----+----------------------------------
**      8 |   c        C
**     16 |   h        H         f
**     32 |   l        L         d
**     64 |   q        Q         g
**      - |                               s
**
**  (string is extracted based on its stored length, but 's' can be
**  prepended with a max length)
*/
void unpack(unsigned char *buf, char *format, ...)
{
    va_list ap;

    signed char *c;              // 8-bit
    unsigned char *C;

    int *h;                      // 16-bit
    unsigned int *H;

    long int *l;                 // 32-bit
    unsigned long int *L;

    long long int *q;            // 64-bit
    unsigned long long int *Q;

    float *f;                    // floats
    double *d;
    long double *g;
    unsigned long long int fhold;

    char *s;
    unsigned int len, maxstrlen=0, count;

    va_start(ap, format);

    for(; *format != '\0'; format++) {
        switch(*format) {
        case 'c': // 8-bit
            c = va_arg(ap, signed char*);
            if (*buf &lt;= 0x7f) { *c = *buf;} // re-sign
            else { *c = -1 - (unsigned char)(0xffu - *buf); }
            buf++;
            break;

        case 'C': // 8-bit unsigned
            C = va_arg(ap, unsigned char*);
            *C = *buf++;
            break;

        case 'h': // 16-bit
            h = va_arg(ap, int*);
            *h = unpacki16(buf);
            buf += 2;
            break;

        case 'H': // 16-bit unsigned
            H = va_arg(ap, unsigned int*);
            *H = unpacku16(buf);
            buf += 2;
            break;

        case 'l': // 32-bit
            l = va_arg(ap, long int*);
            *l = unpacki32(buf);
            buf += 4;
            break;

        case 'L': // 32-bit unsigned
            L = va_arg(ap, unsigned long int*);
            *L = unpacku32(buf);
            buf += 4;
            break;

        case 'q': // 64-bit
            q = va_arg(ap, long long int*);
            *q = unpacki64(buf);
            buf += 8;
            break;

        case 'Q': // 64-bit unsigned
            Q = va_arg(ap, unsigned long long int*);
            *Q = unpacku64(buf);
            buf += 8;
            break;

        case 'f': // float
            f = va_arg(ap, float*);
            fhold = unpacku16(buf);
            *f = unpack754_16(fhold);
            buf += 2;
            break;

        case 'd': // float-32
            d = va_arg(ap, double*);
            fhold = unpacku32(buf);
            *d = unpack754_32(fhold);
            buf += 4;
            break;

        case 'g': // float-64
            g = va_arg(ap, long double*);
            fhold = unpacku64(buf);
            *g = unpack754_64(fhold);
            buf += 8;
            break;

        case 's': // string
            s = va_arg(ap, char*);
            len = unpacku16(buf);
            buf += 2;
            if (maxstrlen &gt; 0 &amp;&amp; len &gt;= maxstrlen) count = maxstrlen - 1;
            else count = len;
            memcpy(s, buf, count);
            s[count] = '\0';
            buf += len;
            break;

        default:
            if (isdigit(*format)) { // track max str len
                maxstrlen = maxstrlen * 10 + (*format-'0');
            }
        }

        if (!isdigit(*format)) maxstrlen = 0;
    }

    va_end(ap);
}
</code></pre>
<p>そして、<a href="https://beej.us/guide/bgnet/examples/pack2.c">上記のコード</a>で、あるデータを <code>buf</code> にパックし、それを変数に展開するデモプログラムを以下に示します。なお、文字列の引数（フォーマット指定子 &quot;<code>s</code>&quot;）を指定して <code>unpack()</code> を呼び出す場合は、バッファオーバーランを防ぐために最大長を &quot;<code>96s</code>&quot; のように前に置くことが賢明です。ネットワーク経由で受け取ったデータを解凍するときには注意が必要です。悪意のあるユーザが、あなたのシステムを攻撃するために、うまく構成されたパケットを送るかもしれません！</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// various bits for floating point types--
// varies for different architectures
typedef float float32_t;
typedef double float64_t;

int main(void)
{
    unsigned char buf[1024];
    int8_t magic;
    int16_t monkeycount;
    int32_t altitude;
    float32_t absurdityfactor;
    char *s = &quot;Great unmitigated Zot! You've found the Runestaff!&quot;;
    char s2[96];
    int16_t packetsize, ps2;

    packetsize = pack(buf, &quot;chhlsf&quot;, (int8_t)'B', (int16_t)0, (int16_t)37, 
            (int32_t)-5, s, (float32_t)-3490.6677);
    packi16(buf+1, packetsize); // store packet size in packet for kicks

    printf(&quot;packet is %&quot; PRId32 &quot; bytes\n&quot;, packetsize);

    unpack(buf, &quot;chhl96sf&quot;, &amp;magic, &amp;ps2, &amp;monkeycount, &amp;altitude, s2,
        &amp;absurdityfactor);

    printf(&quot;'%c' %&quot; PRId32&quot; %&quot; PRId16 &quot; %&quot; PRId32
            &quot; \&quot;%s\&quot; %f\n&quot;, magic, ps2, monkeycount,
            altitude, s2, absurdityfactor);

    return 0;
}
</code></pre>
<p>自分でコードをロールアップするにしても、他人のコードを使うにしても、毎回手作業で各ビットをパッキングするのではなく、バグを抑えるために一般的なデータパッキングルーチンのセットを用意するのは良いアイデアだと思います。</p>
<p>データをパッキングする場合、どのような形式が良いのでしょうか？素晴らしい質問です。幸いなことに、<a href="https://datatracker.ietf.org/doc/html/rfc4506">RFC4506</a>（外部データ表現規格）では、浮動小数点型、整数型、配列、生データなど、さまざまな型のバイナリ形式をすでに定義しているんです。もし自分でデータをロールバックするのであれば、それに準拠することをお勧めします。でも、そうする義務はありません。パケット警察は、あなたのドアのすぐ外にいるわけではありません。少なくとも、私は彼らがそうだとは思いません。</p>
<p>いずれにせよ、データを送信する前に何らかの方法でエンコードするのが正しい方法なのです！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="76-データカプセル化の子"><a class="header" href="#76-データカプセル化の子">7.6 データカプセル化の子</a></h1>
<p>ところで、データをカプセル化するとはどういうことでしょうか。最も単純なケースでは、識別情報かパケット長のどちらか、あるいは両方を含むヘッダーをそこに貼り付けるということです。</p>
<p>ヘッダーはどのようなものにすべきでしょうか？まあ、プロジェクトを完成させるために必要だと思うものを表すバイナリデータに過ぎません。</p>
<p>うわー。漠然としてますね。</p>
<p>なるほど。例えば、<code>SOCK_STREAM</code> を使用したマルチユーザチャットプログラムがあるとします。ユーザが何かをタイプする (&quot;発言する&quot;) と、2つの情報がサーバに送信される必要があります: 何を発言したか、誰が発言したかです。</p>
<p>ここまでは良いですか？&quot;では何が問題なのか？&quot;とあなたは聞いているのでしょう。</p>
<p>問題は、メッセージの長さがまちまちであることです。ある人は &quot;tom&quot; と名乗り、ある人は &quot;Benjamin&quot; と名乗り、&quot;Hey guys what is up?&quot; と言うかもしれません。</p>
<p>そこで、これらのものが入ってきたときに <code>send()</code> でクライアントに送るわけです。送信するデータストリームは次のようになります。</p>
<pre><code>t o m H i B e n j a m i n H e y g u y s w h a t i s u p ?
</code></pre>
<p>といった具合に。あるメッセージが始まり、別のメッセージが止まったとき、クライアントはどうやって知るのでしょうか？もし望むなら、すべてのメッセージを同じ長さにして、<a href="slightly-advanced-techniques/../slightly-advanced-techniques/handling-partial-sends.html">上で実装</a>した <code>sendall()</code> を呼び出すだけでよいでしょう。しかし、それはバンド幅を浪費します！&quot;tom&quot; が &quot;Hi&quot; と言うために 1024 バイトも <code>send()</code> したくはないでしょう。</p>
<p>そこで、データを小さなヘッダーとパケット構造でカプセル化します。クライアントもサーバも、このデータをどのようにパックしたりアンパックしたりするか（&quot;マーシャル&quot;, &quot;アンマーシャル&quot;と呼ばれることもあります）知っています。今は見ないでください、私たちは、クライアントとサーバがどのように通信するかを記述するプロトコルを定義し始めているのです</p>
<p>この場合、ユーザ名は固定長で8文字、パディングは <code>'\0'</code> とします。そして、データは最大 128 文字の可変長とします。このような場合に使用するパケット構造の例を見てみましょう。</p>
<ol>
<li>
<p><code>len</code> (1 byte, unsigned)---8 バイトのユーザ名とチャットデータをカウントしたパケットの総長です。</p>
</li>
<li>
<p><code>name</code> (8 bytes)---ユーザの名前。必要なら NUL パッドされます。</p>
</li>
<li>
<p><code>chatdata</code> (n-bytes) --- データ自体で、128 バイト以下です。パケットの長さは、このデータの長さに 8（上記の名前フィールドの長さ）を加えたものとします。</p>
</li>
</ol>
<p>なぜ、8 バイトと 128 バイトというフィールドの制限を選んだのか？十分な長さがあると思い、思いつきで選んだのです。しかし、8 バイトでは制約が多すぎる、30 バイトの名前フィールドがあってもいい、などということもあるかもしれません。 選択はあなた次第です。</p>
<p>上記のパケット定義を用いると、最初のパケットは以下の情報（16 進数、ASCII）で構成されることになります。</p>
<pre><code>   0A     74 6F 6D 00 00 00 00 00      48 69
(length)  T  o  m    (padding)         H  i
</code></pre>
<p>そして、2つ目も同様です。</p>
<pre><code>   18     42 65 6E 6A 61 6D 69 6E      48 65 79 20 67 75 79 73 20 77 ...
(length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w  ...
</code></pre>
<p>（もちろん、長さはネットワークバイトオーダーで格納されます。この場合は 1 バイトだけなので問題ないですが、一般的にはパケット内の 2 進整数はすべてネットワークバイトオーダーで格納されるようにしたいです。）</p>
<p>このデータを送信するときには、安全策をとって上記の <a href="slightly-advanced-techniques/../slightly-advanced-techniques/handling-partial-sends.html"><code>sendall()</code></a> のようなコマンドを使うべきです。そうすれば、たとえすべてのデータを送信するために <code>send()</code> を複数回呼び出す必要があったとしても、すべてのデータが送信されたことを確認できます。</p>
<p>同様に、このデータを受信するときにも、少し余分な作業をする必要があります。念のため、部分的なパケットを受け取るかもしれないことを想定しておく必要があります（例えば、上の Benjamin から &quot;<code>18 42 65 6E 6A</code>&quot; を受け取るかもしれませんが、この <code>recv()</code> のコールではそれがすべてです。）。パケットが完全に受信されるまで、何度も何度も <code>recv()</code> を呼び出す必要があります。</p>
<p>でも、どうやって？さて、私たちはパケットが完成するために必要な合計バイト数を知っています。その数はパケットの前面に貼られているからです。 また、パケットの最大サイズは 1+8+128、つまり 137 バイトであることも知っています（パケットの定義がそうなっているからです）。</p>
<p>実は、ここでできることがいくつかあるんです。すべてのパケットが長さで始まることを知っているので、パケットの長さを取得するためだけに <code>recv()</code> を呼び出すことができます。そして、一度それを手に入れたら、パケットの残りの長さを正確に指定して（おそらくすべてのデータを得るために繰り返し）、完全なパケットを手に入れるまで再びそれを呼び出すことができます。この方法の利点は、1つのパケットに対して十分な大きさのバッファが必要なことで、欠点は、すべてのデータを取得するために少なくとも2回 <code>recv()</code> を呼び出す必要があることです。</p>
<p>もう一つの方法は、単に <code>recv()</code> を呼び出して、受信してもよい量をパケットの最大バイト数として言うことです。そして、受け取ったものはすべてバッファの後ろに貼り付け、最後にパケットが完了したかどうかを確認します。もちろん、次のパケットの一部を受け取るかもしれないので、そのためのスペースが必要です。</p>
<p>そこで、2つのパケットに十分な大きさの配列を宣言します。これは作業用の配列で、到着したパケットを再構築します。</p>
<p>データを <code>recv()</code> するたびに、ワークバッファにデータを追加し、パケットが完成したかどうかチェックします。すなわち、バッファ内のバイト数がヘッダで指定された長さ以上であること（ヘッダの長さには長さ自体のバイト数は含まれないので、+1）です。バッファ内のバイト数が1より小さい場合、明らかにパケットは完全ではありません。この場合、特別なケースを作る必要があります。しかし、最初の 1 バイトはゴミなので、正しいパケット長を知るためにそれを当てにすることはできないからです。</p>
<p>パケットを完成させたら、あとは好きなように使ってください。使って、ワークバッファから削除してください。</p>
<p>ふぅ〜。もう頭の中でグルグルしてますか？さて、ここでワンツーパンチの2つ目です。1回の <code>recv()</code> 呼び出しで、あるパケットの終わりを越えて次のパケットを読んでしまったかもしれません。つまり、一つの完全なパケットと、次のパケットの不完全な部分を持つワークバッファを持っているのです！なんてこったい。（しかし、このような事態を想定して、ワークバッファを2つのパケットを保持できるような大きさにしたのです！）</p>
<p>最初のパケットの長さはヘッダからわかっているし、ワークバッファのバイト数も記録しているので、ワークバッファのバイト数のうち何バイトが2番目の（不完全な）パケットに属しているかを差し引いて計算することができるのです。最初のパケットを処理したら、それをワークバッファから取り除き、部分的な2番目のパケットをバッファの先頭に移動させ、次の <code>recv() </code> のためにすべての準備をすることができます。</p>
<p>（読者の中には、実際に部分的な2番目のパケットをワークバッファの先頭に移動させるのに時間がかかることを指摘する人もいるでしょう。プログラムは、循環バッファを使用することによって、これを必要としないようにコード化することができます。残念ながら、円形バッファに関する議論は、この記事の範囲外です。それでも気になるなら、データ構造の本を読んでみてください。）</p>
<p>簡単だとは言っていません。なるほど、簡単だとは言いました。練習すれば、すぐに自然にできるようになりますよ。エクスカリバーに誓って！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="77-ブロードキャストパケット---hello-world"><a class="header" href="#77-ブロードキャストパケット---hello-world">7.7 ブロードキャストパケット---Hello, World!</a></h1>
<p>これまで、このガイドでは、1つのホストから他の1つのホストにデータを送信することについて話してきました。しかし、適切な権限があれば、同時に複数のホストにデータを送信することが可能です、と私は主張します！</p>
<p>UDP（TCP ではなく UDP のみ）と標準的な IPv4 では、これはブロードキャストと呼ばれるメカニズムによって行われます。IPv6 ではブロードキャストはサポートされていないため、マルチキャストという優れた技術を利用する必要があります。しかし、未来に目を向けるのはもう十分です。私たちは 32 ビットの現在に留まっています。</p>
<p>しかし、ちょっと待ってください！いきなりブロードキャストを始めることはできません。ブロードキャストパケットをネットワークに送信する前に、ソケットオプション <code>SO_BROADCAST</code> をセットしなければなりません。まるでミサイルの発射スイッチの上に被せる小さなプラスチックのカバーのようなものです。そのくらいのパワーを秘めているのです。</p>
<p>しかし、真面目な話、ブロードキャストパケットを使うには危険性があるのです。ブロードキャストパケットを受信したすべてのシステムは、そのデータの行き先がどのポートか分かるまで、何層にもわたるデータのカプセル化を解かなければならないのです。そして、そのデータを渡すか、廃棄するかしなければなりません。どちらの場合でも、ブロードキャストパケットを受信した各マシンは、ローカルネットワーク上のすべてのマシンで、多くのマシンが不必要な作業をすることになりかねません。ゲーム Doom が発売された当初、これはそのネットワークコードに対する不満でした。</p>
<p>さて、猫の皮を剥ぐ方法は一つではない......ちょっと待った。本当に猫の皮を剥ぐ方法は1つではないのですか？どんな表現なんだ？それと同じように、ブロードキャストパケットを送る方法も1つではありません。では、本題のブロードキャストメッセージの宛先アドレスはどのように指定するのでしょうか？一般的には2つの方法があります。</p>
<ol>
<li>
<p>特定のサブネットのブロードキャストアドレスにデータを送信します。これは、サブネットのネットワーク番号に、アドレスのホスト部分のすべての 1 ビットを設定したものです。例えば、私の家のネットワークは <code>192.168.1.0</code>、ネットマスクは <code>255.255.255.0</code> で、アドレスの最後のバイトは私のホスト番号です（ネットマスクによると、最初の 3 バイトはネットワーク番号だからです）。つまり、私のブロードキャストアドレスは <code>192.168.1.255</code> です。Unix では、<code>ifconfig</code> コマンドが実際にこのすべてのデータを与えてくれます。（気になる方は、ブロードキャストアドレスを得るためのビット論理は <code>network_number</code> OR (NOT <code>netmask</code>) です。）このタイプのブロードキャストパケットは、自分のローカルネットワークだけでなく、遠隔地のネットワークにも送ることができますが、宛先のルータによってパケットがドロップされる危険性があります。（もしドロップされなかったら、どこかのランダムなスマーフが彼らの LAN にブロードキャストトラフィックを流し始めるかもしれません。）</p>
</li>
<li>
<p>&quot;グローバル&quot;ブロードキャストアドレスにデータを送信します。これは <code>255.255.255.255</code> で、別名 <code>INADDR_BROADCAST</code> と呼ばれるものです。多くのマシンはこれをネットワーク番号と自動的にビット演算して、ネットワークブロードキャストアドレスに変換しますが、そうでないものもあります。ルータは、皮肉なことに、この種のブロードキャストパケットをローカルネットワークから転送しません。</p>
</li>
</ol>
<p>では、ソケットオプション <code>SO_BROADCAST</code> を設定せずに、ブロードキャストアドレスでデータを送信しようとするとどうなるでしょうか。それでは、古き良き時代の <a href="slightly-advanced-techniques/../client-server-background/datagram-sockets.html"><code>talker</code> と <code>listener</code></a> を起動し、何が起こるか見てみましょう。</p>
<pre><code>$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sendto: Permission denied
$ talker 255.255.255.255 foo
sendto: Permission denied
</code></pre>
<p>そう、全然嬉しくないんです...ソケットオプションの <code>SO_BROADCAST</code> を設定していなかったからです。そうすれば、どこでも <code>sendto()</code> ができるようになります！</p>
<p>実際、これがブロードキャストできる UDP アプリケーションとできない UDP アプリケーションの唯一の違いなのです。そこで、古い <code>talker</code> アプリケーションに <code>SO_BROADCAST</code> ソケットオプションを設定する章を一つ追加してみましょう。このプログラムを <a href="https://beej.us/guide/bgnet/examples/broadcaster.c"><code>broadcaster.c</code></a> と呼ぶことにします。</p>
<pre><code class="language-c">/*
** broadcaster.c -- a datagram &quot;client&quot; like talker.c, except
**                  this one can broadcast
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT 4950 // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // connector's address information
    struct hostent *he;
    int numbytes;
    int broadcast = 1;
    //char broadcast = '1'; // if that doesn't work, try this

    if (argc != 3) {
        fprintf(stderr,&quot;usage: broadcaster hostname message\n&quot;);
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // get the host info
        perror(&quot;gethostbyname&quot;);
        exit(1);
    }

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror(&quot;socket&quot;);
        exit(1);
    }

    // this call is what allows broadcast packets to be sent:
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcast,
        sizeof broadcast) == -1) {
        perror(&quot;setsockopt (SO_BROADCAST)&quot;);
        exit(1);
    }

    their_addr.sin_family = AF_INET;     // host byte order
    their_addr.sin_port = htons(SERVERPORT); // short, network byte order
    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
    memset(their_addr.sin_zero, '\0', sizeof their_addr.sin_zero);

    if ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0,
             (struct sockaddr *)&amp;their_addr, sizeof their_addr)) == -1) {
        perror(&quot;sendto&quot;);
        exit(1);
    }

    printf(&quot;sent %d bytes to %s\n&quot;, numbytes,
        inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
}
</code></pre>
<p>&quot;通常の&quot; UDP クライアント/サーバの状況と何が違うのでしょうか？何もありません。（この場合、クライアントがブロードキャストパケットの送信を許可されていることを除けば。）このように、古い UDP <a href="slightly-advanced-techniques/../client-server-background/datagram-sockets.html"><code>listener</code></a> プログラムを1つのウィンドウで実行し、<code>broadcaster</code> を別のウィンドウで実行してみてください。これで、上で失敗した送信をすべて行うことができるはずです。</p>
<pre><code>$ broadcaster 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ broadcaster 192.168.1.255 foo
sent 3 bytes to 192.168.1.255
$ broadcaster 255.255.255.255 foo
sent 3 bytes to 255.255.255.255
</code></pre>
<p>そして、<code>listener</code> がパケットを受け取ったと応答するのが見えるはずです。（もし <code>listener</code> が応答しないなら、それは IPv6 アドレスにバインドされているからかもしれません。<code>listener.c</code> の <code>AF_UNSPEC</code> を <code>AF_INET</code> に変更して、強制的に IPv4 にすることを試してみてください。）</p>
<p>なるほど、それはちょっと楽しみですね。しかし、今度は同じネットワーク上にある隣のマシンで <code>listener</code> を起動して、それぞれのマシンに2つのコピーを作成し、ブロードキャストアドレスを指定して <code>broadcaster</code> を再度実行してみてください... おい！両方の <code>listener</code> がパケットを受け取るぞ！<code>sendto()</code> を一度しか呼んでいないのにな。かっこいい！</p>
<p>もし <code>listener</code> が、あなたが直接送ったデータを受け取って、ブロードキャストアドレスのデータを受け取らないなら、あなたのローカルマシンのファイアウォールがパケットをブロックしている可能性があります。（そうそう、Pat とBapper、これが私のサンプルコードが動作しない理由だと、私より先に気づいてくれてありがとうございます。ガイドの中で紹介すると言っておいたのに、こうして紹介してくれて。というわけで、にゃー。）</p>
<p>繰り返しになりますが、ブロードキャストパケットには注意が必要です。LAN 上のすべてのマシンが <code>recvfrom()</code> したかどうかに関わらず、そのパケットを処理しなければならないので、計算機ネットワーク全体にかなりの負荷を与える可能性があります。ブロードキャストパケットは控えめに、そして適切に使用されるべきものであることは間違いありません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-よくある質問"><a class="header" href="#8-よくある質問">8 よくある質問</a></h1>
<h3 id="81-ヘッダーファイルはどこで入手できますか"><a class="header" href="#81-ヘッダーファイルはどこで入手できますか">8.1 ヘッダーファイルはどこで入手できますか？</a></h3>
<p>もし、あなたのシステムに既にないのであれば、おそらく必要ないでしょう。あなたのプラットフォームのマニュアルを参照してください。Windows 用にビルドする場合は、<code>#include &lt;winsock.h&gt;</code> だけが必要です。</p>
<h3 id="82-bind-が-address-already-in-use-と報告した場合どうすればよいのでしょうか"><a class="header" href="#82-bind-が-address-already-in-use-と報告した場合どうすればよいのでしょうか">8.2 <code>bind()</code> が &quot;Address already in use&quot; と報告した場合、どうすればよいのでしょうか？</a></h3>
<p>リスニングしているソケットで <code>SO_REUSEADDR</code> オプションを指定して <code>setsockopt()</code> を使用する必要があります。例として、<a href="common-questions/../system-calls-or-bust/bind-what-port-am-i-on.html"><code>bind()</code> の章</a>と <a href="common-questions/../slightly-advanced-techniques/select-synchronous-io-multiplexing-old-school.html"><code>select()</code> の章</a>をチェックしてみてください。</p>
<h3 id="83-システム上のオープンソケットのリストを取得するにはどうすればよいですか"><a class="header" href="#83-システム上のオープンソケットのリストを取得するにはどうすればよいですか">8.3 システム上のオープンソケットのリストを取得するにはどうすればよいですか？</a></h3>
<p><code>netstat</code> を使用します。詳しくは <code>man</code> ページをチェックしてください。しかし、タイプするだけで良い出力が得られるはずです。</p>
<pre><code>$ netstat
</code></pre>
<p>唯一のコツは、どのソケットがどのプログラムに関連付けられているかを判断することです。<code>:-)</code></p>
<h3 id="84-ルーティングテーブルを見るにはどうしたらいいですか"><a class="header" href="#84-ルーティングテーブルを見るにはどうしたらいいですか">8.4 ルーティングテーブルを見るにはどうしたらいいですか？</a></h3>
<p><code>route</code> コマンド（ほとんどの Linux では <code>/sbin</code> にあります）または <code>netstat -r</code> コマンドを実行します。</p>
<h3 id="85-クライアントとサーバのプログラムが1台しかない場合どのように実行すればよいのでしょうかネットワークプログラムを書くのにネットワークは必要ないのですか"><a class="header" href="#85-クライアントとサーバのプログラムが1台しかない場合どのように実行すればよいのでしょうかネットワークプログラムを書くのにネットワークは必要ないのですか">8.5 クライアントとサーバのプログラムが1台しかない場合、どのように実行すればよいのでしょうか？ネットワークプログラムを書くのにネットワークは必要ないのですか？</a></h3>
<p>幸いなことに、事実上すべてのマシンは、カーネル内に配置され、ネットワークカードのふりをするループバックネットワーク&quot;デバイス&quot;を実装しています。（これはルーティングテーブルで &quot;<code>lo</code>&quot; としてリストされるインターフェースです。）</p>
<p>あなたが &quot;<code>goat</code>&quot; という名前のマシンにログインしていると仮定します。あるウィンドウでクライアントを、別のウィンドウでサーバを実行します。あるいは、サーバをバックグラウンドで起動し（&quot;<code>server &amp;</code>&quot;）、同じウィンドウでクライアントを実行します。ループバックデバイスの利点は、<code>client goat</code> か <code>client localhost</code>（<code>localhost</code> は <code>/etc/hosts</code> ファイルで定義されていると思われるので）を使えば、ネットワークなしでクライアントがサーバと通信できるようになることです！</p>
<p>つまり、ネットワークに接続されていない1台のマシンで動作させるために、コードの変更は一切必要ないのです！ハッザー！</p>
<h3 id="86-リモート側が接続を閉じたかどうかを判断するにはどうすればよいですか"><a class="header" href="#86-リモート側が接続を閉じたかどうかを判断するにはどうすればよいですか">8.6 リモート側が接続を閉じたかどうかを判断するにはどうすればよいですか？</a></h3>
<p><code>recv()</code> が <code>0</code> を返すのでわかります。</p>
<h3 id="87-ping-ユーティリティを実装するにはicmp-とは何ですか生ソケットと-sock_raw-についてもっと詳しく知りたいのですがどこに行けばよいですか"><a class="header" href="#87-ping-ユーティリティを実装するにはicmp-とは何ですか生ソケットと-sock_raw-についてもっと詳しく知りたいのですがどこに行けばよいですか">8.7 &quot;ping&quot; ユーティリティを実装するには？ICMP とは何ですか？生ソケットと <code>SOCK_RAW</code> についてもっと詳しく知りたいのですが、どこに行けばよいですか?</a></h3>
<p>生ソケットに関するすべての疑問は、<a href="common-questions/../more-references/books.html">W. Richard Stevens の UNIX Network Programming books</a> で解決されるでしょう。また、<a href="http://www.unpbook.com/src.html">オンラインの Stevens の UNIX Network Programming</a> のソースコードの <code>ping/</code> サブディレクトリも見てみてください。</p>
<h3 id="88-connect-の呼び出しのタイムアウトを変更または短縮するにはどうすればよいですか"><a class="header" href="#88-connect-の呼び出しのタイムアウトを変更または短縮するにはどうすればよいですか">8.8 <code>connect()</code> の呼び出しのタイムアウトを変更または短縮するにはどうすればよいですか？</a></h3>
<p>W. Richard Stevens と全く同じ答えを出すのではなく、<a href="http://www.unpbook.com/src.html">UNIX Network Programming のソースコードにある <code>lib/connect_nonb.c</code></a> を参照することにしましょう。</p>
<p>その要点は、<code>socket()</code> でソケット記述子を作成し、<a href="common-questions/../slightly-advanced-techniques/blocking.html">それをノンブロッキングに設定</a>して <code>connect()</code> を呼び、すべてがうまくいけば <code>connect()</code> は直ちに <code>-1</code> を返して <code>errno</code> は <code>EINPROGRESS</code> に設定されるということです。その後、好きなタイムアウトで <a href="common-questions/../slightly-advanced-techniques/select-synchronous-io-multiplexing-old-school.html"><code>select()</code></a> を呼び出し、ソケット記述子をリードとライトの両方で渡します。タイムアウトしなければ、<code>connect()</code> の呼び出しが完了したことになります。このとき、<code>getsockopt()</code> に <code>SO_ERROR</code> オプションをつけて <code>connect()</code> 呼び出しからの戻り値を取得する必要があります（エラーがなければ <code>0</code> になるはずです）。</p>
<p>最後に、データ転送を開始する前に、ソケットを再びブロッキングに設定する必要があります。</p>
<p>この方法には、接続中に何か他のことをすることができるという利点もあることに注意してください。例えば、タイムアウトを 500ms のような低い値に設定し、タイムアウトするたびに画面上のインジケータを更新し、それから再び <code>select() </code> を呼び出すことができます。例えば、<code>select()</code> を20回ほど呼び出してタイムアウトしたら、そろそろ接続をあきらめる時期だとわかるでしょう。</p>
<p>私が言ったように、スティーブンスのソースに完璧に優れた例があるので、チェックしてみてください。</p>
<h3 id="89-windows-用にビルドするにはどうしたらいいですか"><a class="header" href="#89-windows-用にビルドするにはどうしたらいいですか">8.9 Windows 用にビルドするにはどうしたらいいですか？</a></h3>
<p>まず、Windows を削除し、Linux または BSD をインストールします。<code>};-)</code>。いや、実際には、導入部の <a href="common-questions/../intro/note-for-windows-programmers.html">Windows 用のビルドの章</a>を見ればいいんですけどね。</p>
<h3 id="810-solarissunos-用にビルドするにはどうしたらいいですかコンパイルしようとするとリンカエラーが出ます"><a class="header" href="#810-solarissunos-用にビルドするにはどうしたらいいですかコンパイルしようとするとリンカエラーが出ます">8.10 Solaris/SunOS 用にビルドするにはどうしたらいいですか？コンパイルしようとするとリンカエラーが出ます！</a></h3>
<p>リンカーエラーは、Sun ボックスがソケットライブラリを自動的にコンパイルしないために起こります。この方法の例については、導入部の <a href="common-questions/../intro/note-for-solaris-sunos-programmers.html">Solaris/SunOS 用のビルドに関する章</a> を参照してください。</p>
<h3 id="811-select-がシグナルで落ち続けるのはなぜか"><a class="header" href="#811-select-がシグナルで落ち続けるのはなぜか">8.11 <code>select()</code> がシグナルで落ち続けるのはなぜか？</a></h3>
<p>シグナルはブロックされたシステムコールに <code>-1</code> を返し、<code>errno</code> に <code>EINTR</code> をセットする傾向があります。<code>sigaction()</code> でシグナルハンドラをセットアップするときに、フラグ <code>SA_RESTART</code> を設定することができます。これは、システムコールが中断された後に再開することを想定したものです。</p>
<p>当然ながら、いつもうまくいくわけではありません。</p>
<p>私のお気に入りの解決策は、<code>goto</code> ステートメントを使うことです。これは教授をイライラさせるだけなので、ぜひやってみてください。</p>
<pre><code class="language-c">select_restart:
if ((err = select(fdmax+1, &amp;readfds, NULL, NULL, NULL)) == -1) {
    if (errno == EINTR) {
        // some signal just interrupted us, so restart
        goto select_restart;
    }
    // handle the real error here:
    perror(&quot;select&quot;);
}
</code></pre>
<p>もちろん、この場合は <code>goto</code> を使う必要はありません。他の構造体を使用して制御することができます。しかし、私は <code>goto</code> 文の方が実際きれいだと思うんです。</p>
<h3 id="812-recv-の呼び出しにタイムアウトを実装するにはどうすればよいですか"><a class="header" href="#812-recv-の呼び出しにタイムアウトを実装するにはどうすればよいですか">8.12 <code>recv()</code> の呼び出しにタイムアウトを実装するにはどうすればよいですか？</a></h3>
<p><a href="common-questions/../slightly-advanced-techniques/select-synchronous-io-multiplexing-old-school.html"><code>select()</code></a>を使いましょう！これは、読み込みたいソケット記述子に対して、タイムアウトパラメータを指定することができます。あるいは、このように関数全体を一つの関数で包むこともできます。</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int recvtimeout(int s, char *buf, int len, int timeout)
{
    fd_set fds;
    int n;
    struct timeval tv;

    // set up the file descriptor set
    FD_ZERO(&amp;fds);
    FD_SET(s, &amp;fds);

    // set up the struct timeval for the timeout
    tv.tv_sec = timeout;
    tv.tv_usec = 0;

    // wait until timeout or data received
    n = select(s+1, &amp;fds, NULL, NULL, &amp;tv);
    if (n == 0) return -2; // timeout!
    if (n == -1) return -1; // error

    // data must be here, so do a normal recv()
    return recv(s, buf, len, 0);
}
.
.
.
// Sample call to recvtimeout():
n = recvtimeout(s, buf, sizeof buf, 10); // 10 second timeout

if (n == -1) {
    // error occurred
    perror(&quot;recvtimeout&quot;);
}
else if (n == -2) {
    // timeout occurred
} else {
    // got some data in buf
}
.
.
.
</code></pre>
<p><code>recvtimeout()</code> はタイムアウトした場合、<code>-2</code> を返すことに注意してください。なぜ <code>0</code> を返さないのでしょうか？そうですね、思い出してみてください、<code>recv()</code> を呼び出したときに <code>0</code> という値が返ってきたら、リモート側が接続を閉じたことを意味します。そのため、この戻り値はすでに話されており、<code>-1</code> は &quot;error&quot; を意味します。そこで、タイムアウトのインジケータとして <code>-2</code> を選択しました。</p>
<h3 id="813-ソケットで送信する前にデータを暗号化または圧縮するにはどうすればよいですか"><a class="header" href="#813-ソケットで送信する前にデータを暗号化または圧縮するにはどうすればよいですか">8.13 ソケットで送信する前にデータを暗号化または圧縮するにはどうすればよいですか？</a></h3>
<p>暗号化を行う簡単な方法として、SSL（セキュア・ソケット・レイヤー）を使用する方法がありますが、このガイドの範囲を超えています。（詳しくは <a href="https://www.openssl.org/">OpenSSL プロジェクト</a>を見てください。）</p>
<p>しかし、独自のコンプレッサーや暗号化システムを導入する場合は、データが両端間で一連のステップを通過すると考えればよいのです。各ステップは、何らかの形でデータを変更します。</p>
<ol>
<li>サーバがファイルやどこからでもデータを読み取ります。</li>
<li>サーバがデータを暗号化・圧縮します（この部分を追加します）。</li>
<li>サーバが暗号化されたデータを <code>send()</code> します。</li>
</ol>
<p>今度はその逆です。</p>
<ol>
<li>クライアントが暗号化されたデータを <code>recv()</code> します。</li>
<li>クライアントがデータを復号・伸張します（この部分はあなたが追加します）。</li>
<li>クライアントがデータをファイル（または任意の場所）に書き込みます。</li>
</ol>
<p>圧縮して暗号化するなら、最初に圧縮することだけは忘れないでください。<code>:-)</code></p>
<p>ただ、サーバがやったことをクライアントがきちんと元に戻してくれれば、いくら中間ステップを追加しても、最終的にはデータは大丈夫です。</p>
<p>つまり、私のコードを使うために必要なことは、データが読み込まれる場所と、ネットワーク上で（<code>send()</code> を使って）データが送信される場所の間にある場所を見つけ、そこに暗号化を行うコードを貼り付けるだけです。</p>
<h3 id="814-pf_inet-をずっと見ているのですがこれは何ですかaf_inetと関係があるのでしょうか"><a class="header" href="#814-pf_inet-をずっと見ているのですがこれは何ですかaf_inetと関係があるのでしょうか">8.14 &quot;<code>PF_INET</code>&quot; をずっと見ているのですが、これは何ですか？<code>AF_INET</code>と関係があるのでしょうか？</a></h3>
<p>はい、そうです。詳しくは <a href="common-questions/../system-calls-or-bust/socket-get-the-file-descriptor.html"><code>socket()</code> の章</a>を参照してください。</p>
<h3 id="815-クライアントからシェルコマンドを受け取って実行するサーバを書くにはどうしたらいいでしょうか"><a class="header" href="#815-クライアントからシェルコマンドを受け取って実行するサーバを書くにはどうしたらいいでしょうか">8.15 クライアントからシェルコマンドを受け取って実行するサーバを書くにはどうしたらいいでしょうか？</a></h3>
<p>簡単のために、クライアントが <code>connect()</code>s, <code>send()</code>s, <code>close()</code>s で接続したとしましょう（つまり、クライアントが再び接続しない限り、その後のシステムコールはありません）。</p>
<p>クライアントがたどるプロセスはこうです。</p>
<ol>
<li>サーバに <code>connect()</code> します。</li>
<li><code>send(&quot;/sbin/ls &gt; /tmp/client.out&quot;)</code></li>
<li>接続を <code>close()</code> します。</li>
</ol>
<p>一方、サーバはデータを処理し、実行します。</p>
<ol>
<li>クライアントからの接続を <code>accept()</code> します。</li>
<li>コマンド文字列を <code>recv(str)</code> します。</li>
<li>接続を <code>close()</code> します。</li>
<li><code>system(str)</code> を使ってコマンドを実行します。</li>
</ol>
<p>ご注意ください！サーバがクライアントの言うことを実行することは、リモートシェルアクセスを与えるようなもので、サーバに接続すると、あなたのアカウントに何かすることができます。例えば、上記の例で、クライアントが &quot;<code>rm -rf ~</code>&quot; と送ったらどうでしょう？それはあなたのアカウント内のすべてを削除してしまいます。</p>
<p>そこで、賢明にも、<code>foobar</code> ユーティリティのような、安全だとわかっているいくつかのユーティリティを除いて、クライアントが何も使えないようにするのです。</p>
<pre><code class="language-c">if (!strncmp(str, &quot;foobar&quot;, 6)) {
    sprintf(sysstr, &quot;%s &gt; /tmp/server.out&quot;, str);
    system(sysstr);
}
</code></pre>
<p>しかし、残念ながらまだ安全ではありません。クライアントが &quot;<code>foobar; rm -rf ~</code>&quot; と入力したらどうでしょうか。最も安全なのは、コマンドの引数に含まれるすべての非英数字（適切であればスペースを含む）の前にエスケープ文字（&quot;<code>\</code>&quot;）を置く小さなルーチンを書くことです。</p>
<p>このように、クライアントが送信したものをサーバが実行し始めると、セキュリティはかなり大きな問題になります。</p>
<h3 id="816-slew-でデータを送っているのですがrecv-すると一度に-536-バイトか-1460-バイトしか受信できませんしかし私のローカルマシンで実行するとすべてのデータを同時に受信することができますどうなっているのでしょうか"><a class="header" href="#816-slew-でデータを送っているのですがrecv-すると一度に-536-バイトか-1460-バイトしか受信できませんしかし私のローカルマシンで実行するとすべてのデータを同時に受信することができますどうなっているのでしょうか">8.16 slew でデータを送っているのですが、<code>recv()</code> すると、一度に 536 バイトか 1460 バイトしか受信できません。しかし、私のローカルマシンで実行すると、すべてのデータを同時に受信することができます。どうなっているのでしょうか？</a></h3>
<p>物理媒体が処理できる最大サイズであるMTUに当たっています。ローカルマシンでは、8K 以上を問題なく処理できるループバックデバイスを使用しています。しかし、Ethernet では、ヘッダーを含めて 1500 バイトしか扱えないので、その限界にぶつかってしまうのです。モデムでは、576 MTU（これもヘッダ付き）で、さらに低い制限にぶつかります。</p>
<p>まず、すべてのデータが送信されていることを確認する必要があります。（詳しくは <a href="common-questions/../slightly-advanced-techniques/handling-partial-sends.html"><code>sendall()</code></a> 関数の実装を参照してください。）それが確認できたら、すべてのデータが読み込まれるまで、ループで <code>recv()</code> を呼び出す必要があります。</p>
<p><code>recv()</code> を複数回呼び出して完全なデータパケットを受信する方法については、<a href="common-questions/../slightly-advanced-techniques/son-of-data-encapsulation.html">7.6 データカプセル化の子</a> の章を読んでください。</p>
<h3 id="817-私は-windows-マシンを使っていますがfork-システムコールも-struct-sigaction-のようなものも持っていませんどうしたらいいでしょうか"><a class="header" href="#817-私は-windows-マシンを使っていますがfork-システムコールも-struct-sigaction-のようなものも持っていませんどうしたらいいでしょうか">8.17 私は Windows マシンを使っていますが、<code>fork()</code> システムコールも <code>struct sigaction</code> のようなものも持っていません。どうしたらいいでしょうか？</a></h3>
<p>もし、どこかにあるとすれば、コンパイラに同梱されているであろう POSIX ライブラリでしょう。私は Windows を持っていないので、答えようがないのですが、Microsoft には POSIX 互換性レイヤーがあり、そこに <code>fork()</code> があるように記憶しています。（そして多分、<code>sigaction</code> も。）</p>
<p>VC++ 付属のヘルプで &quot;fork&quot; または &quot;POSIX&quot; を検索して、何か手がかりがないか見てみてください。</p>
<p>もし、それでうまくいかない場合は、<code>fork()</code>/<code>sigaction</code> を捨てて、Win32 の <code>CreateProcess()</code> に置き換えてください。私は <code>CreateProcess()</code> の使い方を知りません。引数をたくさん取りますが、VC++ に付属するドキュメントに記載されているはずです。</p>
<h3 id="818-ファイアウォールの内側にいるのですがファイアウォールの外側にいる人に私の-ip-アドレスを知らせて私のマシンに接続できるようにするにはどうしたらよいでしょうか"><a class="header" href="#818-ファイアウォールの内側にいるのですがファイアウォールの外側にいる人に私の-ip-アドレスを知らせて私のマシンに接続できるようにするにはどうしたらよいでしょうか">8.18 ファイアウォールの内側にいるのですが、ファイアウォールの外側にいる人に私の IP アドレスを知らせて、私のマシンに接続できるようにするにはどうしたらよいでしょうか？</a></h3>
<p>残念ながら、ファイアウォールの目的は、ファイアウォール外の人がファイアウォール内のマシンに接続するのを防ぐことなので、それを許可することは基本的にセキュリティ違反とみなされます。</p>
<p>これは、すべてが失われたということではありません。ひとつには、ファイアウォールがマスカレードやNATのようなことを行っている場合、しばしば <code>connect()</code> を通して接続することができます。自分が常に接続を開始するようにプログラムを設計すれば、うまくいくでしょう。</p>
<p>もしそれで満足できないなら、システム管理者に頼んでファイアウォールに穴を開けてもらい、人々があなたに接続できるようにすることができます。ファイアウォールは NAT ソフトウェアやプロキシなどを通して、あなたに転送することができます。</p>
<p>ファイアウォールの穴は、決して軽視できないものであることを認識しておいてください。悪い人が内部ネットワークにアクセスできないようにしなければなりません。初心者の場合、ソフトウェアを安全にするのは想像以上に難しいのです。</p>
<p>シスアドを怒らせないようにね。<code>;-)</code></p>
<h3 id="819-パケットスニファーの書き方を教えてくださいイーサネットインタフェースをプロミスキャスモードにするにはどうしたらよいですか"><a class="header" href="#819-パケットスニファーの書き方を教えてくださいイーサネットインタフェースをプロミスキャスモードにするにはどうしたらよいですか">8.19 パケットスニファーの書き方を教えてください。イーサネットインタフェースをプロミスキャスモードにするにはどうしたらよいですか?</a></h3>
<p>ネットワークカードが&quot;プロミスカスモード&quot;の場合、このマシン宛のパケットだけでなく、すべてのパケットをオペレーティングシステムに転送することをご存じない方のために説明します。（しかし、イーサネットは IP より下位の層なので、すべての IP アドレスは効果的に転送されます。より詳しくは、<a href="common-questions/../what-is-a-socket/low-level-nonsense-and-network-theory.html">2.2 低レベルのナンセンスとネットワーク理論</a> の章をご覧ください。）</p>
<p>これは、パケットスニファーの仕組みの基本です。インターフェイスをプロミスカスモードにし、OSはワイヤー上を通過するすべてのパケットを取得します。 このデータを読むために、ある種のソケットを持っているはずです。</p>
<p>残念ながら、その答えはプラットフォームによって異なりますが、例えば &quot;windows promiscuous ioctl&quot; でググれば、おそらくどこかにたどり着けるはずです。Linux の場合は、<a href="https://stackoverflow.com/questions/21323023/sniffing-an-ethernet-interface-on-linux">Stack Overflow のスレッド</a>にも有用そうなものがあります。</p>
<h3 id="820-tcpudp-ソケットにカスタムタイムアウト値を設定するにはどうすればよいですか"><a class="header" href="#820-tcpudp-ソケットにカスタムタイムアウト値を設定するにはどうすればよいですか">8.20 TCP/UDP ソケットにカスタムタイムアウト値を設定するにはどうすればよいですか？</a></h3>
<p>お使いのシステムに依存します。ネットで <code>SO_RCVTIMEO</code> や <code>SO_SNDTIMEO</code>（<code>setsockopt()</code> で使用）を検索して、あなたのシステムがその機能をサポートしているかどうかを確認するとよいでしょう。</p>
<p>Linux のマニュアルでは，<code>alarm()</code> や <code>setitimer()</code> で代用することを勧めています．</p>
<h3 id="821-どのポートが使用可能かどうすれば分かりますか公式なポート番号の一覧はありますか"><a class="header" href="#821-どのポートが使用可能かどうすれば分かりますか公式なポート番号の一覧はありますか">8.21 どのポートが使用可能か、どうすれば分かりますか？&quot;公式&quot;なポート番号の一覧はありますか？</a></h3>
<p>通常、これは問題ではありません。もしあなたが、例えばウェブサーバを書いているのであれば、よく知られているポート 80 をあなたのソフトウェアに使用するのは良い考えです。もし、自分専用のサーバを書くのであれば、適当にポートを選んで（ただし 1023 より大きい）試してみてください。</p>
<p>そのポートがすでに使われている場合、<code>bind()</code> しようとすると &quot;Address already in use&quot; というエラーが表示されます。他のポートを選んでください。（ソフトウェアのユーザが、設定ファイルやコマンドラインスイッチで別のポートを指定できるようにしておくとよいでしょう。）</p>
<p>IANA（Internet Assigned Numbers Authority）が管理している<a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">公式ポート番号一覧</a>があります。そのリストにあるもの（1023 以上）があるからといって、そのポートを使ってはいけないというわけではありません。例えば、Id Software 社の DOOM は、それが何であれ、&quot;mdqs&quot; と同じポートを使っています。重要なのは、あなたがそのポートを使いたいときに、同じマシンの他の誰もそのポートを使っていないことです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-man-ページ"><a class="header" href="#9-man-ページ">9 Man ページ</a></h1>
<p>Unix の世界では、マニュアルがたくさんあります。それらのマニュアルには、自由に使える個々の機能を説明する小さな章があります。</p>
<p>もちろん、<code>manual</code> は入力するのが面倒でしょう。つまり、私を含め、Unix の世界では誰もそんなにタイプするのが好きではないのです。実際、私はどれだけ簡潔であることを好むかについて長々と語ることもできますが、その代わりに、事実上すべての状況において私がどれだけ全く驚くほど簡潔であることを好むかについて、長ったらしい放談であなたを退屈させないように簡潔に語ることにします。</p>
<p><em>[拍手喝采]</em></p>
<p>ありがとうございます。私が言いたいのは、このようなページは Unix の世界では &quot;man ページ&quot;と呼ばれ、私はここに私なりに切り詰めた man ページを載せて、皆さんに読んで楽しんでもらおうということなのです。これらの関数の多くは、私が言っているよりもずっと汎用的なものですが、ここではインターネットソケットプログラミングに関連する部分のみを紹介するつもりです。</p>
<p>しかし、お待ちを！私の man ページの悪いところはそれだけではありません。</p>
<ul>
<li>ガイドに記載されている基本的なことしか書かれていない不完全なものです。</li>
<li>実際の世界には、これ以外にも多くのマニュアルページが存在します。</li>
<li>ご使用のシステムとは異なります。</li>
<li>ヘッダーファイルは、お使いのシステムの関数によって異なる場合があります。</li>
<li>お使いのシステムによっては、関数パラメータが異なる場合があります。</li>
</ul>
<p>もし本当の情報が欲しいなら、ローカルの Unix man ページで <code>man whatever</code> と入力してチェックしてください。ここで、&quot;whatever&quot; は &quot;<code>accept</code>&quot; のような、信じられないほど興味のあるものです。（Microsoft Visual Studio のヘルプセクションにも同じようなものがあると思います。しかし、&quot;man&quot; の方が &quot;help&quot; よりも1バイト簡潔で良いのです。またもや Unix の勝利！）</p>
<p>では、もしこれらに欠陥があるのなら、なぜガイドに掲載するのでしょうか？理由はいくつかありますが、一番の理由は、(a) これらのバージョンはネットワーク・プログラミングに特化しており、実際のものよりも消化しやすいこと、(b) これらのバージョンには例が含まれていることです。</p>
<p>あ！あと、例題といえば、エラーチェックは、コードが長くなってしまうので、あまり入れないようにしています。でも、100% 失敗しないという確信がない限り、システムコールをするときは必ずエラーチェックをした方がいいです。それでもしたほうがいいです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="91-accept"><a class="header" href="#91-accept">9.1 <code>accept()</code></a></h1>
<p>リスニング中のソケットで着信接続を承認します。</p>
<h3 id="911-書式"><a class="header" href="#911-書式">9.1.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int s, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>
<h3 id="912-解説"><a class="header" href="#912-解説">9.1.2 解説</a></h3>
<p>一旦、 <code>SOCK_STREAM</code> ソケットを取得して、 <code>listen()</code> で着信接続のための設定を行うという手間をかけると、そのソケットを使用することができます。次に <code>accept()</code> を呼び出して、新しく接続したクライアントとの通信に使用する新しいソケット記述子を実際に取得します。</p>
<p>リスニングに使用している古いソケットはまだ残っています。そして、さらに <code>accept()</code> を呼び出す際に使用されます。</p>
<table><thead><tr><th>パラメータ</th><th>説明</th></tr></thead><tbody>
<tr><td><code>s</code></td><td><code>listen()</code> 中のソケット記述子。</td></tr>
<tr><td><code>addr</code></td><td>ここには、接続先のサイトのアドレスが記入されています。</td></tr>
<tr><td><code>addrlen</code></td><td>これは <code>addr</code> パラメータで返された構造体の <code>sizeof()</code> で埋められています。これは <code>addr</code> に渡された型なので、 <code>struct sockaddr_in</code> が返ってきたと仮定すれば、安全に無視することができます。</td></tr>
</tbody></table>
<p><code>accept()</code> は通常ブロックされますが、<code>select()</code> を使用して、リスニング中のソケット記述子が &quot;ready to read&quot; になっているかどうかを前もって確認することができます。もしそうなら、新しい接続が <code>accept()</code> を待っていることになります！やったー！あるいは、<code>fcntl()</code> を使って、リスニング中のソケットに <code>O_NONBLOCK</code> フラグを設定することもできます。そうすると、決してブロックせず、代わりに <code>errno</code> を <code>EWOULDBLOCK</code> に設定して <code>-1</code> を返します。</p>
<p><code>accept()</code> が返すソケット記述子は、正真正銘のソケット記述子であり、リモートホストに開いて接続されています。それを使い終わったら <code>close()</code> しなければなりません。</p>
<h3 id="913-返り値"><a class="header" href="#913-返り値">9.1.3 返り値</a></h3>
<p><code>accept()</code> は新しく接続されたソケット記述子を返すが、エラーの場合は <code>-1</code> を返し、 <code>errno</code> は適切に設定されます。</p>
<h3 id="914-例"><a class="header" href="#914-例">9.1.4 例</a></h3>
<pre><code class="language-c">struct sockaddr_storage their_addr;
socklen_t addr_size;
struct addrinfo hints, *res;
int sockfd, new_fd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

// make a socket, bind it, and listen on it:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
listen(sockfd, BACKLOG);

// now accept an incoming connection:

addr_size = sizeof their_addr;
new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

// ready to communicate on socket descriptor new_fd!
</code></pre>
<h3 id="915-参照"><a class="header" href="#915-参照">9.1.5 参照</a></h3>
<p><a href="man-pages/./socket.html"><code>socket()</code></a>,
<a href="man-pages/./getaddrinfo-freeaddrinfo-gai_strerror.html"><code>getaddrinfo()</code></a>,
<a href="man-pages/./listen.html"><code>listen()</code></a>,
<a href="man-pages/./struct-sockaddr-and-pals.html"><code>struct sockaddr_in</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="92-bind"><a class="header" href="#92-bind">9.2 <code>bind()</code></a></h1>
<p>ソケットをIPアドレスとポート番号に関連付けます。</p>
<h3 id="921-書式"><a class="header" href="#921-書式">9.2.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen);
</code></pre>
<h3 id="922-解説"><a class="header" href="#922-解説">9.2.2 解説</a></h3>
<p>リモートマシンがあなたのサーバプログラムに接続しようとするとき、IPアドレスとポート番号という2つの情報が必要です。<code>bind()</code>の呼び出しによって、まさにそれが可能になります。</p>
<p>まず、<code>getaddrinfo()</code> を呼び出して、宛先アドレスとポート情報を持つ <code>struct sockaddr</code> をロードします。それから <code>socket()</code> を呼んでソケット記述子を取得し、ソケットとアドレスを <code>bind()</code> に渡すと、IP アドレスとポートが魔法のように（実際の魔法を使って）ソケットにバインドされるのです！</p>
<p>IP アドレスを知らない場合、あるいはマシンに IP アドレスが 1 つしかないことが分かっている場合、あるいはマシンの IP アドレスがどれでも構わない場合は、<code>getaddrinfo()</code> の <code>hints</code> パラメータに <code>AI_PASSIVE</code> フラグを渡すだけでよいでしょう。これは <code>struct sockaddr</code> の IP アドレス部分を特別な値で埋めるもので、<code>bind()</code> に対して、このホストの IP アドレスを自動的に埋めるように指示するものです。</p>
<p>何、何？現在のホストのアドレスを自動入力するために、<code>struct sockaddr</code> の IP アドレスにどんな特別な値が読み込まれているのでしょうか？もしそうでなければ、上記のように <code>getaddrinfo()</code> からの結果を使用してください。IPv4 では、<code>struct sockaddr_in</code> 構造体の <code>sin_addr.s_addr</code> フィールドは <code>INADDR_ANY</code> に設定されます。IPv6 では、<code>struct sockaddr_in6</code> 構造体の <code>sin6_addr</code> フィールドは、グローバル変数 <code>in6addr_any</code> から代入されます。また、新しい <code>struct in6_addr</code> を宣言する場合は、<code>IN6ADDR_ANY_INIT</code> で初期化することができます。</p>
<p>最後に、<code>addrlen</code> パラメータに <code>sizeof my_addr</code> を設定します。</p>
<h3 id="923-返り値"><a class="header" href="#923-返り値">9.2.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<h3 id="924-例"><a class="header" href="#924-例">9.2.4 例</a></h3>
<pre><code class="language-c">// modern way of doing things with getaddrinfo()

struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:
// (you should actually walk the &quot;res&quot; linked list and error-check!)

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<pre><code class="language-c">// example of packing a struct by hand, IPv4

struct sockaddr_in myaddr;
int s;

myaddr.sin_family = AF_INET;
myaddr.sin_port = htons(3490);

// you can specify an IP address:
inet_pton(AF_INET, &quot;63.161.169.137&quot;, &amp;(myaddr.sin_addr));

// or you can let it automatically select one:
myaddr.sin_addr.s_addr = INADDR_ANY;

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;myaddr, sizeof myaddr);
</code></pre>
<h3 id="925-参照"><a class="header" href="#925-参照">9.2.5 参照</a></h3>
<p><a href="man-pages/./getaddrinfo-freeaddrinfo-gai_strerror.html"><code>getaddrinfo()</code></a>,
<a href="man-pages/./socket.html"><code>socket()</code></a>,
<a href="man-pages/./struct-sockaddr-and-pals.html"><code>struct sockaddr_in</code></a>,
<a href="man-pages/./struct-sockaddr-and-pals.html"><code>struct in_addr</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="93-connect"><a class="header" href="#93-connect">9.3 <code>connect()</code></a></h1>
<p>サーバにソケットを接続します。</p>
<h3 id="931-書式"><a class="header" href="#931-書式">9.3.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, const struct sockaddr *serv_addr,
            socklen_t addrlen);
</code></pre>
<h3 id="932-解説"><a class="header" href="#932-解説">9.3.2 解説</a></h3>
<p><code>socket()</code> コールでソケット記述子を構築したら、<code>connect()</code> システムコールを使って、そのソケットをリモートサーバに接続することができます。必要なことは、ソケット記述子と、もっとよく知りたいと思うサーバのアドレスを渡すだけです。(それと、このような関数によく渡されるアドレスの長さも。)</p>
<p>通常、この情報は <code>getaddrinfo()</code> を呼び出した結果として得られますが、必要であれば自分自身で <code>struct sockaddr</code> を埋めることもできます。</p>
<p>ソケット記述子の <code>bind()</code> をまだ呼んでいない場合、ソケットは自動的にあなたの IP アドレスとランダムなローカルポートに束縛されます。サーバでない場合は、ローカルポートを気にする必要はなく、リモートポートを気にして <code>serv_addr</code> パラメータに設定するだけなので、通常はこれで十分です。クライアントソケットを特定の IP アドレスとポートにしたい場合は、<code>bind()</code> を呼び出すことができますが、これはかなりまれなケースです。</p>
<p>ソケットを <code>connect()</code> したら、あとは自由に <code>send()</code> や <code>recv()</code> をして、好きなだけデータを取り込めます。</p>
<p>特記事項：<code>SOCK_DGRAM</code> UDP ソケットをリモートホストに <code>connect()</code> した場合、<code>send()</code> と <code>recv()</code> だけでなく、<code>sendto()</code> と <code>recvfrom()</code> も使用できるようになります。もし必要なら。</p>
<h3 id="933-返り値"><a class="header" href="#933-返り値">9.3.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返す（それに応じて <code>errno</code> が設定されます）。</p>
<h3 id="934-例"><a class="header" href="#934-例">9.3.4 例</a></h3>
<pre><code class="language-c">// connect to www.example.com port 80 (http)

struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;

// we could put &quot;80&quot; instead on &quot;http&quot; on the next line:
getaddrinfo(&quot;www.example.com&quot;, &quot;http&quot;, &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// connect it to the address and port we passed in to getaddrinfo():

connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<h3 id="935-参照"><a class="header" href="#935-参照">9.3.5 参照</a></h3>
<p><a href="man-pages/./socket.html"><code>socket()</code></a>,
<a href="man-pages/./bind.html"><code>bind()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="94-close"><a class="header" href="#94-close">9.4 <code>close()</code></a></h1>
<p>ソケット記述子を閉じます。</p>
<h3 id="941-書式"><a class="header" href="#941-書式">9.4.1 書式</a></h3>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int close(int s);
</code></pre>
<h3 id="942-解説"><a class="header" href="#942-解説">9.4.2 解説</a></h3>
<p>ソケットを使い終えて、<code>send()</code> や <code>recv()</code> 、あるいはそれ以外のことを一切したくなくなったら、 <code>close()</code> をすれば、ソケットは解放され、二度と使われることはありません。</p>
<p>リモート側は、このような事態が発生したかどうかを、2つの方法のいずれかで判断することができます。1つ目は、リモート側が <code>recv()</code> を呼び出した場合、<code>0</code> を返します。2つ目は、リモート側が <code>send()</code> を呼び出した場合、シグナル <code>SIGPIPE</code> を受け取り、<code>send()</code> は <code>-1</code> を返し、<code>errno</code> は <code>EPIPE</code> にセットされます。</p>
<p><strong>Windowsユーザ</strong>：あなたが使うべき関数は <code>closesocket()</code> であって、<code>close()</code> ではありません。もし、ソケット記述子上で <code>close()</code> を使おうとすると、Windows が怒る可能性があります...。そして、怒られると嫌なものです。</p>
<h3 id="943-返り値"><a class="header" href="#943-返り値">9.4.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<h3 id="944-例"><a class="header" href="#944-例">9.4.4 例</a></h3>
<pre><code class="language-c">s = socket(PF_INET, SOCK_DGRAM, 0);
.
.
.
// a whole lotta stuff...*BRRRONNNN!*
.
.
.
close(s);  // not much to it, really.
</code></pre>
<h3 id="945-参照"><a class="header" href="#945-参照">9.4.5 参照</a></h3>
<p><a href="man-pages/./socket.html"><code>socket()</code></a>,
<a href="man-pages/./shutdown.html"><code>shutdown()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="95-getaddrinfo-freeaddrinfo-gai_strerror"><a class="header" href="#95-getaddrinfo-freeaddrinfo-gai_strerror">9.5 <code>getaddrinfo()</code>, <code>freeaddrinfo()</code>, <code>gai_strerror()</code></a></h1>
<p>ホスト名やサービスに関する情報を取得し、その結果を <code>struct sockaddr</code> にロードします。</p>
<h3 id="951-書式"><a class="header" href="#951-書式">9.5.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *nodename, const char *servname,
                const struct addrinfo *hints, struct addrinfo **res);

void freeaddrinfo(struct addrinfo *ai);

const char *gai_strerror(int ecode);

struct addrinfo {
  int     ai_flags;          // AI_PASSIVE, AI_CANONNAME, ...
  int     ai_family;         // AF_xxx
  int     ai_socktype;       // SOCK_xxx
  int     ai_protocol;       // 0 (auto) or IPPROTO_TCP, IPPROTO_UDP

  socklen_t  ai_addrlen;     // length of ai_addr
  char   *ai_canonname;      // canonical name for nodename
  struct sockaddr  *ai_addr; // binary address
  struct addrinfo  *ai_next; // next structure in linked list
};
</code></pre>
<h3 id="952-解説"><a class="header" href="#952-解説">9.5.2 解説</a></h3>
<p><code>getaddrinfo()</code> は特定のホスト名に関する情報（IPアドレスなど）を返し、<code>struct sockaddr</code> を読み込んで、細かい部分（IPv4かIPv6か）を処理してくれる優れた関数です。これは、古い関数である <code>gethostbyname()</code> と <code>getservbyname()</code> を置き換えるものです。以下の説明には、少し難しく感じるかもしれない多くの情報が含まれていますが、実際の使い方はとてもシンプルです。まずはサンプルを見てみるのもいいかもしれません。</p>
<p>興味のあるホスト名は <code>nodename</code> パラメータに入れます。アドレスは &quot;www.example.com&quot; のようなホスト名か、IPv4 または IPv6 のアドレス（文字列として渡される）のいずれかになります。このパラメータは、<code>AI_PASSIVE</code> フラグを使用している場合は <code>NULL</code> にすることもできます（下記参照）。</p>
<p><code>servname</code> パラメータは、基本的にポート番号です。ポート番号（&quot;80 &quot;のような文字列として渡される）、または &quot;http&quot;、&quot;tftp&quot;、&quot;smtp&quot;、&quot;pop&quot; などのサービス名であることができます。よく知られたサービス名は、<a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">IANA ポートリスト</a>や、<code>/etc/services</code> ファイルで見つけることができます。</p>
<p>最後に、入力パラメータとして <code>hints</code> があります。これは <code>getaddrinfo()</code> 関数が何をしようとしているかを定義する場所です。<code>memset()</code> で使用する前に、構造体全体をゼロにします。それでは、使用する前に設定する必要があるフィールドを見てみましょう。</p>
<p><code>ai_flags</code> には様々なものを設定することができますが、ここでは重要なものをいくつか紹介します。（複数のフラグを指定するには、<code>|</code> 演算子でビット単位の OR を指定します）。フラグの完全なリストについては、man ページをチェックしてください。</p>
<p><code>AI_CANONNAME</code> は、結果の <code>ai_canonname</code> をホストの標準的な（実際の）名前で埋め尽くすようにします。<code>AI_PASSIVE</code> は、結果の IP アドレスを <code>INADDR_ANY</code>（IPv4）または <code>in6addr_any</code>（IPv6）で埋めます。これにより、その後の <code>bind()</code> への呼び出しで、<code>struct sockaddr</code> の IP アドレスが現在のホストのアドレスで自動的に埋められるようになります。これは、アドレスをハードコードしたくない場合に、サーバをセットアップするのに優れています。</p>
<p>もし、<code>AI_PASSIVE</code> フラグを使用する場合は、<code>nodename</code> に <code>NULL</code> を渡すことができます（<code>bind()</code> が後でそれを埋めてくれるからです）。</p>
<p>続けて、入力パラメータについてですが、おそらく <code>ai_family</code> を <code>AF_UNSPEC</code> に設定すると、<code>getaddrinfo()</code> に IPv4 と IPv6 の両方のアドレスを検索させることができるようになります。また、<code>AF_INET</code> や <code>AF_INET6</code> でどちらか一方に限定することもできます。</p>
<p>次に、<code>socktype</code> フィールドを <code>SOCK_STREAM</code> または <code>SOCK_DGRAM</code> のどちらかに設定する必要があります。</p>
<p>最後に、<code>ai_protocol</code> を <code>0</code> にしておくと、自動的にプロトコルの種類が選択されます。</p>
<p>さて、このようなものを全部入れたら、いよいよ <code>getaddrinfo()</code> を呼び出すことができます！</p>
<p>もちろん、ここからが楽しいところです。<code>res</code> は <code>struct addrinfo</code> のリンクリストを指すようになり、このリストを通して、hints で渡したものと一致するすべてのアドレスを取得することができるようになります。</p>
<p>さて、何らかの理由で動作しないアドレスを取得することは可能です。Linux の man ページでは、<code>socket()</code> と <code>connect()</code>（または <code>AI_PASSIVE</code> フラグでサーバをセットアップしている場合は <code>bind()</code>）を成功するまで呼び出すリストをループしています。</p>
<p>最後に、リンクリストを使い終わったら、<code>freeaddrinfo()</code> を呼んでメモリを解放する必要があります （さもないと、メモリがリークしてしまい、Some People が怒ることになります）。</p>
<h3 id="953-返り値"><a class="header" href="#953-返り値">9.5.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーが発生した場合は <code>0</code> 以外を返します。非ゼロを返した場合、関数 <code>gai_strerror()</code> を用いて、エラーコードのプリント可能なバージョンを戻り値に含めることができる。</p>
<h3 id="954-例"><a class="header" href="#954-例">9.5.4 例</a></h3>
<pre><code class="language-c">// code for a client connecting to a server
// namely a stream socket to www.example.com on port 80 (http)
// either IPv4 or IPv6

int sockfd;
struct addrinfo hints, *servinfo, *p;
int rv;

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // use AF_INET6 to force IPv6
hints.ai_socktype = SOCK_STREAM;

if ((rv = getaddrinfo(&quot;www.example.com&quot;, &quot;http&quot;, &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
    exit(1);
}

// loop through all the results and connect to the first we can
for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
    if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
            p-&gt;ai_protocol)) == -1) {
        perror(&quot;socket&quot;);
        continue;
    }

    if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        perror(&quot;connect&quot;);
        close(sockfd);
        continue;
    }

    break; // if we get here, we must have connected successfully
}

if (p == NULL) {
    // looped off the end of the list with no connection
    fprintf(stderr, &quot;failed to connect\n&quot;);
    exit(2);
}

freeaddrinfo(servinfo); // all done with this structure
</code></pre>
<pre><code class="language-c">// code for a server waiting for connections
// namely a stream socket on port 3490, on this host's IP
// either IPv4 or IPv6.

int sockfd;
struct addrinfo hints, *servinfo, *p;
int rv;

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // use AF_INET6 to force IPv6
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE; // use my IP address

if ((rv = getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
    exit(1);
}

// loop through all the results and bind to the first we can
for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
    if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
            p-&gt;ai_protocol)) == -1) {
        perror(&quot;socket&quot;);
        continue;
    }

    if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        close(sockfd);
        perror(&quot;bind&quot;);
        continue;
    }

    break; // if we get here, we must have connected successfully
}

if (p == NULL) {
    // looped off the end of the list with no successful bind
    fprintf(stderr, &quot;failed to bind socket\n&quot;);
    exit(2);
}

freeaddrinfo(servinfo); // all done with this structure
</code></pre>
<h3 id="955-参照"><a class="header" href="#955-参照">9.5.5 参照</a></h3>
<p><a href="man-pages/./gethostbyname-gethostbyaddr.html"><code>gethostbyname()</code></a>,
<a href="man-pages/./getnameinfo.html"><code>getnameinfo()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="96-gethostname"><a class="header" href="#96-gethostname">9.6 <code>gethostname()</code></a></h1>
<p>システムの名称を返します。</p>
<h3 id="961-書式"><a class="header" href="#961-書式">9.6.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/unistd.h&gt;

int gethostname(char *name, size_t len);
</code></pre>
<h3 id="962-解説"><a class="header" href="#962-解説">9.6.2 解説</a></h3>
<p>あなたのシステムには名前がついています。みんなそうです。これは、今まで話してきた他のネットワーク的なものよりも、若干 Unix 的なものですが、それでも使い道はあります。</p>
<p>例えば、ホスト名を取得してから <code>gethostbyname()</code> を呼び出すと、IP アドレスを知ることができます。</p>
<p>パラメータ <code>name</code> はホスト名を格納するバッファを指し、<code>len</code> はそのバッファのサイズ（バイト）を表します。<code>gethostname()</code> はバッファの終端を上書きせず（エラーを返すかもしれませんし、単に書き込みを止めるかもしれません）、バッファに文字列のスペースがある場合は <code>NUL</code>-ターミネイトを行います。</p>
<h3 id="963-返り値"><a class="header" href="#963-返り値">9.6.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返す（それに応じて <code>errno</code> が設定されます）。</p>
<h3 id="964-例"><a class="header" href="#964-例">9.6.4 例</a></h3>
<pre><code class="language-c">char hostname[128];

gethostname(hostname, sizeof hostname);
printf(&quot;My hostname: %s\n&quot;, hostname);
</code></pre>
<h3 id="965-参照"><a class="header" href="#965-参照">9.6.5 参照</a></h3>
<p><a href="man-pages/./gethostbyname-gethostbyaddr.html"><code>gethostbyname()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="97-gethostbyname-gethostbyaddr"><a class="header" href="#97-gethostbyname-gethostbyaddr">9.7 <code>gethostbyname()</code>, <code>gethostbyaddr()</code></a></h1>
<p>ホスト名に対するIPアドレスの取得、またはその逆を行います。</p>
<h3 id="971-書式"><a class="header" href="#971-書式">9.7.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

struct hostent *gethostbyname(const char *name); // DEPRECATED!
struct hostent *gethostbyaddr(const char *addr, int len, int type);
</code></pre>
<h3 id="972-解説"><a class="header" href="#972-解説">9.7.2 解説</a></h3>
<p>注意：この2つの関数は <code>getaddrinfo()</code> と <code>getnameinfo()</code> に取って代わられています！特に、<code>gethostbyname()</code> は IPv6 ではうまく動きません。</p>
<p>これらの関数は、ホスト名と IP アドレスの間を行き来します。例えば、&quot;www.example.com&quot; があれば、 <code>gethostbyname()</code> を使ってその IP アドレスを取得し、<code>struct in_addr</code> に格納することができます。</p>
<p>逆に、<code>struct in_addr</code> や <code>struct in6_addr</code> があれば、<code>gethostbyaddr()</code> を使用してホスト名を取得することができます。<code>gethostbyaddr()</code> は IPv6 互換ですが、より新しいピカピカな <code>getnameinfo()</code> を代わりに使用すべきです。</p>
<p>（ホスト名を調べたい IP アドレスをドットアンドナンバー形式で表した文字列がある場合、<code>AI_CANONNAME</code> フラグを指定して <code>getaddrinfo()</code> を使った方がよいでしょう。）</p>
<p><code>gethostbyname()</code> は &quot;www.yahoo.com&quot; のような文字列を受け取り、IP アドレスを含む膨大な情報を含む <code>struct hostent</code> を返します。（他の情報は、正式なホスト名、エイリアスのリスト、アドレスの種類、アドレスの長さ、そしてアドレスのリストです---これは汎用の構造体で、一度方法を見れば我々の特定の目的のために使うのはかなり簡単です。）</p>
<p><code>gethostbyaddr()</code> は <code>struct in_addr</code> または <code>struct in6_addr</code> を受け取って、対応するホスト名を表示します（もし存在すれば）。したがって、<code>gethostbyname()</code> の逆バージョンということになります。パラメータについては、 <code>addr</code> は <code>char*</code>、実際には <code>struct in_addr</code> へのポインタを渡したいのです。<code>len</code> は <code>sizeof(struct in_addr)</code> で、<code>type</code> は <code>AF_INET</code> であるべきです。</p>
<p>では、返される <code>struct hostent</code> とは何なのでしょうか？これは、問題のホストに関する情報を含むいくつかのフィールドを持っています。</p>
<table><thead><tr><th>Field</th><th>解説</th></tr></thead><tbody>
<tr><td><code>char *h_name</code></td><td>実際の正規のホスト名。</td></tr>
<tr><td><code>char **h_aliases</code></td><td>配列でアクセスできるエイリアスのリスト--- 最後の要素は <code>NULL</code> です。</td></tr>
<tr><td><code>int h_addrtype</code></td><td>結果のアドレスの型。この目的のためには、本当は <code>AF_INET</code> でなければなりません。</td></tr>
<tr><td><code>int length</code></td><td>アドレスの長さをバイト数で表したもので、IP（バージョン4）アドレスの場合は4となります。</td></tr>
<tr><td><code>char **h_addr_list</code></td><td>このホストの IP アドレスのリスト。これは <code>char**</code> ですが、実際には <code>struct in_addr*</code> の配列で、偽装されています。配列の最後の要素は <code>NULL</code> です。</td></tr>
<tr><td><code>h_addr</code></td><td><code>h_addr_list[0]</code> の共通定義エイリアスです。もし、このホストの古い IP アドレスが欲しいだけなら（ええ、複数持つこともできます)、このフィールドを使えばいいのです。</td></tr>
</tbody></table>
<h3 id="973-返り値"><a class="header" href="#973-返り値">9.7.3 返り値</a></h3>
<p>成功すれば <code>struct hostent</code> へのポインタを、エラーなら <code>NULL</code> を返します。</p>
<p>通常の <code>perror()</code> やエラー報告に使うようなものの代わりに、これらの関数は <code>h_errno</code> という変数に並列の結果を持ち、<code>herror()</code> や <code>hstrerror()</code> という関数を使って表示することができるようになりました。 これらの関数は、通常の <code>errno</code>、<code>perror()</code>、<code>strerror()</code> 関数と同じように動作します。</p>
<h3 id="974-例"><a class="header" href="#974-例">9.7.4 例</a></h3>
<pre><code class="language-c">// THIS IS A DEPRECATED METHOD OF GETTING HOST NAMES
// use getaddrinfo() instead!

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int main(int argc, char *argv[])
{
    int i;
    struct hostent *he;
    struct in_addr **addr_list;

    if (argc != 2) {
        fprintf(stderr,&quot;usage: ghbn hostname\n&quot;);
        return 1;
    }

    if ((he = gethostbyname(argv[1])) == NULL) {  // get the host info
        herror(&quot;gethostbyname&quot;);
        return 2;
    }

    // print information about this host:
    printf(&quot;Official name is: %s\n&quot;, he-&gt;h_name);
    printf(&quot;    IP addresses: &quot;);
    addr_list = (struct in_addr **)he-&gt;h_addr_list;
    for(i = 0; addr_list[i] != NULL; i++) {
        printf(&quot;%s &quot;, inet_ntoa(*addr_list[i]));
    }
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<pre><code class="language-c">// THIS HAS BEEN SUPERCEDED
// use getnameinfo() instead!

struct hostent *he;
struct in_addr ipv4addr;
struct in6_addr ipv6addr;

inet_pton(AF_INET, &quot;192.0.2.34&quot;, &amp;ipv4addr);
he = gethostbyaddr(&amp;ipv4addr, sizeof ipv4addr, AF_INET);
printf(&quot;Host name: %s\n&quot;, he-&gt;h_name);

inet_pton(AF_INET6, &quot;2001:db8:63b3:1::beef&quot;, &amp;ipv6addr);
he = gethostbyaddr(&amp;ipv6addr, sizeof ipv6addr, AF_INET6);
printf(&quot;Host name: %s\n&quot;, he-&gt;h_name);
</code></pre>
<h3 id="975-参照"><a class="header" href="#975-参照">9.7.5 参照</a></h3>
<p><a href="man-pages/./getaddrinfo-freeaddrinfo-gai_strerror.html"><code>getaddrinfo()</code></a>,
<a href="man-pages/./getnameinfo.html"><code>getnameinfo()</code></a>,
<a href="man-pages/./gethostname.html"><code>gethostname()</code></a>,
<a href="man-pages/./errno.html"><code>errno</code></a>,
<a href="man-pages/./perror-strerror.html"><code>perror()</code></a>,
<a href="man-pages/./perror-strerror.html"><code>strerror()</code></a>,
<a href="man-pages/./struct-sockaddr-and-pals.html"><code>struct in_addr</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="98-getnameinfo"><a class="header" href="#98-getnameinfo">9.8 <code>getnameinfo()</code></a></h1>
<p>与えられた <code>struct sockaddr</code> のホスト名とサービス名の情報を検索します。</p>
<h3 id="981-書式"><a class="header" href="#981-書式">9.8.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getnameinfo(const struct sockaddr *sa, socklen_t salen,
                char *host, size_t hostlen,
                char *serv, size_t servlen, int flags);
</code></pre>
<h3 id="982-解説"><a class="header" href="#982-解説">9.8.2 解説</a></h3>
<p>この関数は <code>getaddrinfo()</code> の逆で、すでにロードされている <code>struct sockaddr</code> を受け取り、その名前とサービス名のルックアップを行う関数です。これは、古い <code>gethostbyaddr()</code> と <code>getservbyport()</code> 関数を置き換えるものです。</p>
<p><code>sa</code> パラメータに <code>struct sockaddr</code>（実際には <code>struct sockaddr_in</code> または <code>struct sockaddr_in6</code> をキャストしたもの）へのポインタを渡し、<code>salen</code> にその <code>struct</code> の長さを渡す必要があります。</p>
<p>結果として得られるホスト名とサービス名は、<code>host</code> と <code>serv</code> パラメータで指定された領域に書き込まれます。もちろん、これらのバッファの最大長を <code>hostlen</code> と <code>servlen</code> で指定する必要があります。</p>
<p>最後に、渡すことのできるフラグがいくつかありますが、ここでは良いものを2つ紹介します。<code>NI_NOFQDN</code> は <code>host</code> にドメイン名全体ではなく、ホスト名のみを含めるようにする。<code>NI_NAMEREQD</code> は、DNS ルックアップで名前が見つからない場合に、関数を失敗させます（このフラグを指定せず、名前が見つからない場合は、<code>getnameinfo()</code> が代わりに IP アドレスの文字列を <code>host</code> に格納します。）</p>
<p>いつも通り、ローカルの man ページで全容を確認してください。</p>
<h3 id="983-返り値"><a class="header" href="#983-返り値">9.8.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーが発生した場合は <code>0</code> 以外を返します。戻り値が <code>0</code> でない場合、それを <code>gai_strerror()</code> に渡すと、人間が読める文字列を得ることができます。詳しくは <code>getaddrinfo</code> を参照してください。</p>
<h3 id="984-例"><a class="header" href="#984-例">9.8.4 例</a></h3>
<pre><code class="language-c">struct sockaddr_in6 sa; // could be IPv4 if you want
char host[1024];
char service[20];

// pretend sa is full of good information about the host and port...

getnameinfo(&amp;sa, sizeof sa, host, sizeof host, service, sizeof service, 0);

printf(&quot;   host: %s\n&quot;, host);    // e.g. &quot;www.example.com&quot;
printf(&quot;service: %s\n&quot;, service); // e.g. &quot;http&quot;
</code></pre>
<h3 id="985-参照"><a class="header" href="#985-参照">9.8.5 参照</a></h3>
<p><a href="man-pages/./getaddrinfo-freeaddrinfo-gai_strerror.html"><code>getaddrinfo()</code></a>,
<a href="man-pages/./gethostbyname-gethostbyaddr.html"><code>gethostbyaddr()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="99-getpeername"><a class="header" href="#99-getpeername">9.9 <code>getpeername()</code></a></h1>
<p>リモート側の接続に関するアドレス情報を返す。</p>
<h3 id="991-書式"><a class="header" href="#991-書式">9.9.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int getpeername(int s, struct sockaddr *addr, socklen_t *len);
</code></pre>
<h3 id="992-解説"><a class="header" href="#992-解説">9.9.2 解説</a></h3>
<p>リモート接続を <code>accept()</code> したり、サーバに <code>connect()</code> したら、今度はピアとして知られるものを手に入れます。ピアとは、単に接続先のコンピュータのことで、IP アドレスとポートで識別されます。つまり...</p>
<p><code>getpeername()</code> は単に、接続中のマシンに関する情報が詰まった <code>struct sockaddr_in</code> を返します。</p>
<p>なぜ&quot;名前&quot;なのか？このガイドで使っているようなインターネットソケットだけでなく、さまざまな種類のソケットがあるので、&quot;名前&quot;はすべてのケースをカバーする良い総称だったのです。この場合、相手の&quot;名前&quot;は相手の IP アドレスとポートです。</p>
<p>この関数は結果のアドレスのサイズを <code>len</code> で返しますが、<code>len</code> には <code>addr</code> のサイズをあらかじめ代入しておく必要があります。</p>
<h3 id="993-返り値"><a class="header" href="#993-返り値">9.9.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます。）</p>
<h3 id="994-例"><a class="header" href="#994-例">9.9.4 例</a></h3>
<pre><code class="language-c">// assume s is a connected socket

socklen_t len;
struct sockaddr_storage addr;
char ipstr[INET6_ADDRSTRLEN];
int port;

len = sizeof addr;
getpeername(s, (struct sockaddr*)&amp;addr, &amp;len);

// deal with both IPv4 and IPv6:
if (addr.ss_family == AF_INET) {
    struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;
    port = ntohs(s-&gt;sin_port);
    inet_ntop(AF_INET, &amp;s-&gt;sin_addr, ipstr, sizeof ipstr);
} else { // AF_INET6
    struct sockaddr_in6 *s = (struct sockaddr_in6 *)&amp;addr;
    port = ntohs(s-&gt;sin6_port);
    inet_ntop(AF_INET6, &amp;s-&gt;sin6_addr, ipstr, sizeof ipstr);
}

printf(&quot;Peer IP address: %s\n&quot;, ipstr);
printf(&quot;Peer port      : %d\n&quot;, port);
</code></pre>
<h3 id="995-参照"><a class="header" href="#995-参照">9.9.5 参照</a></h3>
<p><a href="man-pages/./gethostname.html"><code>gethostname()</code></a>,
<a href="man-pages/./gethostbyname-gethostbyaddr.html"><code>gethostbyname()</code></a>,
<a href="man-pages/./gethostbyname-gethostbyaddr.html"><code>gethostbyaddr()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="910-errno"><a class="header" href="#910-errno">9.10 <code>errno</code></a></h1>
<p>最後のシステムコールのエラーコードを保持します。</p>
<h3 id="9101-書式"><a class="header" href="#9101-書式">9.10.1 書式</a></h3>
<pre><code class="language-c">#include &lt;errno.h&gt;

int errno;
</code></pre>
<h3 id="9102-解説"><a class="header" href="#9102-解説">9.10.2 解説</a></h3>
<p>これは、多くのシステムコールのエラー情報を保持する変数です。思い起こせば、<code>socket()</code> や <code>listen()</code> などはエラーが発生すると <code>-1</code> を返し、どのエラーが発生したかを具体的に知らせるために <code>errno</code> という正確な値を設定します。</p>
<p>ヘッダーファイル <code>errno.h</code> には、<code>EADDRINUSE</code>, <code>EPIPE</code>, <code>ECONNREFUSED</code> などのような、エラーに対する定数シンボル名の束がリストアップされています。ローカルの man ページには、どのようなコードがエラーとして返されるのかが書かれています。そして、実行時にこれらを使用して、異なるエラーを異なる方法で処理することができます。</p>
<p>あるいは、より一般的には <code>perror()</code> や <code>strerror()</code> を呼び出して、人間が読める形式のエラーを取得することができます。</p>
<p>マルチスレッドの愛好家のために一つ注意しておきたいのは、ほとんどのシステムで <code>errno</code> はスレッドセーフな方法で定義されているということです。（つまり、実際にはグローバル変数ではないのですが、シングルスレッド環境ではグローバル変数と同じように振る舞います。）</p>
<h3 id="9103-返り値"><a class="header" href="#9103-返り値">9.10.3 返り値</a></h3>
<p>この変数の値は、最後に発生したエラーであり、最後のアクションが成功した場合は &quot;success &quot;のコードになるかもしれません。</p>
<h3 id="9104-例"><a class="header" href="#9104-例">9.10.4 例</a></h3>
<pre><code class="language-c">s = socket(PF_INET, SOCK_STREAM, 0);
if (s == -1) {
    perror(&quot;socket&quot;); // or use strerror()
}

tryagain:
if (select(n, &amp;readfds, NULL, NULL) == -1) {
    // an error has occurred!!

    // if we were only interrupted, just restart the select() call:
    if (errno == EINTR) goto tryagain;  // AAAA! goto!!!

    // otherwise it's a more serious error:
    perror(&quot;select&quot;);
    exit(1);
}
</code></pre>
<h3 id="9105-参照"><a class="header" href="#9105-参照">9.10.5 参照</a></h3>
<p><a href="man-pages/./perror-strerror.html"><code>perror()</code></a>,
<a href="man-pages/./perror-strerror.html"><code>strerror()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="911-fcntl"><a class="header" href="#911-fcntl">9.11 <code>fcntl()</code></a></h1>
<p>ソケット記述子を制御します。</p>
<h3 id="9111-書式"><a class="header" href="#9111-書式">9.11.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/unistd.h&gt;
#include &lt;sys/fcntl.h&gt;

int fcntl(int s, int cmd, long arg);
</code></pre>
<h3 id="9112-解説"><a class="header" href="#9112-解説">9.11.2 解説</a></h3>
<p>この関数は通常、ファイルロックやその他のファイル指向の処理を行うために使用されますが、時々見たり使ったりするようなソケット関連の関数もいくつか持っています。</p>
<p>パラメータ <code>s</code> には操作したいソケット記述子、<code>cmd</code> には <code>F_SETFL</code> を設定し、<code>arg</code> には以下のコマンドのいずれかを指定します。（ここで説明した以外にも <code>fcntl()</code> には様々な機能がありますが、ここではソケットに特化して説明します。）</p>
<table><thead><tr><th><code>cmd</code></th><th>解説</th></tr></thead><tbody>
<tr><td><code>O_NONBLOCK</code></td><td>ソケットをノンブロッキングに設定します。詳しくは<a href="man-pages/fcntl.html#blocking">ブロッキング</a>の項を参照してください。</td></tr>
<tr><td><code>O_ASYNC</code></td><td>非同期 I/O を行うようにソケットを設定します。ソケットでデータを <code>recv()</code> する準備ができたら、シグナル <code>SIGIO</code> を発生させます。これはめったに見られないことであり、ガイドの範囲を超えています。また、特定のシステムでのみ利用可能だと思います。</td></tr>
</tbody></table>
<h3 id="9113-返り値"><a class="header" href="#9113-返り値">9.11.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<p><code>fcntl()</code> システムコールの使い方によって、実際には異なる戻り値がありますが、ここではソケットに関係しないので取り上げていません。詳しくはローカルの <code>fcntl()</code> man ページを参照してください。</p>
<h3 id="9114-例"><a class="header" href="#9114-例">9.11.4 例</a></h3>
<pre><code class="language-c">int s = socket(PF_INET, SOCK_STREAM, 0);

fcntl(s, F_SETFL, O_NONBLOCK);  // set to non-blocking
fcntl(s, F_SETFL, O_ASYNC);     // set to asynchronous I/O
</code></pre>
<h3 id="9115-参照"><a class="header" href="#9115-参照">9.11.5 参照</a></h3>
<p><a href="man-pages/../slightly-advanced-techniques/blocking.html">Blocking</a>,
<a href="man-pages/./send-sendto.html"><code>send()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="912-htons-htonl-ntohs-ntohl"><a class="header" href="#912-htons-htonl-ntohs-ntohl">9.12 <code>htons()</code>, <code>htonl()</code>, <code>ntohs()</code>, <code>ntohl()</code></a></h1>
<p>マルチバイト整数型をホストバイトオーダーからネットワークバイトオーダーに変換します。</p>
<h3 id="9121-書式"><a class="header" href="#9121-書式">9.12.1 書式</a></h3>
<pre><code class="language-c">#include &lt;netinet/in.h&gt;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
</code></pre>
<h3 id="9122-解説"><a class="header" href="#9122-解説">9.12.2 解説</a></h3>
<p>不幸なことに、コンピュータによってマルチバイト整数（つまり <code>char</code> より大きな整数）の内部でのバイト順序が異なっています。この結果、2 バイトの <code>short int</code> を Intel のコンピュータから Mac（Intel のコンピュータになる前）に <code>send()</code> すると、一方のコンピュータが <code>1</code> という数字だと思っていても、他方は <code>256</code> という数字だと思い、またその逆もしかりということになるのです。</p>
<p>この問題を回避する方法は、皆がそれぞれの違いを脇に置き、モトローラと IBM は正しく、インテルは奇妙なやり方をしたのだから、送信する前にバイトオーダーを&quot;ビッグエンディアン&quot;に変換することに同意することです。Intel は&quot;リトルエンディアン&quot;マシンなので、私たちが好むバイト順序を&quot;ネットワークバ イトオーダー&quot;と呼ぶ方が、はるかに政治的に正しいのです。そこで、これらの関数は、ネイティブのバイトオーダーからネットワークバイトオーダーに変換し、また元に戻します。</p>
<p>（つまり、Intel ではこれらの関数はすべてのバイトを入れ替えますが、PowerPC ではバイトがすでにネットワークバイトオーダーになっているため、何もしません。しかし、Intel マシンでビルドしても正常に動作するようにしたい人がいるかもしれないので、いずれにせよコードでは常にこれらを使用する必要があります。）</p>
<p>32 ビット（4バイト、おそらく <code>int</code>）と 16 ビット（2バイト、おそらく <code>short</code>）の数値が含まれることに注意してください。64 ビットマシンには 64 ビットの <code>int</code> 用の <code>htonll()</code> があるかもしれませんが、私は見たことがありません。自分で書くしかないでしょう。</p>
<p>とにかく、これらの関数の動作は、まず、ホスト（あなたのマシン）のバイトオーダーから変換するのか、ネットワークのバイトオーダーから変換するのかを決定することです。もし&quot;ホスト&quot;なら、呼び出す関数の最初の文字は &quot;h&quot; です。そうでなければ、&quot;network&quot; の場合は &quot;n&quot; です。関数名の真ん中は、ある&quot;もの&quot;から別の&quot;もの&quot;に変換するため、常に &quot;to&quot; であり、最後の1文字は何に変換するかを示しています。最後の文字はデータの大きさを表し、sort の場合は &quot;s&quot;、long の場合は &quot;l&quot; です。このように</p>
<table><thead><tr><th>関数</th><th>解説</th></tr></thead><tbody>
<tr><td><code>htons()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>s</code>hort</td></tr>
<tr><td><code>htonl()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>l</code>ong</td></tr>
<tr><td><code>ntohs()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>s</code>hort</td></tr>
<tr><td><code>ntohl()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>l</code>ong</td></tr>
</tbody></table>
<h3 id="9123-返り値"><a class="header" href="#9123-返り値">9.12.3 返り値</a></h3>
<p>各関数は変換後の値を返します。</p>
<h3 id="9124-例"><a class="header" href="#9124-例">9.12.4 例</a></h3>
<pre><code class="language-c">uint32_t some_long = 10;
uint16_t some_short = 20;

uint32_t network_byte_order;

// convert and send
network_byte_order = htonl(some_long);
send(s, &amp;network_byte_order, sizeof(uint32_t), 0);

some_short == ntohs(htons(some_short)); // this expression is true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="913-inet_ntoa-inet_aton-inet_addr"><a class="header" href="#913-inet_ntoa-inet_aton-inet_addr">9.13 <code>inet_ntoa()</code>, <code>inet_aton()</code>, <code>inet_addr</code></a></h1>
<p>IP アドレスをドットアンドナンバーの文字列から <code>struct in_addr</code> に変換し、元に戻します。</p>
<h3 id="9131-書式"><a class="header" href="#9131-書式">9.13.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

// ALL THESE ARE DEPRECATED! Use inet_pton()  or inet_ntop() instead!!

char *inet_ntoa(struct in_addr in);
int inet_aton(const char *cp, struct in_addr *inp);
in_addr_t inet_addr(const char *cp);
</code></pre>
<h3 id="9132-解説"><a class="header" href="#9132-解説">9.13.2 解説</a></h3>
<p>これらの関数は IPv6 を扱えないため、非推奨です！代わりに <code>inet_ntop()</code> または <code>inet_pton()</code> を使ってください！これらの関数がここに含まれているのは、まだ野放しになっていることがあるからです。</p>
<p>これらの関数はすべて <code>struct in_addr</code>（おそらく <code>struct sockaddr_in</code> の一部）からドットアンドナンバー形式の文字列（例：&quot;192.168.5.10&quot;）に変換し、その逆もまた可能です。コマンドラインなどで IP アドレスが渡された場合、<code>connect()</code> の相手となる <code>struct in_addr</code> を得るには、これが一番簡単な方法だと思います。もっと強力なものが必要なら、<code>gethostbyname()</code> のような DNS 関数を試してみたり、自分の住んでいる国でクーデターを起こしてみたりしてください。</p>
<p>関数 <code>inet_ntoa()</code> は <code>struct in_addr</code> に格納されたネットワークアドレスをドットアンドナンバー形式の文字列に変換します。&quot;ntoa&quot; の &quot;n&quot; はネットワークを表し、&quot;a&quot; は歴史的な理由から ASCII を表しています（つまり &quot;Network To ASCII&quot; です。&quot;toa&quot; というサフィックスは C ライブラリに <code>atoi()</code> という ASCII 文字列に変換する類似の友人があります）。</p>
<p>関数 <code>inet_aton()</code> はその逆で、ドットや数字を含む文字列から <code>in_addr_t</code>（これは <code>struct in_addr</code> のフィールド <code>s_addr</code> の型）に変換します。</p>
<p>最後に、関数 <code>inet_addr()</code> は古い関数で、基本的に <code>inet_aton()</code> と同じことをします。理論的には非推奨ですが、よく目にしますし、使っても警察には捕まりません。</p>
<h3 id="9133-返り値"><a class="header" href="#9133-返り値">9.13.3 返り値</a></h3>
<p><code>inet_aton()</code> はアドレスが有効な場合は <code>0</code> 以外を返し、アドレスが無効な場合は <code>0</code> を返します。</p>
<p><code>inet_ntoa()</code> はドットアンドナンバーズの文字列を静的バッファに格納し、この関数を呼び出すたびに上書きされるように返します。</p>
<p><code>net_addr()</code> はアドレスを <code>in_addr_t</code> として返し、エラーがある場合は <code>-1</code> を返します。（これは、有効な IP アドレスである &quot;<code>255.255.255.255</code>&quot; という文字列を変換しようとした場合と同じ結果です。これが <code>inet_aton()</code> の方が良い理由です。）</p>
<h3 id="9134-例"><a class="header" href="#9134-例">9.13.4 例</a></h3>
<pre><code class="language-c">struct sockaddr_in antelope;
char *some_addr;

inet_aton(&quot;10.0.0.1&quot;, &amp;antelope.sin_addr); // store IP in antelope

some_addr = inet_ntoa(antelope.sin_addr); // return the IP
printf(&quot;%s\n&quot;, some_addr); // prints &quot;10.0.0.1&quot;

// and this call is the same as the inet_aton() call, above:
antelope.sin_addr.s_addr = inet_addr(&quot;10.0.0.1&quot;);
</code></pre>
<h3 id="9135-参照"><a class="header" href="#9135-参照">9.13.5 参照</a></h3>
<p><a href="man-pages/./inet_ntop-inet-pton.html"><code>inet_ntop()</code></a>,
<a href="man-pages/./inet_ntop-inet-pton.html"><code>inet_pton()</code></a>,
<a href="man-pages/./gethostbyname-gethostbyaddr.html"><code>gethostbyname()</code></a>,
<a href="man-pages/./gethostbyname-gethostbyaddr.html"><code>gethostbyaddr()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="914-inet_ntop-inet_pton"><a class="header" href="#914-inet_ntop-inet_pton">9.14 <code>inet_ntop()</code>, <code>inet_pton()</code></a></h1>
<p>IPアドレスを人間が読める形に変換して戻します。</p>
<h3 id="9141-書式"><a class="header" href="#9141-書式">9.14.1 書式</a></h3>
<pre><code class="language-c">#include &lt;arpa/inet.h&gt;

const char *inet_ntop(int af, const void *src,
                      char *dst, socklen_t size);

int inet_pton(int af, const char *src, void *dst);
</code></pre>
<h3 id="9142-解説"><a class="header" href="#9142-解説">9.14.2 解説</a></h3>
<p>これらの関数は、人間が読める IP アドレスを扱い、様々な関数やシステムコールで使用するためにバイナリ表現に変換するためのものです。&quot;n&quot; は &quot;network&quot;、&quot;p&quot; は &quot;presentation&quot; を表します。あるいは &quot;text presentation&quot; 。しかし、&quot;printable&quot; と考えてもよいです。&quot;ntop&quot; は &quot;network to printable &quot; です。ほらね？</p>
<p>IP アドレスを見るときに、2 進数の山を見たくないことがあります。<code>192.0.2.180</code> や <code>2001:db8:8714:3a90::12</code> のような、プリント可能な形式でありたいと思うことでしょう。そのような場合には、<code>inet_ntop()</code> を使用します。</p>
<p><code>inet_ntop()</code> は <code>af</code> パラメータにアドレスファミリ（<code>AF_INET</code> または <code>AF_INET6</code>）を受け取ります。<code>src</code> パラメータには、文字列に変換したいアドレスを含む <code>struct in_addr</code> または <code>struct in6_addr</code> へのポインタを指定する必要があります。最後に <code>dst</code> と <code>size</code> は、変換先の文字列へのポインタと、その文字列の最大長を表します。</p>
<p><code>dst</code> の文字列の最大長はどうすればよいのでしょうか？IPv4 アドレスと IPv6 アドレスの最大長はどのくらいですか？幸いなことに、あなたを助けてくれるマクロがいくつかあります。最大長は以下の通りです。<code>INET_ADDRSTRLEN</code> と <code>INET6_ADDRSTRLEN</code> です。</p>
<p>また、IP アドレスを可読形式で含む文字列を持っていて、それを <code>struct sockaddr_in</code> や <code>struct sockaddr_in6</code> に格納したい場合もあります。このような場合は、反対の関数 <code>inet_pton()</code> を使用します。</p>
<p>また、<code>inet_pton()</code> は <code>af</code> パラメータにアドレスファミリ（<code>AF_INET</code> または <code>AF_INET6</code>）を受け取ります。<code>src</code> パラメータには、IP アドレスをプリント可能な形式で格納した文字列へのポインタを指定します。最後に <code>dst</code> パラメータは、結果を格納する場所を指定します。これはおそらく <code>struct in_addr</code> または <code>struct in6_addr</code> となります。</p>
<p>これらの関数は DNS のルックアップを行いません---そのためには <code>getaddrinfo()</code> が必要です。</p>
<h3 id="9143-返り値"><a class="header" href="#9143-返り値">9.14.3 返り値</a></h3>
<p><code>inet_ntop()</code> は成功すると <code>dst</code> パラメータを返し、失敗すると <code>NULL</code> を返します（そして <code>errno</code> が設定されます）。</p>
<p><code>inet_pton()</code> は成功すると <code>1</code> を返します。エラーがあった場合（<code>errno</code> が設定されます）は <code>-1</code> を返し、入力が有効な IP アドレスでなかった場合は <code>0</code> を返します。</p>
<h3 id="9144-例"><a class="header" href="#9144-例">9.14.4 例</a></h3>
<pre><code class="language-c">// IPv4 demo of inet_ntop() and inet_pton()

struct sockaddr_in sa;
char str[INET_ADDRSTRLEN];

// store this IP address in sa:
inet_pton(AF_INET, &quot;192.0.2.33&quot;, &amp;(sa.sin_addr));

// now get it back and print it
inet_ntop(AF_INET, &amp;(sa.sin_addr), str, INET_ADDRSTRLEN);

printf(&quot;%s\n&quot;, str); // prints &quot;192.0.2.33&quot;
</code></pre>
<pre><code class="language-c">// IPv6 demo of inet_ntop() and inet_pton()
// (basically the same except with a bunch of 6s thrown around)

struct sockaddr_in6 sa;
char str[INET6_ADDRSTRLEN];

// store this IP address in sa:
inet_pton(AF_INET6, &quot;2001:db8:8714:3a90::12&quot;, &amp;(sa.sin6_addr));

// now get it back and print it
inet_ntop(AF_INET6, &amp;(sa.sin6_addr), str, INET6_ADDRSTRLEN);

printf(&quot;%s\n&quot;, str); // prints &quot;2001:db8:8714:3a90::12&quot;
</code></pre>
<pre><code class="language-c">// Helper function you can use:

//Convert a struct sockaddr address to a string, IPv4 and IPv6:

char *get_ip_str(const struct sockaddr *sa, char *s, size_t maxlen)
{
    switch(sa-&gt;sa_family) {
        case AF_INET:
            inet_ntop(AF_INET, &amp;(((struct sockaddr_in *)sa)-&gt;sin_addr),
                    s, maxlen);
            break;

        case AF_INET6:
            inet_ntop(AF_INET6, &amp;(((struct sockaddr_in6 *)sa)-&gt;sin6_addr),
                    s, maxlen);
            break;

        default:
            strncpy(s, &quot;Unknown AF&quot;, maxlen);
            return NULL;
    }

    return s;
}
</code></pre>
<h3 id="9145-参照"><a class="header" href="#9145-参照">9.14.5 参照</a></h3>
<p><a href="man-pages/./getaddrinfo-freeaddrinfo-gai_strerror.html"><code>getaddrinfo()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="915-listen"><a class="header" href="#915-listen">9.15 <code>listen()</code></a></h1>
<p>ソケットに着信を待つように指示します。</p>
<h3 id="9151-書式"><a class="header" href="#9151-書式">9.15.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int listen(int s, int backlog);
</code></pre>
<h3 id="9152-解説"><a class="header" href="#9152-解説">9.15.2 解説</a></h3>
<p>ソケット記述子（<code>socket()</code>システムコールで作成）を受け取り、着信接続をリッスンするように指示することができます。これがサーバとクライアントを区別するポイントです、みんな。</p>
<p><code>backlog</code> パラメータはシステムによって異なる意味を持ちますが、大まかに言うと、カーネルが新しい接続を拒否し始めるまでに保留できる接続の数です。つまり、新しい接続が来たら、バックログがいっぱいにならないように、素早く <code>accept()</code> する必要があります。10 程度に設定してみて、もしクライアントが高負荷で &quot;Connection refused&quot; を受け始めたら、もっと高く設定してみてください。</p>
<p><code>listen()</code> を呼び出す前に、サーバは <code>bind()</code> を呼び出して特定のポート番号に自分自身をアタッチする必要があります。そのポート番号（サーバの IP アドレス上）は、クライアントが接続するポート番号になります。</p>
<h3 id="9153-返り値"><a class="header" href="#9153-返り値">9.15.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<h3 id="9154-例"><a class="header" href="#9154-例">9.15.4 例</a></h3>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

listen(sockfd, 10); // set s up to be a server (listening) socket

// then have an accept() loop down here somewhere
</code></pre>
<h3 id="9155-参照"><a class="header" href="#9155-参照">9.15.5 参照</a></h3>
<p><a href="man-pages/./accept.html"><code>accept()</code></a>,
<a href="man-pages/./bind.html"><code>bind()</code></a>,
<a href="man-pages/./socket.html"><code>socket()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="916-perror-strerror"><a class="header" href="#916-perror-strerror">9.16 <code>perror()</code>, <code>strerror()</code></a></h1>
<p>エラーを人間が読める文字列で表示します。</p>
<h3 id="9161-書式"><a class="header" href="#9161-書式">9.16.1 書式</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;   // for strerror()

void perror(const char *s);
char *strerror(int errnum);
</code></pre>
<h3 id="9162-解説"><a class="header" href="#9162-解説">9.16.2 解説</a></h3>
<p>多くの関数がエラー時に <code>-1</code> を返し、変数 <code>errno</code> の値を何らかの数値に設定するので、それを自分にとって意味のある形で簡単に表示できたら確かに良いでしょう。</p>
<p>幸いなことに、<code>perror()</code> がそれをやってくれます。もし、エラーの前にもっと説明を表示させたい場合は、パラメータ <code>s</code> を指定します（あるいは <code>s</code> を <code>NULL</code> にしておけば、何も追加で表示されません）。</p>
<p>簡単に言うと、この関数は <code>ECONNRESET</code> のような <code>errno</code> 値を受け取り、それらを &quot;Connection reset by peer&quot; のようにうまく表示します。</p>
<p>関数 <code>strerror()</code> は <code>perror()</code> に非常に似ていますが、与えられた値（通常は変数 <code>errno</code> を渡します）に対するエラーメッセージの文字列へのポインタを返す点が異なります。</p>
<h3 id="9163-返り値"><a class="header" href="#9163-返り値">9.16.3 返り値</a></h3>
<p><code>strerror()</code> はエラーメッセージの文字列へのポインタを返します。</p>
<h3 id="9164-例"><a class="header" href="#9164-例">9.16.4 例</a></h3>
<pre><code class="language-c">int s;

s = socket(PF_INET, SOCK_STREAM, 0);

if (s == -1) { // some error has occurred
    // prints &quot;socket error: &quot; + the error message:
    perror(&quot;socket error&quot;);
}

// similarly:
if (listen(s, 10) == -1) {
    // this prints &quot;an error: &quot; + the error message from errno:
    printf(&quot;an error: %s\n&quot;, strerror(errno));
}
</code></pre>
<h3 id="9165-参照"><a class="header" href="#9165-参照">9.16.5 参照</a></h3>
<p><a href="man-pages/./errno.html"><code>errno</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="917-poll"><a class="header" href="#917-poll">9.17 <code>poll()</code></a></h1>
<p>複数のソケットで同時にイベントをテストします。</p>
<h3 id="9171-書式"><a class="header" href="#9171-書式">9.17.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/poll.h&gt;

int poll(struct pollfd *ufds, unsigned int nfds, int timeout);
</code></pre>
<h3 id="9172-解説"><a class="header" href="#9172-解説">9.17.2 解説</a></h3>
<p>この関数は <code>select()</code> と非常によく似ており、どちらもファイル記述子の集合を監視して、<code>recv()</code> の準備ができた受信データ、<code>send()</code> へのソケットの準備、<code>recv()</code> への帯域外データの準備、エラーなどのイベントを検出します。</p>
<p>基本的な考え方は、 <code>ufds</code> に <code>nfds</code> <code>struct pollfd</code> の配列と、ミリ秒単位のタイムアウト（1秒は1000ミリ秒）を渡すというものです。永遠に待ちたい場合は、タイムアウトを負数にすることでできます。タイムアウトまでにどのソケット記述子でもイベントが発生しなかった場合、<code>poll()</code> が返ります。</p>
<p>配列 <code>struct pollfd</code> の各要素は、1つのソケット記述子を表し、以下のフィールドを含みます。</p>
<pre><code class="language-c">struct pollfd {
    int fd;         // the socket descriptor
    short events;   // bitmap of events we're interested in
    short revents;  // when poll() returns, bitmap of events that occurred
};
</code></pre>
<p><code>poll()</code> を呼び出す前に、ソケット記述子 <code>fd</code> をロードし（<code>fd</code> に負の数を設定すると、この <code>struct pollfd</code> は無視され、その <code>revents</code> フィールドはゼロになります）、次に以下のマクロのビット単位の OR により <code>event</code> フィールドを構築します。</p>
<table><thead><tr><th>Macro</th><th>解説</th></tr></thead><tbody>
<tr><td><code>POLLIN</code></td><td>このソケットで <code>recv()</code> のためのデータが準備できたときに警告を出します。</td></tr>
<tr><td><code>POLLOUT</code></td><td>このソケットにブロックせずにデータを <code>send()</code> できるようになったら警告を出します。</td></tr>
<tr><td><code>POLLPRI</code></td><td>このソケットで帯域外データが <code>recv()</code> できるようになったら警告を出します。</td></tr>
</tbody></table>
<p><code>poll()</code> コールが戻ってくると、<code>revents</code> フィールドは上記のフィールドのビット単位の OR となり、どの記述子で実際にそのイベントが発生したかがわかります。さらに、これらの他のフィールドが存在する可能性があります。</p>
<table><thead><tr><th>Macro</th><th>解説</th></tr></thead><tbody>
<tr><td><code>POLLERR</code></td><td>このソケットでエラーが発生しました。</td></tr>
<tr><td><code>POLLHUP</code></td><td>リモート側の接続がハングアップしました。</td></tr>
<tr><td><code>POLLNVAL</code></td><td>ソケット記述子 <code>fd</code> に何か問題があったようだ---たぶん初期化されていないのだろう？</td></tr>
</tbody></table>
<h3 id="9173-返り値"><a class="header" href="#9173-返り値">9.17.3 返り値</a></h3>
<p>配列 <code>ufds</code> のうち、イベントが発生した要素の数を返します。タイムアウトが発生した場合は <code>0</code> になります。また、エラーが発生した場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます。）</p>
<h3 id="9174-例"><a class="header" href="#9174-例">9.17.4 例</a></h3>
<pre><code class="language-c">int s1, s2;
int rv;
char buf1[256], buf2[256];
struct pollfd ufds[2];

s1 = socket(PF_INET, SOCK_STREAM, 0);
s2 = socket(PF_INET, SOCK_STREAM, 0);

// pretend we've connected both to a server at this point
//connect(s1, ...)...
//connect(s2, ...)...

// set up the array of file descriptors.
//
// in this example, we want to know when there's normal or out-of-band
// data ready to be recv()'d...

ufds[0].fd = s1;
ufds[0].events = POLLIN | POLLPRI; // check for normal or out-of-band

ufds[1].fd = s2;
ufds[1].events = POLLIN; // check for just normal data

// wait for events on the sockets, 3.5 second timeout
rv = poll(ufds, 2, 3500);

if (rv == -1) {
    perror(&quot;poll&quot;); // error occurred in poll()
} else if (rv == 0) {
    printf(&quot;Timeout occurred! No data after 3.5 seconds.\n&quot;);
} else {
    // check for events on s1:
    if (ufds[0].revents &amp; POLLIN) {
        recv(s1, buf1, sizeof buf1, 0); // receive normal data
    }
    if (ufds[0].revents &amp; POLLPRI) {
        recv(s1, buf1, sizeof buf1, MSG_OOB); // out-of-band data
    }

    // check for events on s2:
    if (ufds[1].revents &amp; POLLIN) {
        recv(s1, buf2, sizeof buf2, 0);
    }
}
</code></pre>
<h3 id="9175-参照"><a class="header" href="#9175-参照">9.17.5 参照</a></h3>
<p><a href="man-pages/./select.html"><code>select()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="918-recv-recvfrom"><a class="header" href="#918-recv-recvfrom">9.18 <code>recv()</code>, <code>recvfrom()</code></a></h1>
<p>ソケットでデータを受信します。</p>
<h3 id="9181-書式"><a class="header" href="#9181-書式">9.18.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t recv(int s, void *buf, size_t len, int flags);
ssize_t recvfrom(int s, void *buf, size_t len, int flags,
                 struct sockaddr *from, socklen_t *fromlen);
</code></pre>
<h3 id="9182-解説"><a class="header" href="#9182-解説">9.18.2 解説</a></h3>
<p>ソケットを立ち上げて接続したら、<code>recv()</code>（TCP <code>SOCK_STREAM</code> ソケットの場合）と <code>recvfrom()</code>（UDP <code>SOCK_DGRAM</code> ソケットの場合）を使ってリモート側から受信したデータを読み込むことができるようになります。</p>
<p>どちらの関数も、ソケット記述子 <code>s</code>、バッファへのポインタ <code>buf</code>、バッファのサイズ（バイト数）<code>len</code>、そして関数の動作を制御するための <code>flags</code> を受け取ります。</p>
<p>さらに、<code>recvfrom()</code> は <code>struct sockaddr*</code> を受け取り、<code>from</code> はデータがどこから来たかを示し、 <code>fromlen</code> には <code>struct sockaddr</code> のサイズを記入することになります。（また、<code>fromlen</code> を <code>from</code> または <code>struct sockaddr</code> のサイズに初期化する必要があります。）</p>
<p>では、この関数にどんな不思議なフラグを渡すことができるのでしょうか？以下にそのいくつかを紹介しますが、より詳細な情報やあなたのシステムで実際にサポートされているものについては、ローカルのマニュアルページをチェックする必要があります。また、通常のバニラの <code>recv() </code> にしたい場合は、<code>flags</code> を <code>0</code> に設定します。</p>
<table><thead><tr><th>Macro</th><th>解説</th></tr></thead><tbody>
<tr><td><code>MSG_OOB</code></td><td>Out of Band データを受信します。これは、<code>send()</code> で <code>MSG_OOB</code> フラグを指定して送信されたデータを取得する方法です。受信側としては、緊急のデータがあることを伝えるシグナル <code>SIGURG</code> が発生しているはずです。このシグナルに対するハンドラで、この <code>MSG_OOB</code> フラグを指定して <code>recv()</code> を呼び出すことができます。</td></tr>
<tr><td><code>MSG_PEEK</code></td><td>もし <code>recv()</code> を &quot;見せかけだけ&quot; に呼び出したい場合は、このフラグを付けて呼び出すことができます。これは、<code>recv()</code> を &quot;本当の意味で&quot;（つまり <code>MSG_PEEK</code> フラグなしで）呼び出したときに、バッファの中で何が待っているかを教えてくれるものです。これは、次の <code>recv()</code> 呼び出しに対するスニークプレビューのようなものです。</td></tr>
<tr><td><code>MSG_WAITALL</code></td><td><code>recv()</code> に、<code>len</code> パラメータで指定したデータがすべて揃うまで戻らないように指示します。しかし、シグナルによって呼び出しが中断された場合、何らかのエラーが発生した場合、リモート側が接続を閉じた場合など、極端な状況下ではあなたの希望を無視することができます。怒らないでください。</td></tr>
</tbody></table>
<p><code>recv()</code> を呼び出すと、読み込むべきデータがあるまでブロックされます。ブロックしたくない場合は、ソケットをノンブロッキングに設定するか、<code>select()</code> や <code>poll()</code> で受信データがあるかどうかを確認してから <code>recv()</code> や <code>recvfrom()</code> を呼び出してください。</p>
<h3 id="9183-返り値"><a class="header" href="#9183-返り値">9.18.3 返り値</a></h3>
<p>実際に受け取ったバイト数（<code>len</code> パラメータで指定した値よりも少ないかもしれません）を返します。エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> がセットされます）。</p>
<p>リモート側が接続を閉じていた場合、<code>recv()</code> は <code>0</code> を返します。これは、リモート側が接続を閉じたかどうかを判断するための通常の方法です。正常なのは良いことだ、反乱軍！</p>
<h3 id="9184-例"><a class="header" href="#9184-例">9.18.4 例</a></h3>
<pre><code class="language-c">// stream sockets and recv()

struct addrinfo hints, *res;
int sockfd;
char buf[512];
int byte_count;

// get host info, make socket, and connect it
memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
getaddrinfo(&quot;www.example.com&quot;, &quot;3490&quot;, &amp;hints, &amp;res);
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

// all right! now that we're connected, we can receive some data!
byte_count = recv(sockfd, buf, sizeof buf, 0);
printf(&quot;recv()'d %d bytes of data in buf\n&quot;, byte_count);
</code></pre>
<pre><code class="language-c">// datagram sockets and recvfrom()

struct addrinfo hints, *res;
int sockfd;
int byte_count;
socklen_t fromlen;
struct sockaddr_storage addr;
char buf[512];
char ipstr[INET6_ADDRSTRLEN];

// get host info, make socket, bind it to port 4950
memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;
getaddrinfo(NULL, &quot;4950&quot;, &amp;hints, &amp;res);
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

// no need to accept(), just recvfrom():

fromlen = sizeof addr;
byte_count = recvfrom(sockfd, buf, sizeof buf, 0, &amp;addr, &amp;fromlen);

printf(&quot;recv()'d %d bytes of data in buf\n&quot;, byte_count);
printf(&quot;from IP address %s\n&quot;,
    inet_ntop(addr.ss_family,
        addr.ss_family == AF_INET?
            ((struct sockadd_in *)&amp;addr)-&gt;sin_addr:
            ((struct sockadd_in6 *)&amp;addr)-&gt;sin6_addr,
        ipstr, sizeof ipstr);
</code></pre>
<h3 id="9185-参照"><a class="header" href="#9185-参照">9.18.5 参照</a></h3>
<p><a href="man-pages/./send-sendto.html"><code>send()</code></a>,
<a href="man-pages/./send-sendto.html"><code>sendto()</code></a>,
<a href="man-pages/./select.html"><code>select()</code></a>,
<a href="man-pages/./poll.html"><code>poll()</code></a>,
<a href="man-pages/../slightly-advanced-techniques/blocking.html">Blocking</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="919-select"><a class="header" href="#919-select">9.19 <code>select()</code></a></h1>
<p>ソケット記述子が読み込み/書き込み可能かどうか確認します。</p>
<h3 id="9191-書式"><a class="header" href="#9191-書式">9.19.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/select.h&gt;

int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
           struct timeval *timeout);

FD_SET(int fd, fd_set *set);
FD_CLR(int fd, fd_set *set);
FD_ISSET(int fd, fd_set *set);
FD_ZERO(fd_set *set);
</code></pre>
<h3 id="9192-解説"><a class="header" href="#9192-解説">9.19.2 解説</a></h3>
<p><code>select()</code> 関数は、複数のソケットを同時にチェックして、受信待ちのデータがあるか、ブロッキングせずに <code>send()</code> できるか、何らかの例外が発生したかを確認する方法を提供します。</p>
<p>上記の <code>FD_SET()</code> のようなマクロを使用して、ソケット記述子のセットを投入します。セットができたら、それを以下のいずれかのパラメータとして関数に渡します。<code>readfds</code>（セット内のいずれかのソケットが <code>recv()</code> データを受信できる状態になったとき）、<code>writefds</code>（セット内のいずれかのソケットが <code>send()</code> データを送信できる状態になったとき）、または <code>exceptfds</code>（いずれかのソケットで例外が発生したときに知る必要がある場合）。もし、これらのタイプのイベントに興味がなければ、これらのパラメータのいずれか、あるいはすべてを <code>NULL</code> にすることができます。<code>select()</code> が返された後、セット内の値が変更され、どれが読み書き可能で、どれが例外を発生させたかが表示されます。</p>
<p>最初のパラメータ <code>n</code> は、最も大きい番号のソケット記述子（これらは単なる <code>int</code>s, 覚えていますか？）に <code>1</code> を加えたものです。</p>
<p>最後に、最後に <code>struct timeval</code>, <code>timeout</code> を記述します。これは <code>select()</code> に、これらのセットをどれくらいの時間チェックするかを指示します。タイムアウト後、あるいはイベントが発生したときのどちらか早いほうに戻ります。<code>timeval</code> 構造体は2つのフィールドを持っています。<code>tv_sec</code> は秒数で、これに <code>tv_usec</code> というマイクロ秒（1,000,000 マイクロ秒が 1 秒）を加えたものです。</p>
<p>ヘルパーマクロは次のような働きをします。</p>
<table><thead><tr><th>Macro</th><th>解説</th></tr></thead><tbody>
<tr><td><code>FD_SET(int fd, fd_set *set);</code></td><td><code>set</code> に <code>fd</code> を追加します。</td></tr>
<tr><td><code>FD_CLR(int fd, fd_set *set);</code></td><td><code>set</code> から <code>fd</code> を削除します。</td></tr>
<tr><td><code>FD_ISSET(int fd, fd_set *set);</code></td><td><code>fd</code> が <code>set</code> に含まれる場合は true を返す。</td></tr>
<tr><td><code>FD_ZERO(fd_set *set);</code></td><td><code>set</code> からすべてのエントリをクリアします。</td></tr>
</tbody></table>
<p>Linux ユーザーへの注意事項：Linux の <code>select()</code> は &quot;ready-to-read&quot; を返すことがありますが、実際には読み込む準備ができていないため、その後の <code>read()</code> 呼び出しがブロックされることがあります。このバグを回避するには、受信側のソケットに <code>O_NONBLOCK</code> フラグを設定し、<code>EWOULDBLOCK</code> でエラーになるようにし、このエラーが発生しても無視します。ソケットをノンブロッキングに設定する方法については、<a href="man-pages/select.html#fcntlman"><code>fcntl()</code> reference page</a> を参照してください。</p>
<h3 id="9193-返り値"><a class="header" href="#9193-返り値">9.19.3 返り値</a></h3>
<p>成功した場合はセットに含まれる記述子の数を、タイムアウトに達した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。また、どのソケットが準備できているかを示すために、セットも変更されます。</p>
<h3 id="9194-例"><a class="header" href="#9194-例">9.19.4 例</a></h3>
<pre><code class="language-c">int s1, s2, n;
fd_set readfds;
struct timeval tv;
char buf1[256], buf2[256];

// pretend we've connected both to a server at this point
//s1 = socket(...);
//s2 = socket(...);
//connect(s1, ...)...
//connect(s2, ...)...

// clear the set ahead of time
FD_ZERO(&amp;readfds);

// add our descriptors to the set
FD_SET(s1, &amp;readfds);
FD_SET(s2, &amp;readfds);

// since we got s2 second, it's the &quot;greater&quot;, so we use that for
// the n param in select()
n = s2 + 1;

// wait until either socket has data ready to be recv()d (timeout 10.5 secs)
tv.tv_sec = 10;
tv.tv_usec = 500000;
rv = select(n, &amp;readfds, NULL, NULL, &amp;tv);

if (rv == -1) {
    perror(&quot;select&quot;); // error occurred in select()
} else if (rv == 0) {
    printf(&quot;Timeout occurred! No data after 10.5 seconds.\n&quot;);
} else {
    // one or both of the descriptors have data
    if (FD_ISSET(s1, &amp;readfds)) {
        recv(s1, buf1, sizeof buf1, 0);
    }
    if (FD_ISSET(s2, &amp;readfds)) {
        recv(s2, buf2, sizeof buf2, 0);
    }
}
</code></pre>
<h3 id="9195-参照"><a class="header" href="#9195-参照">9.19.5 参照</a></h3>
<p><a href="man-pages/./poll.html"><code>poll()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="920-setsockopt-getsockopt"><a class="header" href="#920-setsockopt-getsockopt">9.20 <code>setsockopt()</code>, <code>getsockopt()</code></a></h1>
<p>ソケットの各種オプションを設定します。</p>
<h3 id="9201-書式"><a class="header" href="#9201-書式">9.20.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int getsockopt(int s, int level, int optname, void *optval,
               socklen_t *optlen);
int setsockopt(int s, int level, int optname, const void *optval,
               socklen_t optlen);
</code></pre>
<h3 id="9202-解説"><a class="header" href="#9202-解説">9.20.2 解説</a></h3>
<p>ソケットはかなり設定しやすい獣です。実際、とても設定しやすいので、ここですべてをカバーするつもりはありません。どうせシステム依存でしょうから。しかし、基本的なことについてはお話します。</p>
<p>当然ながら、これらの関数はソケットの特定のオプションを取得・設定します。Linux では、ソケットの情報はすべて &quot;man page for socket&quot; の 7 章にあります。（これらの情報を得るには &quot;<code>man 7 socket</code>&quot; とタイプしてください。）</p>
<p>パラメータとしては、<code>s</code> はあなたが話しているソケットで、<code>level</code> は <code>SOL_SOCKET</code> に設定する必要があります。そして、<code>optname</code> に興味のある名前を設定します。繰り返しになりますが、すべてのオプションについては man ページを参照してください。しかし、ここでは最も楽しいものをいくつか紹介します。</p>
<table><thead><tr><th><code>optname</code></th><th>解説</th></tr></thead><tbody>
<tr><td><code>SO_BINDTODEVICE</code></td><td>このソケットは <code>bind()</code> を使って IP アドレスにバインドするのではなく、 <code>eth0</code> のようなシンボリックなデバイス名にバインドしてください。Unix で <code>ifconfig</code> コマンドを入力すると、デバイス名が表示されます。</td></tr>
<tr><td><code>SO_REUSEADDR</code></td><td>このポートにバインドしているアクティブなソケットがない限り、他のソケットが <code>bind()</code> を行えるようにします。これにより、クラッシュ後にサーバを再起動しようとしたときに表示される &quot;Address already in use&quot; エラーメッセージを回避することができます。</td></tr>
<tr><td><code>SOCK_DGRAM</code></td><td>UDP データグラム <a href="man-pages/%60SOCK_DGRAM%60">SOCK_DGRAM</a> ソケットがブロードキャストアドレスに送信されたパケットを送受信できるようにします。TCP ストリームソケットには何もしません---NOTHING!!---ははは！</td></tr>
</tbody></table>
<p>パラメータ <code>optval</code> については、通常、問題の値を示す <code>int</code> へのポインタとなります。ブール値の場合、<code>0</code> は偽で、<code>0</code> 以外は真です。そしてそれは、あなたのシステムで異なっていない限り、絶対的な事実です。渡すべきパラメータがない場合、<code>optval</code> は <code>NULL</code> にすることができます。</p>
<p>最後のパラメータ <code>optlen</code> には、<code>optval</code> の長さ、おそらく <code>sizeof(int)</code> を設定する必要がありますが、オプションによって異なります。<code>getsockopt()</code> の場合、これは <code>socklen_t</code> へのポインタであり、<code>optval</code> に格納される最大サイズのオブジェクトを指定することに注意してください（バッファオーバーフローを防止するためです）。そして <code>getsockopt()</code> は <code>optlen</code> の値を、実際に設定されたバイト数を反映するように変更します。</p>
<p><strong>警告</strong>：いくつかのシステム（特に Sun と Windows）では、このオプションは <code>int</code> の代わりに <code>char</code> とすることができ、例えば <code>int</code> 値 <code>1</code> の代わりに <code>'1'</code> という文字値を設定することができます。繰り返しになりますが、より詳しい情報は &quot;<code>man setsockopt</code>&quot; と &quot;<code>man 7 socket</code>&quot; で各自の man ページをチェックしてください！</p>
<h3 id="9203-返り値"><a class="header" href="#9203-返り値">9.20.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<h3 id="9204-例"><a class="header" href="#9204-例">9.20.4 例</a></h3>
<pre><code class="language-c">int optval;
int optlen;
char *optval2;

// set SO_REUSEADDR on a socket to true (1):
optval = 1;
setsockopt(s1, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof optval);

// bind a socket to a device name (might not work on all systems):
optval2 = &quot;eth1&quot;; // 4 bytes long, so 4, below:
setsockopt(s2, SOL_SOCKET, SO_BINDTODEVICE, optval2, 4);

// see if the SO_BROADCAST flag is set:
getsockopt(s3, SOL_SOCKET, SO_BROADCAST, &amp;optval, &amp;optlen);
if (optval != 0) {
    print(&quot;SO_BROADCAST enabled on s3!\n&quot;);
}
</code></pre>
<h3 id="9205-参照"><a class="header" href="#9205-参照">9.20.5 参照</a></h3>
<p><a href="man-pages/./fcntl.html"><code>fcntl()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="921-send-sendto"><a class="header" href="#921-send-sendto">9.21 <code>send()</code>, <code>sendto()</code></a></h1>
<p>ソケットでデータを送信します。</p>
<h3 id="9211-書式"><a class="header" href="#9211-書式">9.21.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int s, const void *buf, size_t len, int flags);
ssize_t sendto(int s, const void *buf, size_t len,
               int flags, const struct sockaddr *to,
               socklen_t tolen);
</code></pre>
<h3 id="9212-解説"><a class="header" href="#9212-解説">9.21.2 解説</a></h3>
<p>これらの関数は、ソケットにデータを送信します。一般に、<code>send()</code> は TCP の <code>SOCK_STREAM</code> 接続型ソケットに、<code>sendto()</code> は UDP の <code>SOCK_DGRAM</code> 非接続型データグラムソケットに用います。非接続型ソケットでは、パケットを送信するたびにその宛先を指定する必要があり、そのため <code>sendto()</code> の最後のパラメータでパケットの行き先を定義しています。</p>
<p><code>send()</code> と <code>sendto()</code> では、パラメータ <code>s</code> がソケット、<code>buf</code> が送信するデータへのポインタ、<code>len</code> が送信するバイト数、<code>flags</code> がデータの送信方法に関する詳細情報を指定することが可能です。通常の &quot;データ&quot; にしたい場合は、<code>flags</code> を <code>0</code> に設定します。以下は一般的に使用されるフラグですが、詳細はローカルの <code>send()</code> man ページを確認してください。</p>
<table><thead><tr><th>Macro</th><th>解説</th></tr></thead><tbody>
<tr><td><code>MSG_OOB</code></td><td>&quot;帯域外&quot; データとして送信します。TCP はこれをサポートしており、このデータが通常のデータよりも優先順位が高いことを受信側のシステムに伝える方法です。受信側はシグナル <code>SIGURG</code> を受け取り、キューにある残りの通常のデータをすべて最初に受信することなく、このデータを受信することができます。</td></tr>
<tr><td><code>MSG_DONTROUTE</code></td><td>このデータはルータで送らず、ローカルに置いてください。</td></tr>
<tr><td><code>MSG_DONTWAIT</code></td><td>送信トラフィックが詰まっているために <code>send()</code> がブロックされる場合、<code>EAGAIN</code> を返すようにします。これは &quot;この送信のときだけノンブロックを有効にする&quot; ようなものです。詳しくは <a href="man-pages/send-sendto.html#blocking">blocking</a> の章を参照してください。</td></tr>
<tr><td><code>MSG_NOSIGNAL</code></td><td>もし <code>recv()</code> が終了したリモートホストに <code>send()</code> した場合、通常 <code>SIGPIPE</code> というシグナルを受け取ります。このフラグを追加することで、このシグナルが発生するのを防ぐことができます。</td></tr>
</tbody></table>
<h3 id="9213-返り値"><a class="header" href="#9213-返り値">9.21.3 返り値</a></h3>
<p>実際に送信されたバイト数を返します。エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。実際に送信されたバイト数は、送信を要求したバイト数よりも少なくなる可能性があることに注意してください！これを回避するためのヘルパー関数については、<a href="man-pages/../slightly-advanced-techniques/handling-partial-sends.html">handling partial <code>send()</code>s</a> の章を参照してください。</p>
<p>また、どちらかの側でソケットが閉じられていた場合、<code>send()</code> を呼び出したプロセスはシグナル <code>SIGPIPE</code> を受け取ります。（ただし、<code>send()</code> が <code>MSG_NOSIGNAL</code> フラグ付きで呼び出された場合を除きます。）</p>
<h3 id="9214-例"><a class="header" href="#9214-例">9.21.4 例</a></h3>
<pre><code class="language-c">int spatula_count = 3490;
char *secret_message = &quot;The Cheese is in The Toaster&quot;;

int stream_socket, dgram_socket;
struct sockaddr_in dest;
int temp;

// first with TCP stream sockets:

// assume sockets are made and connected
//stream_socket = socket(...
//connect(stream_socket, ...

// convert to network byte order
temp = htonl(spatula_count);
// send data normally:
send(stream_socket, &amp;temp, sizeof temp, 0);

// send secret message out of band:
send(stream_socket, secret_message, strlen(secret_message)+1, MSG_OOB);

// now with UDP datagram sockets:
//getaddrinfo(...
//dest = ... // assume &quot;dest&quot; holds the address of the destination
//dgram_socket = socket(...

// send secret message normally:
sendto(dgram_socket, secret_message, strlen(secret_message)+1, 0,
       (struct sockaddr*)&amp;dest, sizeof dest);
</code></pre>
<h3 id="9215-参照"><a class="header" href="#9215-参照">9.21.5 参照</a></h3>
<p><a href="man-pages/./recv-recvfrom.html"><code>recv()</code></a>,
<a href="man-pages/./recv-recvfrom.html"><code>recvfrom()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="922-shutdown"><a class="header" href="#922-shutdown">9.22 <code>shutdown()</code></a></h1>
<p>ソケットでのさらなる送受信を停止します。</p>
<h3 id="9221-書式"><a class="header" href="#9221-書式">9.22.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int shutdown(int s, int how);
</code></pre>
<h3 id="9222-解説"><a class="header" href="#9222-解説">9.22.2 解説</a></h3>
<p>それだ！もうダメだ！このソケットではもう <code>send()</code> はできないが、<code>recv()</code> はまだしたい！その逆もしかり！どうすればいいんだ？</p>
<p>ソケット記述子を <code>close()</code> すると、読み書きのためのソケットの両側を閉じ、ソケット記述子を解放します。片方だけを閉じたい場合は、この <code>shutdown()</code> コールを使用することができます。</p>
<p>パラメータとして、<code>s</code> は当然このアクションを実行したいソケットで、どのようなアクションを実行するかは <code>how</code> パラメータで指定することができます。<code>How</code> は <code>SHUT_RD</code> でそれ以降の <code>recv()</code> を禁止したり、<code>SHUT_WR</code> でそれ以降の <code>send()</code> を禁止したり、<code>SHUT_RDWR</code> でその両方を禁止したりすることができます。</p>
<p><code>shutdown()</code> はソケット記述子を解放しないので、ソケットを完全にシャットダウンしても、最終的には <code>close()</code> しなければならないことに注意してください。</p>
<p>これは、ほとんど使われないシステムコールです。</p>
<h3 id="9223-返り値"><a class="header" href="#9223-返り値">9.22.3 返り値</a></h3>
<p>成功した場合は <code>0</code> を、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<h3 id="9224-例"><a class="header" href="#9224-例">9.22.4 例</a></h3>
<pre><code class="language-c">int s = socket(PF_INET, SOCK_STREAM, 0);

// ...do some send()s and stuff in here...

// and now that we're done, don't allow any more sends()s:
shutdown(s, SHUT_WR);
</code></pre>
<h3 id="9225-参照"><a class="header" href="#9225-参照">9.22.5 参照</a></h3>
<p><a href="man-pages/./close.html"><code>close()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="923-socket"><a class="header" href="#923-socket">9.23 <code>socket()</code></a></h1>
<p>ソケット記述子をアロケートします。</p>
<h3 id="9231-書式"><a class="header" href="#9231-書式">9.23.1 書式</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
</code></pre>
<h3 id="9232-解説"><a class="header" href="#9232-解説">9.23.2 解説</a></h3>
<p>ソケット的なことをするのに使える新しいソケット記述子を返します。これは一般に、ソケットプログラムを書くための膨大なプロセスの最初の呼び出しとなり、その後の <code>listen()</code>, <code>bind()</code>, <code>accept()</code> や他の様々な関数の呼び出しでその結果を利用することができるようになります。</p>
<p>通常の使い方では、以下の例のように <code>getaddrinfo()</code> を呼び出して、これらのパラメータの値を取得します。しかし、本当に必要であれば、手動でこれらの値を埋めることができます。</p>
<table><thead><tr><th>Macro</th><th>解説</th></tr></thead><tbody>
<tr><td><code>domain</code></td><td><code>domain</code> には、どのような種類のソケットに興味があるのかを記述します。これは様々なものがありますが、これはソケットガイドなので、IPv4では <code>PF_INET</code> 、IPv6では <code>PF_INET6</code> となります。</td></tr>
<tr><td><code>type</code></td><td>また、<code>type</code> パラメータには様々なものを指定できますが、信頼性の高い TCP ソケット（<code>send()</code>, <code>recv()</code>）には <code>SOCK_STREAM</code> を、信頼性の低い高速な UDP ソケット（<code>sendto()</code>, <code>recvfrom()</code>）には <code>SOCK_DGRAM</code> を設定することになると思われます。（もうひとつの興味深いソケットタイプは <code>SOCK_RAW</code> で、これはパケットを手動で構築するために使用することができます。これはかなりクールです。）</td></tr>
<tr><td><code>protocol</code></td><td>最後に、<code>protocol</code> パラメータは、特定のソケットタイプでどのプロトコルを使用するかを指示します。既に述べたように、例えば <code>SOCK_STREAM</code> は TCP を使用します。幸いなことに、<code>SOCK_STREAM</code> や <code>SOCK_DGRAM</code> を使用する場合は、プロトコルを <code>0</code> に設定すれば、自動的に適切なプロトコルを使用することができます。そうでない場合は、<code>getprotobyname()</code> を使用して適切なプロトコル番号を調べることができます。</td></tr>
</tbody></table>
<h3 id="9233-返り値"><a class="header" href="#9233-返り値">9.23.3 返り値</a></h3>
<p>それ以降の呼び出しで使用される新しいソケット記述子、またはエラーの場合は <code>-1</code>（それに応じて <code>errno</code> が設定されます）。</p>
<h3 id="9234-例"><a class="header" href="#9234-例">9.23.4 例</a></h3>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;     // AF_INET, AF_INET6, or AF_UNSPEC
hints.ai_socktype = SOCK_STREAM; // SOCK_STREAM or SOCK_DGRAM

getaddrinfo(&quot;www.example.com&quot;, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket using the information gleaned from getaddrinfo():
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
</code></pre>
<h3 id="9235-参照"><a class="header" href="#9235-参照">9.23.5 参照</a></h3>
<p><a href="man-pages/./accept.html"><code>accept()</code></a>,
<a href="man-pages/./bind.html"><code>bind()</code></a>,
<a href="man-pages/./getaddrinfo-freeaddrinfo-gai_strerror.html"><code>getaddrinfo()</code></a>,
<a href="man-pages/./listen.html"><code>listen()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="924-struct-sockaddr-and-pals"><a class="header" href="#924-struct-sockaddr-and-pals">9.24 <code>struct sockaddr</code> and pals</a></h1>
<p>インターネットアドレスを扱うための構造体です。</p>
<h3 id="9241-書式"><a class="header" href="#9241-書式">9.24.1 書式</a></h3>
<pre><code class="language-c">#include &lt;netinet/in.h&gt;

// All pointers to socket address structures are often cast to pointers
// to this type before use in various functions and system calls:

struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
};


// IPv4 AF_INET sockets:

struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET, AF_INET6
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;          // load with inet_pton()
};


// IPv6 AF_INET6 sockets:

struct sockaddr_in6 {
    u_int16_t       sin6_family;   // address family, AF_INET6
    u_int16_t       sin6_port;     // port number, Network Byte Order
    u_int32_t       sin6_flowinfo; // IPv6 flow information
    struct in6_addr sin6_addr;     // IPv6 address
    u_int32_t       sin6_scope_id; // Scope ID
};

struct in6_addr {
    unsigned char   s6_addr[16];   // load with inet_pton()
};


// General socket address holding structure, big enough to hold either
// struct sockaddr_in or struct sockaddr_in6 data:

struct sockaddr_storage {
    sa_family_t  ss_family;     // address family

    // all this is padding, implementation specific, ignore it:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};
</code></pre>
<h3 id="9242-解説"><a class="header" href="#9242-解説">9.24.2 解説</a></h3>
<p>これらは、インターネット・アドレスを扱うすべてのシステムコールと関数の基本構造です。多くの場合、<code>getaddrinfo()</code> を使ってこれらの構造体を埋めておき、必要なときにそれを読み出すことになります。</p>
<p>メモリ上では、<code>struct sockaddr_in</code> と <code>struct sockaddr_in6</code> は <code>struct sockaddr</code> と同じ開始構造体を共有しており、一方の型のポインタを他方に自由にキャストしても、宇宙の終焉の可能性を除けば何の害もないのです。</p>
<p>もし、<code>struct sockaddr_in*</code> を <code>struct sockaddr*</code> にキャストしたときに宇宙が終わるとしたら、それは全くの偶然であり、心配する必要はないでしょう。</p>
<p>このことを念頭に置いて、関数が <code>struct sockaddr*</code> を受け取るときはいつでも、<code>struct sockaddr_in*</code>, <code>struct sockaddr_in6*</code>, または <code>struct sockadd_storage*</code> を簡単に安全にその型にキャストできることを覚えておいてください。</p>
<p><code>sockaddr_in</code> 構造体は、IPv4 アドレス（例：&quot;192.0.2.10&quot;）で使用される構造体です。アドレスファミリ（<code>AF_INET</code>）、ポート（<code>sin_port</code>）と IPv4 アドレス（<code>sin_addr</code>）を保持します。</p>
<p>また、<code>struct sockaddr_in</code> には <code>sin_zero</code> というフィールドがあり、ある人はこれを <code>0</code> に設定しなければならないと主張しています。他の人はそれについて何も主張していませんし（Linux のドキュメントでは全く言及されていません）、 <code>0</code> に設定することは実際には必要ないように思われます。ですから、もしあなたがそうしたいと思ったら、<code>memset()</code> を使って <code>0</code> にセットしてください。</p>
<p>さて、この <code>struct in_addr</code> は、システムによって奇妙な獣のようなものです。時には、あらゆる種類の <code>#define</code> やその他のナンセンスなものを含むクレイジーな <code>union</code> になることもあります。しかし、多くのシステムでは <code>s_addr</code> フィールドしか実装されていないので、この構造体の <code>s_addr</code> フィールドのみを使用する必要があります。</p>
<p><code>struct sockadd_in6</code> と <code>struct in6_addr</code> は IPv6 で使用されることを除けば、非常によく似ています。</p>
<p><code>struct sockaddr_storage</code> は、IP バージョンに依存しないコードを書こうとしているときに、新しいアドレスが IPv4 か IPv6 か分からない場合に <code>accept()</code> や <code>recvfrom()</code> に渡すことができる構造体です。<code>struct sockaddr_storage</code> 構造体は、元の小さな <code>struct sockaddr</code> とは異なり、両方のタイプを保持するのに十分な大きさを持っています。</p>
<h3 id="9243-例"><a class="header" href="#9243-例">9.24.3 例</a></h3>
<pre><code class="language-c">// IPv4:

struct sockaddr_in ip4addr;
int s;

ip4addr.sin_family = AF_INET;
ip4addr.sin_port = htons(3490);
inet_pton(AF_INET, &quot;10.0.0.1&quot;, &amp;ip4addr.sin_addr);

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;ip4addr, sizeof ip4addr);
</code></pre>
<pre><code class="language-c">// IPv6:

struct sockaddr_in6 ip6addr;
int s;

ip6addr.sin6_family = AF_INET6;
ip6addr.sin6_port = htons(4950);
inet_pton(AF_INET6, &quot;2001:db8:8714:3a90::12&quot;, &amp;ip6addr.sin6_addr);

s = socket(PF_INET6, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;ip6addr, sizeof ip6addr);
</code></pre>
<h3 id="9244-参照"><a class="header" href="#9244-参照">9.24.4 参照</a></h3>
<p><a href="man-pages/./accept.html"><code>accept()</code></a>,
<a href="man-pages/./bind.html"><code>bind()</code></a>,
<a href="man-pages/./connect.html"><code>connect()</code></a>,
<a href="man-pages/./inet_ntoa-inet_aton-inet_addr.html"><code>inet_aton()</code></a>,
<a href="man-pages/./inet_ntoa-inet_aton-inet_addr.html"><code>inet_ntoa()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-その他の参考文献"><a class="header" href="#10-その他の参考文献">10 その他の参考文献</a></h1>
<p>ここまで来たのに、もっともっとと叫んでいるあなたへ。このようなことをもっと知るには、他にどこへ行けばいいのでしょうか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="101-書籍"><a class="header" href="#101-書籍">10.1 書籍</a></h1>
<p>昔ながらのパルプ紙を使った本をお探しなら、以下のような素晴らしい本があります。これらは、人気のある書店のアフィリエイト・リンクにリダイレクトされ、私に素敵なキックバックを与えてくれます。もしあなたが単に気前がいいと思うなら、<a href="mailto:beej@beej.us"><code>beej@beej.us</code></a> に寄付をすることができます。<code>:-)</code></p>
<p><strong>Unix Network Programming, volumes 1-2</strong>
by W. Richard Stevens. Published by Addison-Wesley Professional and
Prentice Hall.
ISBNs for volumes 1-2:
<a href="https://www.amazon.com/gp/product/0131411551/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0131411551&amp;linkId=ba1c7125a8a30d1fc24ab3f02f93df5c">978-0131411555</a>,
<a href="https://www.amazon.com/gp/product/0130810819/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0130810819&amp;linkId=fc2fc5e5a8474ac5b581c6c63eb8aab1">978-0130810816</a>.</p>
<p><strong>Internetworking with TCP/IP, volume I</strong>
by Douglas E. Comer. Published by Pearson.
ISBN <a href="https://www.amazon.com/gp/product/013608530X/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=013608530X&amp;linkId=aaecfca118e9b06368ccdad432b0d8bc">978-0136085300</a>.</p>
<p><strong>TCP/IP Illustrated, volumes 1-3</strong>
by W. Richard Stevens and Gary R. Wright. Published by Addison Wesley.
ISBNs for volumes 1, 2, and 3 (and a 3-volume set):
<a href="https://www.amazon.com/gp/product/0201633469/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0201633469&amp;linkId=f55f46bf364eecf439b08a9be4dda3aa">978-0201633467</a>,
<a href="https://www.amazon.com/gp/product/020163354X/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=020163354X&amp;linkId=b34bedba0db53401aa57e45e8848ef2c">978-0201633542</a>,
<a href="https://www.amazon.com/gp/product/0201634953/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0201634953&amp;linkId=2174bc77a388d8852cd17c192ec75ae3">978-0201634952</a>,
(<a href="https://www.amazon.com/gp/product/0201776316/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0201776316&amp;linkId=a5159b2a189c17f1e0f85a92a18e2899">978-0201776317</a>).</p>
<p><strong>TCP/IP Network Administration</strong>
by Craig Hunt. Published by O'Reilly &amp; Associates, Inc.
ISBN <a href="https://www.amazon.com/gp/product/0596002971/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0596002971&amp;linkId=6f4e59df75ab25433cfa7d0b8c22ea87">978-0596002978</a>.</p>
<p><strong>Advanced Programming in the UNIX Environment</strong>
by W. Richard Stevens. Published by Addison Wesley.
ISBN <a href="https://www.amazon.com/gp/product/0321637739/ref=as_li_tl?ie=UTF8&amp;tag=beejus0c-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0321637739&amp;linkId=11b244a6429ec3f2a53b9333aaa24d94">978-0321637734</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="102-web-参考文献"><a class="header" href="#102-web-参考文献">10.2 Web 参考文献</a></h1>
<p>ウェブで：</p>
<p><strong><a href="https://cis.temple.edu/%7Egiorgio/old/cis307s96/readings/docs/sockets.html">BSD Sockets: A Quick And Dirty Primer</a></strong>
（Unixシステムのプログラミング情報も！）</p>
<p><strong><a href="https://developerweb.net/?f=70">The Unix Socket FAQ</a></strong></p>
<p><strong><a href="http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/">TCP/IP FAQ</a></strong></p>
<p><strong><a href="https://tangentsoft.net/wskfaq/">The Winsock FAQ</a></strong></p>
<p>そして、関連する Wikipedia のページを紹介します。</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley Sockets</a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol (IP)</a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol (TCP)</a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol (UDP)</a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Client-server">Client-Server</a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Serialization">Serialization</a></strong>（パッキングとアンパッキングデータ）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="103-rfcs"><a class="header" href="#103-rfcs">10.3 RFCs</a></h1>
<p>RFCs
---本当の汚れ！これは、割り当てられた番号、プログラミング API、インターネット上で使用されるプロトコルについて記述した文書です。ここでは、いくつかの RFC へのリンクを掲載しますので、ポップコーンを片手に考える帽子をかぶって楽しんでください。</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc1">RFC 1</a></strong>
---最初の RFC。これは、&quot;インターネット&quot; が誕生したばかりの頃、どのようなものだったのか、そして、どのように一から設計されていたのかを知ることができます。（この RFC は、明らかに完全に時代遅れです！）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc768">RFC 768</a></strong>
---ユーザーデータグラムプロトコル（UDP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc791">RFC 791</a></strong>
---インターネットプロトコル（IP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc793">RFC 793</a></strong>
---伝送制御プロトコル（TCP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc854">RFC 854</a></strong>
---テルネットプロトコル</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc959">RFC 959</a></strong>
---ファイル転送プロトコル（FTP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc1350">RFC 1350</a></strong>
---些細なフィル転送プロトコル（TFTP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc1459">RFC 1459</a></strong>
---Internet Relay Chat Protocol（IRC）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a></strong>
---プライベートインターネットにおけるアドレスの割り当て</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc2131">RFC 2131</a></strong>
---Dynamic Host Configuration Protocol（DHCP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC 2616</a></strong>
---ハイパーテキスト転送プロトコル（HTTP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc2821">RFC 2821</a></strong>
---簡易メール転送プロトコル（SMTP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc3330">RFC 3330</a></strong>
---特殊用途のIPv4アドレス</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc3493">RFC 3493</a></strong>
---IPv6のための基本的なソケットインタフェース拡張</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc3542">RFC 3542</a></strong>
--- IPv6用の拡張ソケットアプリケーション・プログラム・インターフェース（API）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc3849">RFC 3849</a></strong>
---ドキュメンテーションのためのIPv6アドレスプレフィックス予約</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc3920">RFC 3920</a></strong>
---拡張可能なメッセージングおよびプレゼンスプロトコル（XMPP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc3977">RFC 3977</a></strong>
---ネットワークニュース転送プロトコル（NNTP）</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc4193">RFC 4193</a></strong>
---ユニークローカルIPv6ユニキャストアドレス</p>
<p><strong><a href="https://datatracker.ietf.org/doc/html/rfc4506">RFC 4506</a></strong>
---外部データ表現標準（XDR）</p>
<p>IETF には、<a href="https://tools.ietf.org/rfc/">RFC の検索とブラウズ</a>のための素晴らしいオンラインツールがあります。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="src/theme/theme-solarized_dark.js"></script>
        <script type="text/javascript" src="src/theme/theme-solarized_light.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
