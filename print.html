<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Beej のネットワークプログラミング入門</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/solarized-light-hljs.css">
        <link rel="stylesheet" href="theme/solarized-dark-hljs.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Home</a></li><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> 序説</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/audience.html"><strong aria-hidden="true">1.1.</strong> 対象読者</a></li><li class="chapter-item expanded "><a href="intro/platform-and-compiler.html"><strong aria-hidden="true">1.2.</strong> プラットフォームとコンパイラ</a></li><li class="chapter-item expanded "><a href="intro/official-homepage-and-books-for-sale.html"><strong aria-hidden="true">1.3.</strong> 公式ホームページと販売書籍</a></li><li class="chapter-item expanded "><a href="intro/note-for-solaris-sunos-programmers.html"><strong aria-hidden="true">1.4.</strong> Solaris/SunOS プログラマへの注意事項</a></li><li class="chapter-item expanded "><a href="intro/note-for-windows-programmers.html"><strong aria-hidden="true">1.5.</strong> Windows プログラマへの注意事項</a></li><li class="chapter-item expanded "><a href="intro/email-policy.html"><strong aria-hidden="true">1.6.</strong> メールポリシー</a></li><li class="chapter-item expanded "><a href="intro/mirroring.html"><strong aria-hidden="true">1.7.</strong> ミラーリング</a></li><li class="chapter-item expanded "><a href="intro/note-for-translators.html"><strong aria-hidden="true">1.8.</strong> 翻訳者への注意事項</a></li><li class="chapter-item expanded "><a href="intro/copyright-distribution-and-legal.html"><strong aria-hidden="true">1.9.</strong> 著作権・配布・法的事項</a></li><li class="chapter-item expanded "><a href="intro/dedication.html"><strong aria-hidden="true">1.10.</strong> 献辞</a></li><li class="chapter-item expanded "><a href="intro/publishing-information.html"><strong aria-hidden="true">1.11.</strong> 出版情報</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-a-socket/index.html"><strong aria-hidden="true">2.</strong> ソケットとは？</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-a-socket/two-types-of-internet-sockets.html"><strong aria-hidden="true">2.1.</strong> 2種類のインターネットソケット</a></li><li class="chapter-item expanded "><a href="what-is-a-socket/low-level-nonsense-and-network-theory.html"><strong aria-hidden="true">2.2.</strong> 低レベルのナンセンスとネットワーク理論</a></li></ol></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/index.html"><strong aria-hidden="true">3.</strong> IP アドレス, 構造体, データマンジング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/ip-addresses-versions-4-and-6.html"><strong aria-hidden="true">3.1.</strong> IP アドレス、バージョン4と6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/subnets.html"><strong aria-hidden="true">3.1.1.</strong> サブネット</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/port-munbers.html"><strong aria-hidden="true">3.1.2.</strong> ポート番号</a></li></ol></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/byte-order.html"><strong aria-hidden="true">3.2.</strong> バイトオーダー</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/structs.html"><strong aria-hidden="true">3.3.</strong> 構造体</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/ip-addresses-part-deux.html"><strong aria-hidden="true">3.4.</strong> IP アドレス、パート2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/private-or-disconnected-networks.html"><strong aria-hidden="true">3.4.1.</strong> プライベート（またはディスコネクト）ネットワーク</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="jumping-from-ipv4-to-ipv6/index.html"><strong aria-hidden="true">4.</strong> IPv4 から IPv6 へのジャンプ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="solarized-light">Solarized Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="solarized-dark">Solarized Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Beej のネットワークプログラミング入門</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/solareenlo/bgnet" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 align="center">Beej のインターネットソケットを利用したネットワークプログラミング入門</h1>
<p align="center">
Brian “Beej Jorgensen” Hall
</p>
<p align="center">
v3.1.5, Copyright © November 20, 2020
</p>
<h2 id="ここは何"><a class="header" href="#ここは何">ここは何？</a></h2>
<p><a href="https://beej.us/guide/bgnet/html/">https://beej.us/guide/bgnet/html/</a> の日本語訳</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://beej.us/guide/bgnet/">https://beej.us/guide/bgnet/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-序説"><a class="header" href="#1-序説">1 序説</a></h1>
<p>おいおい、ソケットプログラミングで参ってるのか？このようなことは <code>man</code> ページから理解するには少し難しすぎるのではありませんか？クールなインターネットプログラミングをしたいけど、<code>connect()</code> の前に <code>bind()</code> を呼ばないといけないのか、などなど、<code>struct</code> のゴブをかき分けている時間はないでしょう。</p>
<p>さて、どうでしょう！？私はもうこの厄介なビジネスをやり遂げました。そして、この情報をみんなと共有したくてたまらないのです！あなたは正しい場所に来たのです。この文書は、平均的な有能なCプログラマーが、このネットワーク・ノイズに対処するために必要なエッジを与えてくれるはずです。</p>
<p>そして、チェックしてみてください。私はついに未来に追いつき、（ちょうどいいタイミングで！）IPv6用にガイドを更新しました。お楽しみに！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-対象読者"><a class="header" href="#11-対象読者">1.1 対象読者</a></h1>
<p>このドキュメントは、完全なリファレンスではなく、チュートリアルとして書かれています。 ソケットプログラミングを始めたばかりで、足がかりを探している人が読むと、おそらく最適なものになるでしょう。ソケットプログラミングの完全なガイドではありません。</p>
<p>でも、うまくいけば、あのマニュアルページが意味を持ち始めるかもしれませんね...。<code>:-)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-プラットフォームとコンパイラ"><a class="header" href="#12-プラットフォームとコンパイラ">1.2 プラットフォームとコンパイラ</a></h1>
<p>この文書に含まれるコードは、Gnu の <code>gcc</code> コンパイラを使用して Linux PC でコンパイルされています。しかし、<code>gcc</code>を使うプラットフォームであれば、ほぼ全てのプラットフォームでビルドできるはずです。当然ながら、Windows 用のプログラミングには適用されません。以下の<a href="intro/docs/intro/#windows">section on Windows programming</a>を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-公式ホームページと販売書籍"><a class="header" href="#13-公式ホームページと販売書籍">1.3 公式ホームページと販売書籍</a></h1>
<p>このドキュメントの正式な所在地は</p>
<ul>
<li><a href="https://beej.us/guide/bgnet/"><code>https://beej.us/guide/bgnet/</code></a></li>
</ul>
<p>また、サンプルコードや様々な言語への翻訳も掲載されています。</p>
<p>製本された印刷物（&quot;本&quot;と呼ぶ人もいる）を購入するには、以下をご覧ください。</p>
<ul>
<li><a href="https://beej.us/guide/url/bgbuy"><code>https://beej.us/guide/url/bgbuy</code></a></li>
</ul>
<p>文書作成生活の維持に役立つので、購入はありがたいです！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-solarissunos-プログラマへの注意事項"><a class="header" href="#14-solarissunos-プログラマへの注意事項">1.4 Solaris/SunOS プログラマへの注意事項</a></h1>
<p>Solaris または SunOS 用にコンパイルする場合、適切なライブラリをリンクするために、いくつかの特別なコマンドラインスイッチを指定する必要があります。これを行うには、コンパイルコマンドの最後に &quot;<code>-lnsl -lsocket -lresolv</code>&quot; を以下のように追加するだけです。</p>
<pre><code>$ cc -o server server.c -lnsl -lsocket -lresolv
</code></pre>
<p>それでもエラーが出るようなら、さらにそのコマンドラインの最後に <code>-lxnet</code> を追加してみるといいでしょう。それが何をするのか正確にはわかりませんが、必要な人もいるようです。</p>
<p>もう一つ問題がありそうなのは、<code>setsockopt()</code> の呼び出しのところです。プロトタイプは私の Linux ボックスのものとは異なるので、代わりに</p>
<pre><code class="language-c">int yes=1;
</code></pre>
<pre><code class="language-c">char yes='1';
</code></pre>
<p>を入力します。</p>
<p>私は Sunbox を持っていないので、上記の情報を検証したわけではありません---あくまでメールで教えてもらったことです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-windows-プログラマへの注意事項"><a class="header" href="#15-windows-プログラマへの注意事項">1.5 Windows プログラマへの注意事項</a></h1>
<p>このガイドの時点では、歴史的に、私が Windows をあまり好きではないという事実のために、Windows を少し非難しています。しかし、Windows は膨大なインストールベースがあり、明らかに完璧なオペレーティングシステムであることを公平にお伝えする必要があります。</p>
<p>不在は心を豊かにすると言いますが、この場合、私はそれが真実であると信じています。(ただ、言えることは、10数年前から個人的な仕事ではマイクロソフトのOSを使っていなかったので、ずっと幸せだということです だから、安心して、&quot;どうぞ、ご自由に Windows を使ってください！&quot;と言えるのです。 ...そう、歯ぎしりしながら言うんですけどね。</p>
<p>ですから私は、<a href="https://www.linux.com/">Linux</a> や <a href="https://bsd.org/">BSD</a>、あるいは Unix のいくつかのフレーバーを、代わりに試してみることをお勧めします。</p>
<p>しかし、人は好きなものを好きになるものです。Windows の皆さんは、この情報が、もしあれば、いくつかの小さな変更を加えて、あなた方にも一般的に適用できることを知って喜んでいることでしょう。</p>
<p>Windows 用の Unix ツールの集合体である <a href="https://cygwin.com/">Cygwin</a> をインストールするのもいい方法です。そうすると、これらのプログラムはすべて修正なしでコンパイルできるようになると、人づてに聞いたことがあります。</p>
<p>もうひとつ、<a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux</a> も検討してみてください。これは基本的に、Windows 10 に Linux の VM 的なものをインストールすることができます。これもまた、間違いなく位置づけられるでしょう。</p>
<p>しかし、中には純粋な Windows のやり方で物事を進めたいと思う人もいるかもしれません。それはとてもガッツのあることで、こうすればいいんです。すぐに Unix を買ってきてください! いやいや---冗談です。最近は Windows フレンドリー(笑)なはずなんですが...。</p>
<p>これは、あなたがしなければならないことです（<a href="intro/">Cygwin</a>をインストールしない限り！）：まず、ここで私が言及するシステムヘッダーファイルのほとんどを無視してください。あなたがインクルードする必要があるのは、以下のものだけです。</p>
<pre><code class="language-c">#include &lt;winsock.h&gt;
</code></pre>
<p>待ってください！ソケットライブラリで何かする前に <code>WSAStartup()</code> を呼び出す必要があります。これを行うためのコードは以下のようなものです。</p>
<pre><code class="language-c editable">#include &lt;winsock.h&gt;

{
    WSADATA wsaData;   // if this doesn't work
    //WSAData wsaData; // then try this instead

    // MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:

    if (WSAStartup(MAKEWORD(1,1), &amp;wsaData) != 0) {
        fprintf(stderr, &quot;WSAStartup failed.\n&quot;);
        exit(1);
    }
</code></pre>
<p>また、Winsock ライブラリをリンクするようにコンパイラに指示する必要があります。通常、<code>wsock32.lib</code> または <code>winsock32.lib</code>、Winsock 2.0 の場合は <code>ws2_32.lib</code> と呼ばれます。VC++ では、これは <code>Project</code> メニューの <code>Settings...</code> から行うことができます。<code>Link</code> タブをクリックし、&quot;Object/library modules&quot; というタイトルのボックスを探します。そのリストに &quot;wsock32.lib&quot;（または、お好みの lib）を追加してください。</p>
<p>とか聞いています。</p>
<p>最後に、ソケットライブラリを使い終わったら、<code>WSACleanup()</code> を呼び出す必要があります。詳しくはオンラインヘルプを参照してください。</p>
<p>一度これを行えば、このチュートリアルの残りの例は、いくつかの例外を除いて、概ね適用できるはずです。ひとつは、ソケットを閉じるために <code>close()</code> を使うことができません。また、<code>select()</code> はソケットディスクリプタに対してのみ動作し、ファイルディスクリプタに対しては動作しません (<code>stdin</code> に対する <code>0</code> のように)。</p>
<p>また、<code>CSocket</code> というソケットクラスもあります。詳細はコンパイラのヘルプを参照してください。</p>
<p>Winsock についての詳しい情報は、<a href="https://tangentsoft.net/wskfaq/">Winsock FAQ</a> を読んで、そこから進んでください。</p>
<p>最後に、Windows には <code>fork()</code> システムコールがないそうですが、これは残念ながら私の例のいくつかで使われているものです。多分、POSIX ライブラリか何かをリンクしないと動かないでしょうし、代わりに <code>CreateProcess()</code> を使ってもいいでしょう。<code>fork()</code> は引数を取らず、<code>CreateProcess()</code> は約480億の引数を取ります。もし、そこまで気が回らないのであれば、<code>CreateThread()</code> の方が少し消化しやすいでしょう。残念ながら、マルチスレッドに関する議論はこのドキュメントの範囲外です。私が語れることは限られているのですからね!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-メールポリシー"><a class="header" href="#16-メールポリシー">1.6 メールポリシー</a></h1>
<p>メールでの質問には基本的に対応しますので、気軽に書き込んでください。ただし、返事を保証するものではありません。私はかなり忙しい生活を送っているので、どうしても質問に答えられないことがあります。そのような場合は、メッセージを削除します。個人的なことではなく、あなたが必要とする詳細な回答をする時間がないだけなのです。</p>
<p>原則として、質問が複雑であればあるほど、回答できる可能性は低くなります。質問を送る前に質問を絞り込み、関連する情報（プラットフォーム、コンパイラ、表示されるエラーメッセージなど、トラブルシューティングに役立ちそうなもの）を必ず記載していただければ、回答が得られる可能性は高くなります。より詳しい情報は、ESRのドキュメント、<a href="http://www.catb.org/%7Eesr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a> をお読みください。</p>
<p>返事がない場合は、もう少し調べてみて、答えが見つからなければ、また調べてみてください。そして調べたことまたを書き込んでください。その結果、私がお手伝いできるようになることを期待しています。</p>
<p>さて、手紙の書き方、書き方についておせっかいを焼いてしまいましたが、このガイドが何年にもわたって賞賛されてきたことに、私は十分に感謝していることをお伝えしておきたいと思います。このガイドが良いことに使われていると聞いて、私はとても嬉しくなりました。<code>:-)</code> ありがとうございます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-ミラーリング"><a class="header" href="#17-ミラーリング">1.7 ミラーリング</a></h1>
<p>このサイトをミラーリングすることは、公的にも私的にも大歓迎です。もし、あなたがこのサイトを公的にミラーリングし、メインページからリンクしてほしい場合は、<code>beej@beej.us</code> までご連絡ください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-翻訳者への注意事項"><a class="header" href="#18-翻訳者への注意事項">1.8 翻訳者への注意事項</a></h1>
<p>もし、このガイドを他の言語に翻訳したい場合は、<code>beej@beej.us</code> までメールをいただければ、メインページからあなたの翻訳をリンクさせていただきます。翻訳にはあなたの名前と連絡先を自由に追加してください。</p>
<p>このソースマークダウン文書は UTF-8 エンコーディングを使用しています。</p>
<p>後述の <a href="intro/note-for-translators.html#legal">Copyright, Distribution, and Legal</a> に記載されている使用許諾条件にご注意ください。</p>
<p>もし私に翻訳をホストして欲しいのであれば、言ってください。また、あなたがホストすることを望むなら、私はそれにリンクします；どちらでも構いません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-著作権配布法的事項"><a class="header" href="#19-著作権配布法的事項">1.9 著作権・配布・法的事項</a></h1>
<pre><code class="language-text">Beej's Guide to Network Programming is Copyright © 2019 Brian &quot;Beej Jorgensen&quot; Hall.
</code></pre>
<p>この作品は、以下のソースコードと翻訳に関する特定の例外を除き、クリエイティブ・コモンズ 表示-非営利-改変禁止 3.0 ライセンスの下に提供されています。このライセンスのコピーを見るには、以下をご覧ください。</p>
<p><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/"><code>https://creativecommons.org/licenses/by-nc-nd/3.0/</code></a></p>
<p>または、Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA に手紙を送ってください。</p>
<p>本使用許諾の&quot;二次的著作物の禁止&quot;部分の具体的な例外は、次のとおりです：このガイドは、翻訳が正確である限り、どの言語にも自由に翻訳でき、ガイド全体を再印刷することができます。翻訳には、オリジナルのガイドと同じライセンスの制約が適用されます。翻訳には、翻訳者の名前と連絡先も含めることができます。</p>
<p>本書で紹介する C 言語のソースコードは、パブリックドメインとして許諾され、いかなるライセンス制限もありません。</p>
<p>教育関係者は、このガイドを生徒に勧めたり、コピーを提供したりすることを自由に推奨します。</p>
<p>書面による相互の合意がない限り、著者は作品を現状のまま提供し、作品に関して、明示的、黙示的、法定またはその他のいかなる種類の表明または保証（権利、商品性、特定目的への適合性、非侵害、潜在的またはその他の欠陥の不在、精度、または発見可能かどうかにかかわらず誤りの有無の保証を含むが、これに限定されない）も行わないものとします。</p>
<p>適用される法律で要求される範囲を除き、いかなる場合においても、著作者は、著作物の使用から生じる特別損害、付随的損害、結果的損害、懲罰的損害または典型的損害について、たとえ著作者がその損害の可能性を知らされていたとしても、いかなる法的理論によってもお客様に対して責任を負うことはないものとします。</p>
<p>お問い合わせは <code>beej@beej.us</code> までお願いします。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="110-献辞"><a class="header" href="#110-献辞">1.10 献辞</a></h1>
<p>このガイドを書くにあたり、過去から未来にわたって協力してくださった皆様に感謝します。そして、私がこのガイドを作るために使っているフリーソフトやパッケージを制作しているすべての人に感謝します。GNU、Linux、Slackware、vim、Python、Inkscape、pandoc、その他多数。そして最後に、文字通り何千もの人々が、改善の提案や励ましの言葉を書いてくれたことに、大きな感謝を捧げます。</p>
<p>このガイドを、コンピュータの世界における私の最大のヒーローであり、インスピレーターである何人かに捧げます。Donald Knuth、Bruce Schneier、W. Richard Stevens、The Woz、そして私の読者、さらにフリーおよびオープンソースソフトウェアのコミュニティ全体に捧げます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-出版情報"><a class="header" href="#111-出版情報">1.11 出版情報</a></h1>
<p>この本は、GNU ツールを搭載した Arch Linux のマシン上で vim エディタを使って、Markdown で書かれています。表紙の&quot;アート&quot;とダイアグラムは Inkscape で作成されています。Markdown は Python、Pandoc および XeLaTeX により、Liberation フォントを用いて HTML および LaTex/PDF に変換されます。このツールチェーンは 100% フリーおよびオープンソースソフトウェアで構成されています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-ソケットとは"><a class="header" href="#2-ソケットとは">2 ソケットとは？</a></h1>
<p>&quot;ソケット&quot;という言葉をよく耳にしますが、そもそも&quot;ソケット&quot;とは何なのでしょうか？それは、標準的な Unix のファイルディスクリプタを使って他のプログラムと会話するための方法です。</p>
<p>なんと？</p>
<p>Ok--- Unix のハッカーが &quot;Unix では何でもファイルなんだ！&quot;と言ったのを聞いたことがあるかもしれません。その人が言っているのは、Unix のプログラムが何らかの I/O を行うとき、ファイル記述子に対して読み書きを行うという事実のことかもしれません。ファイルディスクリプタは、単純に、開いているファイルに関連する整数です。しかし、このファイルは、ネットワーク接続、FIFO、パイプ、ターミナル、ディスク上のファイルなど、あらゆるものになり得ます（ここが重要）。Unix ではすべてがファイルなのです！だから、インターネット上で他のプログラムと通信したいときは、ファイル記述子を介して行うことになるんだ。と思ってください。</p>
<p>&quot;ネットワーク通信のためのファイルディスクリプタはどこで手に入るのですか、お利口さん？&quot;というのが、今あなたが考えている最後の質問でしょうが、とにかくそれに答えてあげましょう。あなたは <code>socket()</code> システムルーチンを呼び出すのです。このルーチンはソケットディスクリプタを返すので、それを使って <code>send()</code> と <code>recv()</code> (<a href="what-is-a-socket/docs/man-pages/#sendman"><code>man send</code></a>, <a href="what-is-a-socket/docs/man-pages/#recvman"><code>man recv</code></a>) という特別なソケットコールを使って通信を行います。</p>
<p>&quot;でもね！&quot;あなたは今頃、そう叫んでいるかもしれません。&quot;ファイルディスクリプタなら、どうしてネプチューンの名において、通常の <code>read()</code> と <code>write()</code> の呼び出しでソケットを通して通信できないんだ？&quot;と。短い答えは、&quot;できる！&quot;です。もっと長い答えは、&quot;できるけど、<code>send()</code> と <code>recv()</code> はデータ転送をより大きく制御できる &quot;です。</p>
<p>次は何？どうでしょう、ソケットにはいろいろな種類がありますね。DARPA インターネットアドレス (インターネットソケット)、ローカルノード上のパス名 (Unix ソケット)、CCITT X.25 アドレス (X.25 ソケット、無視しても大丈夫)、そしておそらくあなたが実行する Unix のフレーバーに応じて他の多くの種類があります。この文書では、最初の&quot;インターネットソケット&quot;のみを扱います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-2種類のインターネットソケット"><a class="header" href="#21-2種類のインターネットソケット">2.1 2種類のインターネットソケット</a></h1>
<p>これは何？インターネットソケットには2種類ある？そうです。まあ、違うけど。嘘です。もっとあるんだけど、怖がらせたくなかったんだ。 ここでは2種類しか話しません。ただし、この文章では、&quot;Raw Sockets&quot; も非常に強力なので、ぜひ調べてみてくださいと言うつもりです。</p>
<p>わかったよ、もう。この2つのタイプは何ですか？一つは&quot;ストリームソケット&quot;、もう一つは&quot;データグラムソケット&quot;で、以下、それぞれ &quot;<code>SOCK_STREAM</code>&quot; &quot;<code>SOCK_DGRAM</code>&quot; と呼ぶことがあります。データグラムソケットは&quot;コネクションレス型ソケット&quot;と呼ばれることもあります 。(ただし、本当に必要であれば <code>connect()'</code> を使用することができます。後述の <a href="what-is-a-socket/two-types-of-internet-sockets.html#connect"><code>connect()</code></a> を参照してください)。</p>
<p>ストリームソケットは、信頼性の高い双方向接続の通信ストリームです。ソケットに2つのアイテムを &quot;1, 2&quot; という順序で出力すると、反対側にも &quot;1, 2&quot; という順序で届きます。また、エラーも発生しません。実際、私はエラーフリーであることを確信しています。もし、そうでないと主張する人がいたら、耳に指を突っ込んで&quot;ララララ&quot;と唱えてやりたいくらいだ。</p>
<p>何がストリーム・ソケットを使うのでしょうか？さて、皆さんは <code>telnet</code> というアプリケーションをご存知でしょうか？あれはストリームソケットを使っているんだ。あなたが入力した文字は、すべて入力した順番に到着する必要がありますよね？また、Webブラウザは HTTP(Hypertext Transfer Protocol) を使っていますが、これはストリームソケットを使ってページを取得します。実際、80番ポートで Web サイトに telnet して、&quot;<code>GET / HTTP/1.0</code>&quot; と入力してリターンを2回押すと、HTML がダンプされて戻ってきますよ。</p>
<p>もし <code>telnet</code> がインストールされておらず、インストールもしたくない場合、あるいは <code>telnet</code> がクライアントとの接続にうるさい場合、ガイドには <a href="https://beej.us/guide/bgnet/examples/telnot.c"><code>telnot</code></a> という <code>telnet</code> に似たプログラムが付属しています。これは、このガイドで必要なものすべてに対してうまく機能するはずです。(なお、telnet は実際には <a href="https://datatracker.ietf.org/doc/html/rfc854">spec'd networking protocol</a> であり、<code>telnot</code> はこのプロトコルを全く実装していません)。</p>
<p>ストリームソケットは、どのようにしてこの高いレベルのデータ伝送品質を実現しているのでしょうか。 それは、&quot;TCP&quot; として知られる&quot;伝送制御プロトコル&quot;(TCP の詳細については <a href="https://datatracker.ietf.org/doc/html/rfc793">RFC 793</a> を参照)というプロトコルを使用しているからです。TCP はデータが順次、エラーなく到着することを確認します。&quot;TCP&quot; は &quot;TCP/IP&quot; の半分で、&quot;IP&quot; は &quot;Internet Protocol&quot;（<a href="https://datatracker.ietf.org/doc/html/rfc791">RFC 791</a> を参照）の略だと聞いたことがあるかもしれません。IP は主にインターネット・ルーティングを扱い、一般にデータの完全性には責任を持ちません。</p>
<p>かっこいい。データグラムソケットについてはどうでしょうか？なぜコネクションレス型と呼ばれるのでしょうか？どうなっているんだ？なぜ信頼性が低いのでしょうか？データグラムを送ると、それが届くかもしれません。データグラムを送信すると、それは到着するかもしれません。もし到着すれば、パケット内のデータはエラーフリーです。</p>
<p>データグラムソケットもルーティングに IP を使いますが、TCP は使わず、&quot;User Datagram Protocol&quot;、つまり &quot;UDP&quot; を使います（<a href="https://datatracker.ietf.org/doc/html/rfc768">RFC 768</a> を参照）。</p>
<p>なぜコネクションレスレスなのか？まあ、基本的には、ストリームソケットのようにオープンな接続を維持する必要がないからです。パケットを作り、その上に宛先情報を含む IP ヘッダを貼り付け、送信するだけでいいのです。コネクションは必要ありません。一般的には、TCP スタックが利用できないときや、パケットをいくつか落としても宇宙の終わりを意味しないときに使用されます。サンプルアプリケーション: <code>tftp</code> (FTP の弟分のようなファイル転送プロトコル)、<code>dhcpcd</code> (DHCP クライアント)、マルチプレイヤーゲーム、ストリーミングオーディオ、ビデオ会議、などなど。</p>
<p>&quot;ちょっと待った！<code>tftp</code> と <code>dhcpcd</code> はバイナリアプリケーションをあるホストから別のホストに転送するために使われるんだ！アプリケーションが到着したときに動作することを期待するならば、データが失われることはありえない！これはどんな黒魔術なんだ？&quot;</p>
<p>さて、私の人間の友人である <code>tftp</code> やそれに類するプログラムは、UDP の上に独自のプロトコルを載せています。たとえば、tftp プロトコルは、送信されたパケットごとに、受信者は&quot;受け取ったよ！&quot;というパケットを送り返さなければならない、と言っています。というパケット(&quot;ACK&quot; パケット)を送り返さなければなりません。元のパケットの送信者は、例えば5秒間返信がない場合、最終的に ACK を得るまでパケットを再送信することになります。この確認手続きは、信頼性の高い <code>SOCK_DGRAM</code> アプリケーションを実装する際に非常に重要です。</p>
<p>ゲーム、オーディオ、ビデオなどの信頼性の低いアプリケーションでは、ドロップしたパケットを無視するか、あるいは巧みに補うようにします。(Quake プレイヤーは、この効果の発現を呪われたラグという専門用語で知っていることでしょう。 この場合の&quot;呪われた&quot;という単語は、非常に不敬な発言を意味します)。</p>
<p>なぜ信頼性の低い基礎プロトコルを使うのでしょうか？理由は2つ、速度とスピードです。何が無事に到着したかを追跡し、順序立てて確認したりするよりも、発射して忘れる方がずっと速いのです。チャットメッセージを送るなら、TCP は素晴らしいです。世界中のプレイヤーの位置情報を毎秒40件送るなら、1件や2件が落ちてもそれほど問題ではないので、UDP は良い選択だと思います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-低レベルのナンセンスとネットワーク理論"><a class="header" href="#22-低レベルのナンセンスとネットワーク理論">2.2 低レベルのナンセンスとネットワーク理論</a></h1>
<p>先ほどプロトコルの階層化について触れましたので、そろそろネットワークが実際にどのように動作するのか、そして <code>SOCK_DGRAM</code> パケットがどのように構築されるのかについて、いくつかの例を挙げて説明しましょう。 実際のところ、このセクションは読み飛ばしても大丈夫でしょう。しかし、良い背景にはなります。</p>
<figure>
  <img
  src="images/dataencap.svg"
  alt="[Encapsulated Protocols Diagram]">
  <figcaption>データのカプセル化</figcaption>
</figure>
<p>子供たちよ、データカプセル化について学ぶ時間だ！これはとても重要なことです。あまりに重要なので、このチコステでネットワークの授業を受けると、このことを学ぶことになるかもしれません <code>;-)</code>. 基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えば TFTP プロトコル）によってヘッダー（まれにフッターも）でラップ（&quot;カプセル化&quot;）され、次のプロトコル（例えば UDP）によって全体（TFTP ヘッダーも含む）が再びカプセル化され、さらに次のプロトコル（IP）によってカプセル化され、ハードウェア（物理）層（例えば Ethernet）の最終プロトコルによって再びカプセル化されます。</p>
<p>他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルが IP と UDP ヘッダを、TFTP プログラムが TFTP ヘッダを取り除き、ようやくデータを手に入れることができます。</p>
<p>これでやっと悪名高いレイヤードネットワークモデル（通称 &quot;ISO/OSI&quot;）について語れるようになりました。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。</p>
<p>さっそくですが、本格的なモデルのレイヤーを紹介します。 ネットワーククラスの試験のために覚えておいてください。</p>
<ul>
<li>アプリケーション層</li>
<li>プレゼンテーション層</li>
<li>セッション層</li>
<li>トランスポート層</li>
<li>ネットワーク層</li>
<li>データリンク層</li>
<li>物理層</li>
</ul>
<p>物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと相互作用する場所です。</p>
<p>さて、このモデルは、本当にやろうと思えば、自動車の修理ガイドとして使えるほど一般的なものです。Unix とより整合性のあるレイヤーモデルは、次のようなものでしょう。</p>
<ul>
<li>アプリケーション層 (<em>telnet, ftp, etc.</em>)</li>
<li>Host-to-Host トランスポート層 (<em>TCP, UDP</em>)</li>
<li>インターネット層 (<em>IP and routing</em>)</li>
<li>ネットワークアクセス層 (<em>Ethernet, wi-fi, or whatever</em>)</li>
</ul>
<p>この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。</p>
<p>シンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ！そして、&quot;<code>cat</code>&quot; を使って自分でパケットヘッダを入力しなければならないのです！冗談です。ストリームソケットでやるべきことは、データを <code>send()</code> することだけです。データグラムソケットでは、あなたが選んだメソッドでパケットをカプセル化し、<code>sendto()</code> で送り出すだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築します。ああ、現代の技術ですね。</p>
<p>というわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていました：何もありません！（笑）。その通り、全く話すつもりはありません。ルータはパケットを IP ヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、<a href="https://datatracker.ietf.org/doc/html/rfc791">IP RFC</a> をチェックしてみてください。もしあなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-ip-アドレス-構造体-データマンジング"><a class="header" href="#3-ip-アドレス-構造体-データマンジング">3 IP アドレス, 構造体, データマンジング</a></h1>
<p>ここからは気分転換にコードの話をするところです。</p>
<p>その前に、もっとノンコードの話をしましょう！イエーイ！まず最初に IP アドレスとポートについて少しお話したいと思いますので、それを整理します。それからソケット API がどのように IP アドレスや他のデータを保存し、操作するかについて話します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-ip-アドレスバージョン4と6"><a class="header" href="#31-ip-アドレスバージョン4と6">3.1 IP アドレス、バージョン4と6</a></h1>
<p>ベン・ケノービがまだオビワン・ケノービと呼ばれていた頃、インターネット・プロトコル・バージョン4（IPv4）と呼ばれる素晴らしいネットワーク・ルーティング・システムが存在しました。IPv4 は 4 バイト（4オクテット）で構成されるアドレスで、一般に「ドットと数字」で表記されるのが一般的でした。<code>192.0.2.111</code> のように。</p>
<p>皆さんも一度は目にしたことがあるのではないでしょうか。</p>
<p>実際、この記事を書いている時点では、インターネット上のほぼすべてのサイトが IPv4 を使っています。</p>
<p>オビ・ワンをはじめ、誰もが幸せでした。しかし、ヴィント・サーフという名の否定的な人物が、IPv4 アドレスが足りなくなると警告を発したのです！</p>
<p>(<a href="https://en.wikipedia.org/wiki/Vint_Cerf">ヴィント・サーフ</a>氏は、IPv4 による「破滅と暗黒の黙示録」の到来を警告するとともに、「インターネットの父」としても有名です。だから、私は彼の判断に二の足を踏む立場にはないのだ)。</p>
<p>アドレスが足りなくなる？そんなことがあるのでしょうか？つまり、32ビットの IPv4 アドレスには何十億もの IP アドレスが存在するのです。本当に何十億台ものコンピュータがあるのでしょうか？</p>
<p>Yes.</p>
<p>また、コンピュータが数台しかなく、10億という数字があり得ないほど大きいと誰もが思っていた当初、いくつかの大きな組織は、自分たちが使うために何百万というIPアドレスを惜しげもなく割り当てていたのです。(ゼロックス、MIT、フォード、HP、IBM、GE、AT&amp;T、そしてアップルという小さな会社などです)。</p>
<p>実際、いくつかの応急処置がなかったら、とっくに使い果たしていたでしょう。</p>
<p>しかし今は、すべての人間がIPアドレスを持ち、すべてのコンピュータ、電卓、電話、パーキングメーター、そして（なぜか）子犬も、という時代です。</p>
<p>そして、IPv6 が誕生したのです。ヴィント・サーフはおそらく不死身なので（たとえ肉体がこの世を去ったとしても、おそらく彼はすでにインターネット2の奥深くにある超知的な <a href="https://en.wikipedia.org/wiki/ELIZA">ELIZA</a> プログラムとして存在しているはずです）、もし次のバージョンのインターネットプロトコルで十分なアドレスが確保できなければ、誰も彼の「だから言っただろう」という言葉を再び聞きたくはないでしょう。</p>
<p>これは何を示唆しているのでしょうか？</p>
<p>もっとたくさんのアドレスが必要だということです。2倍どころか10億倍でもなく1000兆倍でもなく 7900万ビリオン・トリリオンの数のアドレスが必要なのです！そうこなくちゃ！</p>
<p>ビージェイ、それは本当なの？大きな数字を信じない理由があるんだ。&quot;32ビットと128ビットの差は大したことないように聞こえるかもしれない、96ビット多いだけだろ？しかし、私たちはここで累乗の話をしていることを忘れてはなりません。32ビットは約40億の数字（2^32）を表し、128ビットは約340兆の数字（2^128）を表します。これは、宇宙の星1つに対して、100万個の IPv4 インターネットがあるようなものです。</p>
<p>IPv4のドットや数字も忘れて、16進数では、2バイトの塊をコロンで区切って、このように表現しています。</p>
<pre><code>2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551
</code></pre>
<p>それだけではありません! 多くの場合、IPアドレスにはたくさんのゼロが含まれていますが、それらを2つのコロンで区切って圧縮することができます。そして、各バイトペアの先頭のゼロを省くことができます。例えば、次のようなアドレスのペアは、それぞれ等価です。</p>
<pre><code>2001:0db8:c9d2:0012:0000:0000:0000:0051
2001:db8:c9d2:12::51

2001:0db8:ab00:0000:0000:0000:0000:0000
2001:db8:ab00::

0000:0000:0000:0000:0000:0000:0000:0001
::1
</code></pre>
<p>アドレス <code>::1</code> はループバックアドレスです。常に「今走っているこのマシン」という意味です。IPv4 では、ループバックアドレスは <code>127.0.0.1</code> です。</p>
<p>最後に、IPv6 アドレスの IPv4 互換モードですが、これは皆さんが遭遇する可能性のあるものです。例えば、<code>192.0.2.33</code>という IPv4 アドレスを IPv6 アドレスとして表現したい場合、次のような表記をします。&quot;<code>::ffff:192.0.2.33</code>&quot;。</p>
<p>本気で楽しみたいんです。</p>
<p>実際、IPv6 の開発者たちは、何兆個ものアドレスを軽率にも予約用に切り捨てたほど、IPv6 は楽しいものなのですが、数が多すぎて、正直言って、もう誰が数えているのでしょうか？銀河系のすべての惑星のすべての男性、女性、子供、子犬、そしてパーキングメーターのために十分な数が残されています。 信じてくれ、銀河系のどの星にもパーキングメーターはあるんだ。本当なんだ。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="311-サブネット"><a class="header" href="#311-サブネット">3.1.1 サブネット</a></h1>
<p>組織上、「この IP アドレスの先頭からこのビットまでがネットワーク部分、それ以外がホスト部分」と宣言するのが便利な場合があります。</p>
<p>例えば、IPv4 では <code>192.0.2.12</code> というように、最初の3バイトがネットワークで、最後の1バイトがホストと言えるでしょう。あるいは、別の言い方をすれば、ネットワーク <code>192.0.2.0</code> 上のホスト <code>12</code> について話していることになります（ホストであるバイトをゼロにしているところをご覧ください）。</p>
<p>そして、さらに時代遅れの情報を! 準備はいいですか？古代では、サブネットには「クラス」があり、アドレスの最初の1バイト、2バイト、3バイトがネットワーク部分でした。運良く1バイトがネットワーク、3バイトがホストの場合、ネットワーク上に24ビット分のホスト（1600万程度）を持つことができます。これが「クラス A」のネットワークである。一方、「クラス C」は、ネットワークが3バイト、ホストが1バイトで、256台のホスト（ただし、予約された数台は除く）を持ちます。</p>
<p>ご覧のように、A クラスがほんの少し、C クラスが大量に、そして真ん中に B クラスが何個かある状態でした。</p>
<p>IP アドレスのネットワーク部分は、ネットマスクと呼ばれるもので記述されており、IP アドレスとビット単位で AND することでネットワーク番号を取得します。ネットマスクは通常 <code>255.255.255.0</code> のような形をしています。（例えば、このネットマスクでは、あなたの IP が <code>192.0.2.12</code> なら、あなたのネットワークは <code>192.0.2.12</code> AND <code>255.255.255.0</code> で、 <code>192.0.2.0</code> となります。）</p>
<p>しかし、残念ながら、これはインターネットの最終的なニーズに対して十分なきめ細かさではないことが判明しました。クラスCのネットワークはすぐに足りなくなったし、クラスAのネットワークも足りなくなったので、わざわざ尋ねる必要はありません。この問題を解決するために、権力者たちはネットマスクを 8、16、24 のどれでもなく、任意のビット数にすることを許可しました。例えば <code>255.255.255.252</code> というネットマスクは、30 ビットのネットワークと 2 ビットのホストで、 ネットワーク上に 4 つのホストを置くことができます。（ネットマスクは常に1ビットの束と0ビットの束からなることに注意してください。）</p>
<p>しかし、<code>255.192.0.0</code> のような大きな数字の羅列をネットマスクとして使うのは、少し扱いにくいです。まず、それが何ビットなのかが直感的にわからないし、コンパクトでもありません。そこで新スタイルが登場したのですが、これはもっとすっきりしています。IP アドレスの後にスラッシュを付けて、その後に10進数でネットワークのビット数を指定するだけです。こんな感じです。<code>192.0.2.12/30</code>。</p>
<p>あるいは、IPv6 の場合、このようなものです。<code>2001:db8::/32</code> または <code>2001:db8:5413:4028::9db9/64</code> です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="312-ポート番号"><a class="header" href="#312-ポート番号">3.1.2 ポート番号</a></h1>
<p>以前、インターネット層（IP）とホスト間トランスポート層（TCPとUDP）を分離した<a href="ip-addresses-structs-and-data-munging/docs/what-is-a-socket/#lowlevel">レイヤードネットワークモデル</a>をご紹介しましたが、覚えていらっしゃいますか？次の段落の前に、そのことをしっかり覚えておいてください。</p>
<p>IP アドレス（IP 層で使われる）の他に、TCP（ストリームソケット）や、偶然にも UDP（データグラムソケット）で使われるアドレスがあることが判明したのです。それは、ポート番号です。これは16ビットの数字で、接続のためのローカルアドレスのようなものです。</p>
<p>IP アドレスはホテルの番地、ポート番号は部屋番号だと思ってください。後で自動車業界の例も考えてみましょう。</p>
<p>例えば、受信メールとウェブサービスの両方を扱うコンピュータを用意したい場合、1つのIPアドレスを持つコンピュータでその2つを区別する方法はあるでしょうか？</p>
<p>さて、インターネット上のサービスには、それぞれ異なるウェルノウン・ポート番号が設定されています。 <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">IANA のポート一覧</a>か、Unix であれば <code>/etc/services</code> ファイルで確認することができます。HTTP（ウェブ）はポート80、telnet はポート23、SMTP はポート25、ゲーム <a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)">DOOM</a> はポート666、などなど。1024以下のポートはしばしば特殊とみなされ、通常、使用するには OS の特別な権限が必要です。</p>
<p>といったところでしょうか。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-バイトオーダー"><a class="header" href="#32-バイトオーダー">3.2 バイトオーダー</a></h1>
<p>レルムの命令で！バイトの並び順は2種類とします。今後、Lame and Magnificent と呼ばれるようになります。</p>
<p>というのは冗談ですが、本当にどちらか一方が優れているのです。<code>:-)</code></p>
<p>あなたのコンピュータは、あなたの背後でバイトを逆順に保存しているかもしれないのです。そうなんです。誰もあなたに言いたくはなかったのです。</p>
<p>つまり、2バイトの16進数、たとえば <code>b34f</code> を表現する場合、<code>b3</code> と <code>4f</code> の2バイトに続けて格納する、というのがインターネットの世界の共通認識になっているのです。これは理にかなっているし、<a href="https://en.wikipedia.org/wiki/Wilford_Brimley">ウィルフォード・ブリムリー</a>も言うように、正しい行為です。このように、大きい方の端が先になるように格納された数字をビッグエンディアン（Big-Endian）と呼びます。</p>
<p>残念ながら、世界中に散在する一部のコンピュータ、すなわちインテルまたはインテル互換のプロセッサを搭載したものは、バイトを逆に格納しているため、<code>b34f</code>は <code>4f</code> と <code>b3</code> の連続したバイトとしてメモリに格納されることになります。この記憶方式をリトルエンディアンと呼びます。</p>
<p>でも、ちょっと待ってください！用語の説明はまだ終わっていないのです。もっとまともなビッグエンディアンはネットワークバイトオーダーとも呼ばれ、私たちネットワーク系が好む順序だからです。</p>
<p>コンピュータはホストバイトオーダーで数字を記憶しています。インテル 80x86 であれば、ホストバイト順はリトルエンディアンです。モトローラ 68K の場合は、ビッグエンディアンです。PowerPC なら、ホストバイトの並びは......まあ、人それぞれですね。</p>
<p>パケットを作成するときやデータ構造を埋めるときに、2バイトや4バイトの数値がネットワークバイトオーダーになっていることを確認する必要があることがよくあります。しかし、ネイティブなホストバイトオーダーがわからない場合、どのようにすればよいのでしょうか。</p>
<p>朗報です。ホストのバイトオーダーが正しくないと仮定して、値をネットワークバ イトオーダーに設定するための関数を常に実行するようにすればよいのです。この関数は、必要であれば魔法のような変換を行い、エンディアンが異なるマシンにもコードを移植することができます。</p>
<p>よしよし。変換できる数値は、<code>short</code>（2バイト）と <code>long</code>（4バイト）の2種類です。これらの関数は、符号なしのバリエーションでも動作します。例えば、<code>short</code> をホストバイトオーダーからネットワークバイトオーダーに変換したいとします。まず &quot;h&quot; でホスト、その後に &quot;to&quot; をつけます。そして、&quot;n&quot; は &quot;network&quot;、&quot;s&quot; は &quot;short&quot; を表します。h-to-n-s または htons() (読み方: &quot;ホストからネットワークへのショート&quot;) です。</p>
<p>簡単すぎるくらいに...。</p>
<p>&quot;n&quot;、&quot;h&quot;、&quot;s&quot;、&quot;l&quot; の組み合わせは、本当にくだらないものを除いて、すべて使うことができるのです。たとえば、<code>stolh()</code> (&quot;Short to Long Host&quot;) という関数はありません---とにかく、このパーティーでは。しかし、あるのです。</p>
<table><thead><tr><th>関数</th><th>説明</th></tr></thead><tbody>
<tr><td><code>htons()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>s</code>hort</td></tr>
<tr><td><code>htonl()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>l</code>ong</td></tr>
<tr><td><code>ntohs()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>s</code>hort</td></tr>
<tr><td><code>ntohl()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>l</code>ong</td></tr>
</tbody></table>
<p>基本的には、送出する前にネットワークバイトオーダーに変換し、送出後にホストバイトオーダーに変換します。</p>
<p>64bitのバリエーションは知らないです、すみません。また、浮動小数点をやりたい場合は、ずっと下の<a href="ip-addresses-structs-and-data-munging/byte-order.html#serialization">Serialization</a> の章をチェックしてください。</p>
<p>この文書では、特に断らない限り、数値はホストバイトオーダーであると仮定しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-構造体"><a class="header" href="#33-構造体">3.3 構造体</a></h1>
<p>さて、ついにここまで来ました。そろそろプログラミングの話をしましょう。この章では、ソケットインターフェイスで使用される様々なデータ型について説明します。</p>
<p>まず、簡単なものからです。ソケットディスクリプタです。ソケットディスクリプタは以下のような型です。</p>
<pre><code class="language-c">int
</code></pre>
<p>普通の <code>int</code> です。</p>
<p>ここからは変な話なので、我慢して読んでください。</p>
<p>My First Struct™---<code>struct addrinfo</code>。この構造体は最近開発されたもので、ソケットアドレス構造体を後で使用するために準備するために使用されます。また、ホスト名のルックアップやサービス名のルックアップにも使用されます。これは、後で実際の使い方を説明するときに、より意味をなすと思いますが、今は、接続を行うときに最初に呼び出されるものの1つであることを知っておいてください。</p>
<pre><code class="language-c">struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for &quot;any&quot;
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
};
</code></pre>
<p>この構造体を少し読み込んでから、<code>getaddrinfo()</code> を呼び出します。この構造体のリンクリストへのポインタが返され、必要なものがすべて満たされます。</p>
<p><code>ai_family</code> フィールドで IPv4 か IPv6 を使うように強制することもできますし、<code>AF_UNSPEC</code> のままにして何でも使えるようにすることも可能です。これは、あなたのコードが IP バージョンに依存しないので、クールです。</p>
<p>これはリンクされたリストであることに注意してください：<code>ai_next</code> は次の要素を指しています---そこから選択するためにいくつかの結果があるかもしれません。私は最初にうまくいった結果を使いますが、あなたは異なるビジネスニーズを持っているかもしれません。何でもかんでも知ってるわけじゃないんです！</p>
<p><code>struct addrinfo</code> の <code>ai_addr</code> フィールドは <code>struct sockaddr</code> へのポインタであることがわかります。ここからが、IP アドレス構造体の中身についての細かい話になります。</p>
<p>通常、これらの構造体に書き込む必要はありません。多くの場合、<code>addrinfo</code> 構造体を埋めるために <code>getaddrinfo()</code> を呼び出すだけでよいでしょう。しかし、これらの構造体の内部を覗いて値を取得する必要があるため、ここでそれらを紹介します。</p>
<p>(また、構造体 <code>addrinfo</code> が発明される前に書かれたコードはすべて、これらのものをすべて手作業で梱包していたので、まさにそのような IPv4 コードを多く見かけることができます。このガイドの古いバージョンなどでもそうです)。</p>
<p>ある構造体は IPv4 で、ある構造体は IPv6 で、ある構造体はその両方です。どれが何なのか、メモしておきます。</p>
<p>とにかく、構造体 <code>sockaddr</code> は、多くの種類のソケットのためのソケットアドレス情報を保持します。</p>
<pre><code class="language-c">struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
};
</code></pre>
<p><code>sa_family</code> には様々なものを指定できますが、この文書ではすべて <code>AF_INET</code> (IPv4) または <code>AF_INET6</code> (IPv6) とします。<code>sa_data</code> にはソケットの宛先アドレスとポート番号を指定します。<code>sa_data</code> にアドレスを手で詰め込むのは面倒なので、これはかなり扱いにくいです。</p>
<p>構造体 <code>sockaddr</code> を扱うために、プログラマは IPv4 で使用する構造体 <code>sockaddr_in</code>（&quot;in&quot; は &quot;Internet&quot; の意）を並列に作成しました。</p>
<p><code>sockaddr_in</code> 構造体へのポインタは <code>sockaddr</code> 構造体へのポインタにキャストすることができ、その逆も可能です。つまり、<code>connect()</code> が <code>struct sockaddr*</code> を要求しても、<code>struct sockaddr_in</code> を使用して、最後の最後でキャストすることができるのです！</p>
<pre><code class="language-c">// (IPv4 only--see struct sockaddr_in6 for IPv6)

struct sockaddr_in {
    short int          sin_family;  // Address family, AF_INET
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
};
</code></pre>
<p>この構造体により、ソケットアドレスの要素を簡単に参照することができます。<code>sin_zero</code> (構造体を <code>struct sockaddr</code> の長さに合わせるために含まれます) は、関数 <code>memset()</code> ですべて 0 に設定する必要があることに注意すること。また、<code>sin_family</code> は <code>struct sockaddr</code> の <code>sa_family</code> に相当し、&quot;<code>AF_INET</code>&quot; に設定されることに注意します。最後に、<code>sin_port</code> はネットワークバイトオーダーでなければなりません（<code>htons()</code> を使用することで！）。</p>
<p>もっと掘り下げましょう！<code>sin_addr</code> フィールドは <code>in_addr</code> 構造体であることがわかりますね。あれは何なんだ？まあ、大げさではなく、史上最も恐ろしい組合せの1つです。</p>
<pre><code class="language-c">// (IPv4 only--see struct in6_addr for IPv6)

// Internet address (a structure for historical reasons)
struct in_addr {
    uint32_t s_addr; // that's a 32-bit int (4 bytes)
};
</code></pre>
<p>うおぉ まあ、昔はユニオンだったんだけど、今はもうそういう時代じゃないみたいだね。おつかれさまでした。つまり、<code>ina</code> を <code>struct sockaddr_in</code> 型と宣言した場合、<code>ina.sin_addr.s_addr</code> は4バイトの IP アドレス（ネットワークバイトオーダー）を参照することになります。あなたのシステムがまだ <code>struct in_addr</code> のための神々しいユニオンを使用している場合でも、あなたはまだ私が上記のように全く同じ方法で4バイトの IP アドレスを参照することができます（これは <code>#defines</code> によるものです）ことに注意してください。</p>
<p>IPv6 ではどうでしょうか。これについても同様の構造体が存在します。</p>
<pre><code class="language-c">// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)

struct sockaddr_in6 {
    u_int16_t       sin6_family;   // address family, AF_INET6
    u_int16_t       sin6_port;     // port number, Network Byte Order
    u_int32_t       sin6_flowinfo; // IPv6 flow information
    struct in6_addr sin6_addr;     // IPv6 address
    u_int32_t       sin6_scope_id; // Scope ID
};

struct in6_addr {
    unsigned char   s6_addr[16];   // IPv6 address
};
</code></pre>
<p>IPv4 が IPv4 アドレスとポート番号を持つように、IPv6 も IPv6 アドレスとポート番号を持つことに注意してください。</p>
<p>また、IPv6 フロー情報やスコープ ID のフィールドについては、今のところ触れないことに注意してください。<code>:-)</code></p>
<p>最後になりますが、こちらもシンプルな構造体である <code>struct sockaddr_storage</code> は、IPv4 と IPv6 の両方の構造体を保持できるように十分な大きさに設計されています。コールによっては、<code>struct sockaddr</code> に IPv4 と IPv6 のどちらのアドレスが記入されるのか事前にわからないことがありますよね。そこで、この並列構造体を渡しますが、サイズが大きい以外は <code>struct sockaddr</code> とよく似ており、必要な型にキャストします。</p>
<pre><code class="language-c">struct sockaddr_storage {
    sa_family_t  ss_family;     // address family

    // all this is padding, implementation specific, ignore it:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};
</code></pre>
<p>重要なのは、<code>ss_family</code> フィールドでアドレスファミリーを確認できることで、これが <code>AF_INET</code> か <code>AF_INET6</code>（IPv4 か IPv6 か）かを確認することです。それから、必要なら <code>struct sockaddr_in</code> や <code>struct sockaddr_in6</code> にキャストすることができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-ip-アドレスパート2"><a class="header" href="#34-ip-アドレスパート2">3.4 IP アドレス、パート2</a></h1>
<p>幸いなことに、IP アドレスを操作するための関数がたくさんあります。手書きで把握して <code>&lt;&lt;</code> 演算子で <code>long</code> に詰め込む必要はありません。</p>
<p>まず、<code>struct sockaddr_in ina</code> があり、そこに格納したい IP アドレスが <code>10.12.110.57</code> または <code>2001:db8:63b3:1::3490</code> だとしましょう。<code>inet_pton()</code> という関数は、数字とドットで表記された IP アドレスを、<code>AF_INET</code> か <code>AF_INET6</code> の指定によって、<code>in_addr</code> 構造体か <code>in6_addr</code> 構造体に変換する関数です。(&quot;<code>pton</code>&quot; は &quot;presentation to network&quot; の略で、覚えやすければ &quot;printable to network&quot; と呼んでも構いません)。変換は次のように行うことができます。</p>
<pre><code class="language-c">struct sockaddr_in sa; // IPv4
struct sockaddr_in6 sa6; // IPv6

inet_pton(AF_INET, &quot;10.12.110.57&quot;, &amp;(sa.sin_addr)); // IPv4
inet_pton(AF_INET6, &quot;2001:db8:63b3:1::3490&quot;, &amp;(sa6.sin6_addr)); // IPv6
</code></pre>
<p>(クイックメモ: 古い方法では、<code>inet_addr()</code> という関数や <code>inet_aton()</code> という別の関数を使っていましたが、これらはもう時代遅れで IPv6 では動きません。)</p>
<p>さて、上記のコードスニペットは、エラーチェックがないため、あまり堅牢ではありません。<code>inet_pton()</code> はエラー時に <code>-1</code> を返し、アドレスがめちゃくちゃになった場合は 0 を返します。ですから、使用する前に結果が 0 よりも大きいことを確認してください！</p>
<p>さて、これで文字列の IP アドレスをバイナリ表現に変換することができるようになりました。では、その逆はどうでしょうか？<code>in_addr</code> 構造体を持っていて、それを数字とドットの表記で印刷したい場合はどうでしょうか。(この場合、関数 <code>inet_ntop()</code> (&quot;<code>ntop</code>&quot; は &quot;network to presentation&quot; という意味です。覚えやすければ &quot;network to printable&quot; と呼んでも構いません) を次のように使用します。</p>
<pre><code class="language-c">// IPv4:

char ip4[INET_ADDRSTRLEN];  // space to hold the IPv4 string
struct sockaddr_in sa;      // pretend this is loaded with something

inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);

printf(&quot;The IPv4 address is: %s\n&quot;, ip4);


// IPv6:

char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string
struct sockaddr_in6 sa6;    // pretend this is loaded with something

inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);

printf(&quot;The address is: %s\n&quot;, ip6);
</code></pre>
<p>呼び出す際には、アドレスの種類（IPv4 または IPv6）、アドレス、結果を格納する文字列へのポインタ、その文字列の最大長を渡すことになります。(2つのマクロは、最大の IPv4 または IPv6 アドレスを保持するために必要な文字列のサイズを都合よく保持します。<code>INET_ADDRSTRLEN</code> と <code>INET6_ADDRSTRLEN</code> です)。</p>
<p>(古いやり方についてもう一度簡単に触れておくと、この変換を行う歴史的な関数は <code>inet_ntoa()</code> と呼ばれるものでした。これも時代遅れで、IPv6 では動きません。)</p>
<p>最後に、これらの関数は数値の IP アドレスに対してのみ動作します。&quot;<code>www.example.com</code>&quot; のようなホスト名に対してネームサーバの DNS ルックアップは行いません。後ほど説明するように、そのためには <code>getaddrinfo()</code> を使用します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="341-プライベートまたはディスコネクトネットワーク"><a class="header" href="#341-プライベートまたはディスコネクトネットワーク">3.4.1 プライベート（またはディスコネクト）ネットワーク</a></h1>
<p>多くの場所では、自分たちを守るために、ネットワークを他の地域から隠すファイアウォールがあります。そして多くの場合、ファイアウォールは、ネットワークアドレス変換（NAT）と呼ばれるプロセスを使って、&quot;内部&quot; IP アドレスを&quot;外部&quot;（世界中の誰もが知っている）IP アドレスに変換しています。</p>
<p>もう緊張してきましたか？&quot;こんな変なことして どこへ行くんだろう？&quot;</p>
<p>まあ、ノンアルコール飲料でも買ってリラックスしてください。初心者の場合、NAT は透過的に行われるので、心配する必要もありませんから。しかし、あなたが見ているネットワーク番号に混乱し始めた場合に備えて、ファイアウォールの背後にあるネットワークについて話したいと思います。</p>
<p>例えば、私の自宅にはファイアウォールがあります。DSL 会社から割り当てられた2つの固定 IPv4 アドレスを持っていますが、ネットワーク上に7台のコンピューターがあります。どうしてこんなことが可能なのでしょうか？2台のコンピュータが同じ IP アドレスを共有することはできませんし、そうでなければデータはどちらに行けばいいのかわからなくなってしまいます。</p>
<p>答えは、&quot;同じIPアドレスを共有していない&quot;です。2400万個の IP アドレスが割り当てられたプライベートネットワーク上にあるのです。それらはすべて私のためだけのものです。まあ、他の人たちから見れば、すべて私のためのものなのですが。ここで、何が起こっているのかを説明します。</p>
<p>リモートコンピューターにログインすると、ISP から提供されたパブリック IP アドレスである <code>192.0.2.33</code> からログインしていると表示されるのです。しかし、ローカルコンピューターにその IP アドレスを尋ねると、<code>10.0.0.5</code> と答えるのです。誰が IP アドレスを変換しているのでしょうか？そうです、ファイアウォールです。ファイアウォールが NAT しているのです。</p>
<p><code>10.x.x.x</code> は、完全に切断されたネットワークか、ファイアウォールの内側にあるネットワークでのみ使用される、数少ない予約ネットワークの1つです。どのプライベート・ネットワーク番号が使用できるかの詳細は、<a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a> に概説されていますが、一般的によく目にするのは、<code>10.x.x.x</code> と <code>192.168.x.x</code> で、<code>x</code> は通常 0 ～ 255 です。一般的ではないのは、<code>172.y.x.x</code> で、<code>y</code> は16から31の間です。</p>
<p>NAT するファイアウォールの内側のネットワークは、これらの予約されたネットワークのいずれかにある必要はありませんが、一般的にはそうなっています。</p>
<p>(楽しい事実！私の外部 IP アドレスは、本当は <code>192.0.2.33</code> ではないのです。<code>192.0.2.x</code> ネットワークは、このガイドのように、ドキュメントで使用するための架空の&quot;本当の&quot; IP アドレスのために予約されているのです！わーい、すごい！)</p>
<p>IPv6 にも、ある意味プライベートネットワークがあります。<a href="https://datatracker.ietf.org/doc/html/rfc4193">RFC 4193</a> にあるように、<code>fdXX:</code>（将来的には <code>fcXX:</code>）で始まります。しかし、NAT と IPv6 は一般的に混ざりません(このドキュメントの範囲外である IPv6 から IPv4 へのゲートウェイを行う場合を除きます)。理論的には、自由に使えるアドレスが非常に多くなるため、NAT を使用する必要はなくなるはずです。しかし、外部にルーティングしないネットワーク上で自分のためにアドレスを割り当てたい場合は、このようにします。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-ipv4-から-ipv6-へのジャンプ"><a class="header" href="#4-ipv4-から-ipv6-へのジャンプ">4 IPv4 から IPv6 へのジャンプ</a></h1>
<p>しかし、IPv6 で動作させるためには、私のコードのどこを変えればいいのか知りたいのです！今すぐ教えてください！</p>
<p>Ok! Ok!</p>
<p>ここに書かれていることはほとんどすべて、私が上で説明したことですが、せっかちな人のためのショートバージョンです。（もちろん、これ以外にもありますが、このガイドに該当するのはこれです。）</p>
<ol>
<li>
<p>まず、構造体を手で詰めるのではなく、<a href="jumping-from-ipv4-to-ipv6/docs/ip-addresses-structs-and-data-munging/#structs"><code>getaddrinfo()</code></a> を使ってすべての <code>sockaddr</code> 構造体の情報を取得するようにしてください。こうすることで、IP のバージョンに左右されず、また、その後の多くのステップを省くことができます。</p>
</li>
<li>
<p>IP バージョンに関連する何かをハードコーディングしていることが分かったら、ヘルパー関数でラップするようにします。</p>
</li>
<li>
<p><code>AF_INET</code> を <code>AF_INET6</code> に変更します。</p>
</li>
<li>
<p><code>PF_INET</code> を <code>PF_INET6</code> に変更します。</p>
</li>
<li>
<p><code>INADDR_ANY</code> の割り当てを <code>in6addr_any</code> の割り当てに変更し、若干の差異が生じます。</p>
<pre><code class="language-c">struct sockaddr_in sa;
struct sockaddr_in6 sa6;

sa.sin_addr.s_addr = INADDR_ANY;  // use my IPv4 address
sa6.sin6_addr = in6addr_any; // use my IPv6 address
</code></pre>
<p>Also, the value <code>IN6ADDR_ANY_INIT</code> can be used as an initializer when
the <code>struct in6_addr</code> is declared, like so:</p>
<pre><code class="language-c">struct in6_addr ia6 = IN6ADDR_ANY_INIT;
</code></pre>
</li>
<li>
<p><code>struct sockaddr_in</code> の代わりに <code>struct sockaddr_in6</code> を使用し、必要に応じてフィールドに &quot;6&quot; を追加してください（上記の <a href="jumping-from-ipv4-to-ipv6/docs/ip-addresses-structs-and-data-munging/#structs"><code>struct</code>s</a> を参照）。<code>sin6_zero</code> フィールドはありません。</p>
</li>
<li>
<p><code>struct in_addr</code> の代わりに <code>struct in6_addr</code> を使用し、必要に応じてフィールドに &quot;6&quot; を追加してください（上記の <a href="jumping-from-ipv4-to-ipv6/docs/ip-addresses-structs-and-data-munging/#structs"><code>struct</code>s</a> を参照）。</p>
</li>
<li>
<p><code>inet_aton()</code> や <code>inet_addr()</code> の代わりに、<code>inet_apton()</code> を使用してください。</p>
</li>
<li>
<p><code>inet_ntoa()</code> の代わりに <code>inet_ntop()</code> を使用してください。</p>
</li>
<li>
<p><code>gethostbyname()</code> の代わりに、優れた <code>getaddrinfo()</code> を使用してください。</p>
</li>
<li>
<p><code>gethostbyaddr()</code> の代わりに、優れた <code>getnameinfo()</code> を使用してください（<code>gethostbyaddr()</code>は IPv6 でも動作可能です）。</p>
</li>
<li>
<p><code>INADDR_BROADCAST</code> は動作しなくなりました。代わりに IPv6 マルチキャストを使用してください。</p>
</li>
</ol>
<p>出来上がり！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/theme-solarized_dark.js"></script>
        <script type="text/javascript" src="theme/theme-solarized_light.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
