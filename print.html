<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Beej のネットワークプログラミング入門</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/solarized-light-hljs.css">
        <link rel="stylesheet" href="theme/solarized-dark-hljs.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Home</a></li><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> 序説</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/audience.html"><strong aria-hidden="true">1.1.</strong> 対象読者</a></li><li class="chapter-item expanded "><a href="intro/platform-and-compiler.html"><strong aria-hidden="true">1.2.</strong> プラットフォームとコンパイラ</a></li><li class="chapter-item expanded "><a href="intro/official-homepage-and-books-for-sale.html"><strong aria-hidden="true">1.3.</strong> 公式ホームページと販売書籍</a></li><li class="chapter-item expanded "><a href="intro/note-for-solaris-sunos-programmers.html"><strong aria-hidden="true">1.4.</strong> Solaris/SunOS プログラマへの注意事項</a></li><li class="chapter-item expanded "><a href="intro/note-for-windows-programmers.html"><strong aria-hidden="true">1.5.</strong> Windows プログラマへの注意事項</a></li><li class="chapter-item expanded "><a href="intro/email-policy.html"><strong aria-hidden="true">1.6.</strong> メールポリシー</a></li><li class="chapter-item expanded "><a href="intro/mirroring.html"><strong aria-hidden="true">1.7.</strong> ミラーリング</a></li><li class="chapter-item expanded "><a href="intro/note-for-translators.html"><strong aria-hidden="true">1.8.</strong> 翻訳者への注意事項</a></li><li class="chapter-item expanded "><a href="intro/copyright-distribution-and-legal.html"><strong aria-hidden="true">1.9.</strong> 著作権・配布・法的事項</a></li><li class="chapter-item expanded "><a href="intro/dedication.html"><strong aria-hidden="true">1.10.</strong> 献辞</a></li><li class="chapter-item expanded "><a href="intro/publishing-information.html"><strong aria-hidden="true">1.11.</strong> 出版情報</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-a-socket/index.html"><strong aria-hidden="true">2.</strong> ソケットとは？</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-a-socket/two-types-of-internet-sockets.html"><strong aria-hidden="true">2.1.</strong> 2種類のインターネットソケット</a></li><li class="chapter-item expanded "><a href="what-is-a-socket/low-level-nonsense-and-network-theory.html"><strong aria-hidden="true">2.2.</strong> 低レベルのナンセンスとネットワーク理論</a></li></ol></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/index.html"><strong aria-hidden="true">3.</strong> IP アドレス, 構造体, データマンジング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/ip-addresses-versions-4-and-6.html"><strong aria-hidden="true">3.1.</strong> IP アドレス、バージョン4と6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/subnets.html"><strong aria-hidden="true">3.1.1.</strong> サブネット</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/port-munbers.html"><strong aria-hidden="true">3.1.2.</strong> ポート番号</a></li></ol></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/byte-order.html"><strong aria-hidden="true">3.2.</strong> バイトオーダー</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/structs.html"><strong aria-hidden="true">3.3.</strong> 構造体</a></li><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/ip-addresses-part-deux.html"><strong aria-hidden="true">3.4.</strong> IP アドレス、パート2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ip-addresses-structs-and-data-munging/private-or-disconnected-networks.html"><strong aria-hidden="true">3.4.1.</strong> プライベート（またはディスコネクト）ネットワーク</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="jumping-from-ipv4-to-ipv6/index.html"><strong aria-hidden="true">4.</strong> IPv4 から IPv6 へのジャンプ</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/index.html"><strong aria-hidden="true">5.</strong> システムコールかバスト</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="system-calls-or-bust/getaddrinfo-prepare-to-launch.html"><strong aria-hidden="true">5.1.</strong> getaddrinfo()---起動の準備をしよう！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/socket-get-the-file-descriptor.html"><strong aria-hidden="true">5.2.</strong> socket()---ファイルディスクリプターを取得しよう！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/bind-what-port-am-i-on.html"><strong aria-hidden="true">5.3.</strong> bind()---私はどのポートにいるのでしょうか？</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/connect-hey-you.html"><strong aria-hidden="true">5.4.</strong> connect()---やあ、こんにちは！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/listen-will-somebody-please-call-me.html"><strong aria-hidden="true">5.5.</strong> listen()---誰か電話してくれない？</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/accept-thank-you-for-calling-port-3490.html"><strong aria-hidden="true">5.6.</strong> accept()---&quot;3490番ポートにコールいただきありがとうございます。&quot;</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/send-and-recv-talk-to-me-baby.html"><strong aria-hidden="true">5.7.</strong> send() and recv()---話せよ、ベイビー！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/sendto-and-recvfrom-talk-to-me-GDRAM-style.html"><strong aria-hidden="true">5.8.</strong> sendto() and recvfrom()---DGRAM スタイルで話して。</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/close-shutdown-get-outta-my-face.html"><strong aria-hidden="true">5.9.</strong> close() and shutdown()---私の前から失せな！</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/getpeername-who-are-you.html"><strong aria-hidden="true">5.10.</strong> getpeername()---あなたは誰ですか？</a></li><li class="chapter-item expanded "><a href="system-calls-or-bust/gethostname-who-am-i.html"><strong aria-hidden="true">5.11.</strong> gethostname()---私は誰なのか？</a></li></ol></li><li class="chapter-item expanded "><a href="client-server-background/index.html"><strong aria-hidden="true">6.</strong> クライアント-サーバの背景</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client-server-background/a-simple-stream-server.html"><strong aria-hidden="true">6.1.</strong> シンプルなストリームサーバ</a></li><li class="chapter-item expanded "><a href="client-server-background/a-simple-stream-client.html"><strong aria-hidden="true">6.2.</strong> シンプルなストリームクライアント</a></li><li class="chapter-item expanded "><a href="client-server-background/datagram-sockets.html"><strong aria-hidden="true">6.3.</strong> データグラムソケット</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="solarized-light">Solarized Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="solarized-dark">Solarized Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Beej のネットワークプログラミング入門</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/solareenlo/bgnet" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 align="center">Beej のインターネットソケットを利用したネットワークプログラミング入門</h1>
<p align="center">
Brian “Beej Jorgensen” Hall
</p>
<p align="center">
v3.1.5, Copyright © November 20, 2020
</p>
<h2 id="ここは何"><a class="header" href="#ここは何">ここは何？</a></h2>
<p><a href="https://beej.us/guide/bgnet/html/">https://beej.us/guide/bgnet/html/</a> の日本語訳</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://beej.us/guide/bgnet/">https://beej.us/guide/bgnet/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-序説"><a class="header" href="#1-序説">1 序説</a></h1>
<p>おいおい、ソケットプログラミングで参ってるのか？このようなことは <code>man</code> ページから理解するには少し難しすぎるのではありませんか？クールなインターネットプログラミングをしたいけど、<code>connect()</code> の前に <code>bind()</code> を呼ばないといけないのか、などなど、<code>struct</code> のゴブをかき分けている時間はないでしょう。</p>
<p>さて、どうでしょう！？私はもうこの厄介なビジネスをやり遂げました。そして、この情報をみんなと共有したくてたまらないのです！あなたは正しい場所に来たのです。この文書は、平均的な有能なCプログラマーが、このネットワーク・ノイズに対処するために必要なエッジを与えてくれるはずです。</p>
<p>そして、チェックしてみてください。私はついに未来に追いつき、（ちょうどいいタイミングで！）IPv6用にガイドを更新しました。お楽しみに！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-対象読者"><a class="header" href="#11-対象読者">1.1 対象読者</a></h1>
<p>このドキュメントは、完全なリファレンスではなく、チュートリアルとして書かれています。 ソケットプログラミングを始めたばかりで、足がかりを探している人が読むと、おそらく最適なものになるでしょう。ソケットプログラミングの完全なガイドではありません。</p>
<p>でも、うまくいけば、あのマニュアルページが意味を持ち始めるかもしれませんね...。<code>:-)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-プラットフォームとコンパイラ"><a class="header" href="#12-プラットフォームとコンパイラ">1.2 プラットフォームとコンパイラ</a></h1>
<p>この文書に含まれるコードは、Gnu の <code>gcc</code> コンパイラを使用して Linux PC でコンパイルされています。しかし、<code>gcc</code>を使うプラットフォームであれば、ほぼ全てのプラットフォームでビルドできるはずです。当然ながら、Windows 用のプログラミングには適用されません。以下の<a href="intro/docs/intro/#windows">section on Windows programming</a>を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-公式ホームページと販売書籍"><a class="header" href="#13-公式ホームページと販売書籍">1.3 公式ホームページと販売書籍</a></h1>
<p>このドキュメントの正式な所在地は</p>
<ul>
<li><a href="https://beej.us/guide/bgnet/"><code>https://beej.us/guide/bgnet/</code></a></li>
</ul>
<p>また、サンプルコードや様々な言語への翻訳も掲載されています。</p>
<p>製本された印刷物（&quot;本&quot;と呼ぶ人もいる）を購入するには、以下をご覧ください。</p>
<ul>
<li><a href="https://beej.us/guide/url/bgbuy"><code>https://beej.us/guide/url/bgbuy</code></a></li>
</ul>
<p>文書作成生活の維持に役立つので、購入はありがたいです！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-solarissunos-プログラマへの注意事項"><a class="header" href="#14-solarissunos-プログラマへの注意事項">1.4 Solaris/SunOS プログラマへの注意事項</a></h1>
<p>Solaris または SunOS 用にコンパイルする場合、適切なライブラリをリンクするために、いくつかの特別なコマンドラインスイッチを指定する必要があります。これを行うには、コンパイルコマンドの最後に &quot;<code>-lnsl -lsocket -lresolv</code>&quot; を以下のように追加するだけです。</p>
<pre><code>$ cc -o server server.c -lnsl -lsocket -lresolv
</code></pre>
<p>それでもエラーが出るようなら、さらにそのコマンドラインの最後に <code>-lxnet</code> を追加してみるといいでしょう。それが何をするのか正確にはわかりませんが、必要な人もいるようです。</p>
<p>もう一つ問題がありそうなのは、<code>setsockopt()</code> の呼び出しのところです。プロトタイプは私の Linux ボックスのものとは異なるので、代わりに</p>
<pre><code class="language-c">int yes=1;
</code></pre>
<pre><code class="language-c">char yes='1';
</code></pre>
<p>を入力します。</p>
<p>私は Sunbox を持っていないので、上記の情報を検証したわけではありません---あくまでメールで教えてもらったことです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-windows-プログラマへの注意事項"><a class="header" href="#15-windows-プログラマへの注意事項">1.5 Windows プログラマへの注意事項</a></h1>
<p>このガイドの時点では、歴史的に、私が Windows をあまり好きではないという事実のために、Windows を少し非難しています。しかし、Windows は膨大なインストールベースがあり、明らかに完璧なオペレーティングシステムであることを公平にお伝えする必要があります。</p>
<p>不在は心を豊かにすると言いますが、この場合、私はそれが真実であると信じています。(ただ、言えることは、10数年前から個人的な仕事ではマイクロソフトのOSを使っていなかったので、ずっと幸せだということです だから、安心して、&quot;どうぞ、ご自由に Windows を使ってください！&quot;と言えるのです。 ...そう、歯ぎしりしながら言うんですけどね。</p>
<p>ですから私は、<a href="https://www.linux.com/">Linux</a> や <a href="https://bsd.org/">BSD</a>、あるいは Unix のいくつかのフレーバーを、代わりに試してみることをお勧めします。</p>
<p>しかし、人は好きなものを好きになるものです。Windows の皆さんは、この情報が、もしあれば、いくつかの小さな変更を加えて、あなた方にも一般的に適用できることを知って喜んでいることでしょう。</p>
<p>Windows 用の Unix ツールの集合体である <a href="https://cygwin.com/">Cygwin</a> をインストールするのもいい方法です。そうすると、これらのプログラムはすべて修正なしでコンパイルできるようになると、人づてに聞いたことがあります。</p>
<p>もうひとつ、<a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux</a> も検討してみてください。これは基本的に、Windows 10 に Linux の VM 的なものをインストールすることができます。これもまた、間違いなく位置づけられるでしょう。</p>
<p>しかし、中には純粋な Windows のやり方で物事を進めたいと思う人もいるかもしれません。それはとてもガッツのあることで、こうすればいいんです。すぐに Unix を買ってきてください! いやいや---冗談です。最近は Windows フレンドリー(笑)なはずなんですが...。</p>
<p>これは、あなたがしなければならないことです（<a href="intro/">Cygwin</a>をインストールしない限り！）：まず、ここで私が言及するシステムヘッダーファイルのほとんどを無視してください。あなたがインクルードする必要があるのは、以下のものだけです。</p>
<pre><code class="language-c">#include &lt;winsock.h&gt;
</code></pre>
<p>待ってください！ソケットライブラリで何かする前に <code>WSAStartup()</code> を呼び出す必要があります。これを行うためのコードは以下のようなものです。</p>
<pre><code class="language-c editable">#include &lt;winsock.h&gt;

{
    WSADATA wsaData;   // if this doesn't work
    //WSAData wsaData; // then try this instead

    // MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:

    if (WSAStartup(MAKEWORD(1,1), &amp;wsaData) != 0) {
        fprintf(stderr, &quot;WSAStartup failed.\n&quot;);
        exit(1);
    }
</code></pre>
<p>また、Winsock ライブラリをリンクするようにコンパイラに指示する必要があります。通常、<code>wsock32.lib</code> または <code>winsock32.lib</code>、Winsock 2.0 の場合は <code>ws2_32.lib</code> と呼ばれます。VC++ では、これは <code>Project</code> メニューの <code>Settings...</code> から行うことができます。<code>Link</code> タブをクリックし、&quot;Object/library modules&quot; というタイトルのボックスを探します。そのリストに &quot;wsock32.lib&quot;（または、お好みの lib）を追加してください。</p>
<p>とか聞いています。</p>
<p>最後に、ソケットライブラリを使い終わったら、<code>WSACleanup()</code> を呼び出す必要があります。詳しくはオンラインヘルプを参照してください。</p>
<p>一度これを行えば、このチュートリアルの残りの例は、いくつかの例外を除いて、概ね適用できるはずです。ひとつは、ソケットを閉じるために <code>close()</code> を使うことができません。また、<code>select()</code> はソケットディスクリプタに対してのみ動作し、ファイルディスクリプタに対しては動作しません (<code>stdin</code> に対する <code>0</code> のように)。</p>
<p>また、<code>CSocket</code> というソケットクラスもあります。詳細はコンパイラのヘルプを参照してください。</p>
<p>Winsock についての詳しい情報は、<a href="https://tangentsoft.net/wskfaq/">Winsock FAQ</a> を読んで、そこから進んでください。</p>
<p>最後に、Windows には <code>fork()</code> システムコールがないそうですが、これは残念ながら私の例のいくつかで使われているものです。多分、POSIX ライブラリか何かをリンクしないと動かないでしょうし、代わりに <code>CreateProcess()</code> を使ってもいいでしょう。<code>fork()</code> は引数を取らず、<code>CreateProcess()</code> は約480億の引数を取ります。もし、そこまで気が回らないのであれば、<code>CreateThread()</code> の方が少し消化しやすいでしょう。残念ながら、マルチスレッドに関する議論はこのドキュメントの範囲外です。私が語れることは限られているのですからね!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-メールポリシー"><a class="header" href="#16-メールポリシー">1.6 メールポリシー</a></h1>
<p>メールでの質問には基本的に対応しますので、気軽に書き込んでください。ただし、返事を保証するものではありません。私はかなり忙しい生活を送っているので、どうしても質問に答えられないことがあります。そのような場合は、メッセージを削除します。個人的なことではなく、あなたが必要とする詳細な回答をする時間がないだけなのです。</p>
<p>原則として、質問が複雑であればあるほど、回答できる可能性は低くなります。質問を送る前に質問を絞り込み、関連する情報（プラットフォーム、コンパイラ、表示されるエラーメッセージなど、トラブルシューティングに役立ちそうなもの）を必ず記載していただければ、回答が得られる可能性は高くなります。より詳しい情報は、ESRのドキュメント、<a href="http://www.catb.org/%7Eesr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a> をお読みください。</p>
<p>返事がない場合は、もう少し調べてみて、答えが見つからなければ、また調べてみてください。そして調べたことまたを書き込んでください。その結果、私がお手伝いできるようになることを期待しています。</p>
<p>さて、手紙の書き方、書き方についておせっかいを焼いてしまいましたが、このガイドが何年にもわたって賞賛されてきたことに、私は十分に感謝していることをお伝えしておきたいと思います。このガイドが良いことに使われていると聞いて、私はとても嬉しくなりました。<code>:-)</code> ありがとうございます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-ミラーリング"><a class="header" href="#17-ミラーリング">1.7 ミラーリング</a></h1>
<p>このサイトをミラーリングすることは、公的にも私的にも大歓迎です。もし、あなたがこのサイトを公的にミラーリングし、メインページからリンクしてほしい場合は、<code>beej@beej.us</code> までご連絡ください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-翻訳者への注意事項"><a class="header" href="#18-翻訳者への注意事項">1.8 翻訳者への注意事項</a></h1>
<p>もし、このガイドを他の言語に翻訳したい場合は、<code>beej@beej.us</code> までメールをいただければ、メインページからあなたの翻訳をリンクさせていただきます。翻訳にはあなたの名前と連絡先を自由に追加してください。</p>
<p>このソースマークダウン文書は UTF-8 エンコーディングを使用しています。</p>
<p>後述の <a href="intro/note-for-translators.html#legal">Copyright, Distribution, and Legal</a> に記載されている使用許諾条件にご注意ください。</p>
<p>もし私に翻訳をホストして欲しいのであれば、言ってください。また、あなたがホストすることを望むなら、私はそれにリンクします；どちらでも構いません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-著作権配布法的事項"><a class="header" href="#19-著作権配布法的事項">1.9 著作権・配布・法的事項</a></h1>
<pre><code class="language-text">Beej's Guide to Network Programming is Copyright © 2019 Brian &quot;Beej Jorgensen&quot; Hall.
</code></pre>
<p>この作品は、以下のソースコードと翻訳に関する特定の例外を除き、クリエイティブ・コモンズ 表示-非営利-改変禁止 3.0 ライセンスの下に提供されています。このライセンスのコピーを見るには、以下をご覧ください。</p>
<p><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/"><code>https://creativecommons.org/licenses/by-nc-nd/3.0/</code></a></p>
<p>または、Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA に手紙を送ってください。</p>
<p>本使用許諾の&quot;二次的著作物の禁止&quot;部分の具体的な例外は、次のとおりです：このガイドは、翻訳が正確である限り、どの言語にも自由に翻訳でき、ガイド全体を再印刷することができます。翻訳には、オリジナルのガイドと同じライセンスの制約が適用されます。翻訳には、翻訳者の名前と連絡先も含めることができます。</p>
<p>本書で紹介する C 言語のソースコードは、パブリックドメインとして許諾され、いかなるライセンス制限もありません。</p>
<p>教育関係者は、このガイドを生徒に勧めたり、コピーを提供したりすることを自由に推奨します。</p>
<p>書面による相互の合意がない限り、著者は作品を現状のまま提供し、作品に関して、明示的、黙示的、法定またはその他のいかなる種類の表明または保証（権利、商品性、特定目的への適合性、非侵害、潜在的またはその他の欠陥の不在、精度、または発見可能かどうかにかかわらず誤りの有無の保証を含むが、これに限定されない）も行わないものとします。</p>
<p>適用される法律で要求される範囲を除き、いかなる場合においても、著作者は、著作物の使用から生じる特別損害、付随的損害、結果的損害、懲罰的損害または典型的損害について、たとえ著作者がその損害の可能性を知らされていたとしても、いかなる法的理論によってもお客様に対して責任を負うことはないものとします。</p>
<p>お問い合わせは <code>beej@beej.us</code> までお願いします。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="110-献辞"><a class="header" href="#110-献辞">1.10 献辞</a></h1>
<p>このガイドを書くにあたり、過去から未来にわたって協力してくださった皆様に感謝します。そして、私がこのガイドを作るために使っているフリーソフトやパッケージを制作しているすべての人に感謝します。GNU、Linux、Slackware、vim、Python、Inkscape、pandoc、その他多数。そして最後に、文字通り何千もの人々が、改善の提案や励ましの言葉を書いてくれたことに、大きな感謝を捧げます。</p>
<p>このガイドを、コンピュータの世界における私の最大のヒーローであり、インスピレーターである何人かに捧げます。Donald Knuth、Bruce Schneier、W. Richard Stevens、The Woz、そして私の読者、さらにフリーおよびオープンソースソフトウェアのコミュニティ全体に捧げます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-出版情報"><a class="header" href="#111-出版情報">1.11 出版情報</a></h1>
<p>この本は、GNU ツールを搭載した Arch Linux のマシン上で vim エディタを使って、Markdown で書かれています。表紙の&quot;アート&quot;とダイアグラムは Inkscape で作成されています。Markdown は Python、Pandoc および XeLaTeX により、Liberation フォントを用いて HTML および LaTex/PDF に変換されます。このツールチェーンは 100% フリーおよびオープンソースソフトウェアで構成されています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-ソケットとは"><a class="header" href="#2-ソケットとは">2 ソケットとは？</a></h1>
<p>&quot;ソケット&quot;という言葉をよく耳にしますが、そもそも&quot;ソケット&quot;とは何なのでしょうか？それは、標準的な Unix のファイルディスクリプタを使って他のプログラムと会話するための方法です。</p>
<p>なんと？</p>
<p>Ok--- Unix のハッカーが &quot;Unix では何でもファイルなんだ！&quot;と言ったのを聞いたことがあるかもしれません。その人が言っているのは、Unix のプログラムが何らかの I/O を行うとき、ファイル記述子に対して読み書きを行うという事実のことかもしれません。ファイルディスクリプタは、単純に、開いているファイルに関連する整数です。しかし、このファイルは、ネットワーク接続、FIFO、パイプ、ターミナル、ディスク上のファイルなど、あらゆるものになり得ます（ここが重要）。Unix ではすべてがファイルなのです！だから、インターネット上で他のプログラムと通信したいときは、ファイル記述子を介して行うことになるんだ。と思ってください。</p>
<p>&quot;ネットワーク通信のためのファイルディスクリプタはどこで手に入るのですか、お利口さん？&quot;というのが、今あなたが考えている最後の質問でしょうが、とにかくそれに答えてあげましょう。あなたは <code>socket()</code> システムルーチンを呼び出すのです。このルーチンはソケットディスクリプタを返すので、それを使って <code>send()</code> と <code>recv()</code> (<a href="what-is-a-socket/docs/man-pages/#sendman"><code>man send</code></a>, <a href="what-is-a-socket/docs/man-pages/#recvman"><code>man recv</code></a>) という特別なソケットコールを使って通信を行います。</p>
<p>&quot;でもね！&quot;あなたは今頃、そう叫んでいるかもしれません。&quot;ファイルディスクリプタなら、どうしてネプチューンの名において、通常の <code>read()</code> と <code>write()</code> の呼び出しでソケットを通して通信できないんだ？&quot;と。短い答えは、&quot;できる！&quot;です。もっと長い答えは、&quot;できるけど、<code>send()</code> と <code>recv()</code> はデータ転送をより大きく制御できる &quot;です。</p>
<p>次は何？どうでしょう、ソケットにはいろいろな種類がありますね。DARPA インターネットアドレス (インターネットソケット)、ローカルノード上のパス名 (Unix ソケット)、CCITT X.25 アドレス (X.25 ソケット、無視しても大丈夫)、そしておそらくあなたが実行する Unix のフレーバーに応じて他の多くの種類があります。この文書では、最初の&quot;インターネットソケット&quot;のみを扱います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-2種類のインターネットソケット"><a class="header" href="#21-2種類のインターネットソケット">2.1 2種類のインターネットソケット</a></h1>
<p>これは何？インターネットソケットには2種類ある？そうです。まあ、違うけど。嘘です。もっとあるんだけど、怖がらせたくなかったんだ。 ここでは2種類しか話しません。ただし、この文章では、&quot;Raw Sockets&quot; も非常に強力なので、ぜひ調べてみてくださいと言うつもりです。</p>
<p>わかったよ、もう。この2つのタイプは何ですか？一つは&quot;ストリームソケット&quot;、もう一つは&quot;データグラムソケット&quot;で、以下、それぞれ &quot;<code>SOCK_STREAM</code>&quot; &quot;<code>SOCK_DGRAM</code>&quot; と呼ぶことがあります。データグラムソケットは&quot;コネクションレス型ソケット&quot;と呼ばれることもあります 。(ただし、本当に必要であれば <code>connect()'</code> を使用することができます。後述の <a href="what-is-a-socket/two-types-of-internet-sockets.html#connect"><code>connect()</code></a> を参照してください)。</p>
<p>ストリームソケットは、信頼性の高い双方向接続の通信ストリームです。ソケットに2つのアイテムを &quot;1, 2&quot; という順序で出力すると、反対側にも &quot;1, 2&quot; という順序で届きます。また、エラーも発生しません。実際、私はエラーフリーであることを確信しています。もし、そうでないと主張する人がいたら、耳に指を突っ込んで&quot;ララララ&quot;と唱えてやりたいくらいだ。</p>
<p>何がストリーム・ソケットを使うのでしょうか？さて、皆さんは <code>telnet</code> というアプリケーションをご存知でしょうか？あれはストリームソケットを使っているんだ。あなたが入力した文字は、すべて入力した順番に到着する必要がありますよね？また、Webブラウザは HTTP(Hypertext Transfer Protocol) を使っていますが、これはストリームソケットを使ってページを取得します。実際、80番ポートで Web サイトに telnet して、&quot;<code>GET / HTTP/1.0</code>&quot; と入力してリターンを2回押すと、HTML がダンプされて戻ってきますよ。</p>
<p>もし <code>telnet</code> がインストールされておらず、インストールもしたくない場合、あるいは <code>telnet</code> がクライアントとの接続にうるさい場合、ガイドには <a href="https://beej.us/guide/bgnet/examples/telnot.c"><code>telnot</code></a> という <code>telnet</code> に似たプログラムが付属しています。これは、このガイドで必要なものすべてに対してうまく機能するはずです。(なお、telnet は実際には <a href="https://datatracker.ietf.org/doc/html/rfc854">spec'd networking protocol</a> であり、<code>telnot</code> はこのプロトコルを全く実装していません)。</p>
<p>ストリームソケットは、どのようにしてこの高いレベルのデータ伝送品質を実現しているのでしょうか。 それは、&quot;TCP&quot; として知られる&quot;伝送制御プロトコル&quot;(TCP の詳細については <a href="https://datatracker.ietf.org/doc/html/rfc793">RFC 793</a> を参照)というプロトコルを使用しているからです。TCP はデータが順次、エラーなく到着することを確認します。&quot;TCP&quot; は &quot;TCP/IP&quot; の半分で、&quot;IP&quot; は &quot;Internet Protocol&quot;（<a href="https://datatracker.ietf.org/doc/html/rfc791">RFC 791</a> を参照）の略だと聞いたことがあるかもしれません。IP は主にインターネット・ルーティングを扱い、一般にデータの完全性には責任を持ちません。</p>
<p>かっこいい。データグラムソケットについてはどうでしょうか？なぜコネクションレス型と呼ばれるのでしょうか？どうなっているんだ？なぜ信頼性が低いのでしょうか？データグラムを送ると、それが届くかもしれません。データグラムを送信すると、それは到着するかもしれません。もし到着すれば、パケット内のデータはエラーフリーです。</p>
<p>データグラムソケットもルーティングに IP を使いますが、TCP は使わず、&quot;User Datagram Protocol&quot;、つまり &quot;UDP&quot; を使います（<a href="https://datatracker.ietf.org/doc/html/rfc768">RFC 768</a> を参照）。</p>
<p>なぜコネクションレスレスなのか？まあ、基本的には、ストリームソケットのようにオープンな接続を維持する必要がないからです。パケットを作り、その上に宛先情報を含む IP ヘッダを貼り付け、送信するだけでいいのです。コネクションは必要ありません。一般的には、TCP スタックが利用できないときや、パケットをいくつか落としても宇宙の終わりを意味しないときに使用されます。サンプルアプリケーション: <code>tftp</code> (FTP の弟分のようなファイル転送プロトコル)、<code>dhcpcd</code> (DHCP クライアント)、マルチプレイヤーゲーム、ストリーミングオーディオ、ビデオ会議、などなど。</p>
<p>&quot;ちょっと待った！<code>tftp</code> と <code>dhcpcd</code> はバイナリアプリケーションをあるホストから別のホストに転送するために使われるんだ！アプリケーションが到着したときに動作することを期待するならば、データが失われることはありえない！これはどんな黒魔術なんだ？&quot;</p>
<p>さて、私の人間の友人である <code>tftp</code> やそれに類するプログラムは、UDP の上に独自のプロトコルを載せています。たとえば、tftp プロトコルは、送信されたパケットごとに、受信者は&quot;受け取ったよ！&quot;というパケットを送り返さなければならない、と言っています。というパケット(&quot;ACK&quot; パケット)を送り返さなければなりません。元のパケットの送信者は、例えば5秒間返信がない場合、最終的に ACK を得るまでパケットを再送信することになります。この確認手続きは、信頼性の高い <code>SOCK_DGRAM</code> アプリケーションを実装する際に非常に重要です。</p>
<p>ゲーム、オーディオ、ビデオなどの信頼性の低いアプリケーションでは、ドロップしたパケットを無視するか、あるいは巧みに補うようにします。(Quake プレイヤーは、この効果の発現を呪われたラグという専門用語で知っていることでしょう。 この場合の&quot;呪われた&quot;という単語は、非常に不敬な発言を意味します)。</p>
<p>なぜ信頼性の低い基礎プロトコルを使うのでしょうか？理由は2つ、速度とスピードです。何が無事に到着したかを追跡し、順序立てて確認したりするよりも、発射して忘れる方がずっと速いのです。チャットメッセージを送るなら、TCP は素晴らしいです。世界中のプレイヤーの位置情報を毎秒40件送るなら、1件や2件が落ちてもそれほど問題ではないので、UDP は良い選択だと思います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-低レベルのナンセンスとネットワーク理論"><a class="header" href="#22-低レベルのナンセンスとネットワーク理論">2.2 低レベルのナンセンスとネットワーク理論</a></h1>
<p>先ほどプロトコルの階層化について触れましたので、そろそろネットワークが実際にどのように動作するのか、そして <code>SOCK_DGRAM</code> パケットがどのように構築されるのかについて、いくつかの例を挙げて説明しましょう。 実際のところ、このセクションは読み飛ばしても大丈夫でしょう。しかし、良い背景にはなります。</p>
<figure>
  <img
  src="images/dataencap.svg"
  alt="[Encapsulated Protocols Diagram]">
  <figcaption>データのカプセル化</figcaption>
</figure>
<p>子供たちよ、データカプセル化について学ぶ時間だ！これはとても重要なことです。あまりに重要なので、このチコステでネットワークの授業を受けると、このことを学ぶことになるかもしれません <code>;-)</code>. 基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えば TFTP プロトコル）によってヘッダー（まれにフッターも）でラップ（&quot;カプセル化&quot;）され、次のプロトコル（例えば UDP）によって全体（TFTP ヘッダーも含む）が再びカプセル化され、さらに次のプロトコル（IP）によってカプセル化され、ハードウェア（物理）層（例えば Ethernet）の最終プロトコルによって再びカプセル化されます。</p>
<p>他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルが IP と UDP ヘッダを、TFTP プログラムが TFTP ヘッダを取り除き、ようやくデータを手に入れることができます。</p>
<p>これでやっと悪名高いレイヤードネットワークモデル（通称 &quot;ISO/OSI&quot;）について語れるようになりました。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。</p>
<p>さっそくですが、本格的なモデルのレイヤーを紹介します。 ネットワーククラスの試験のために覚えておいてください。</p>
<ul>
<li>アプリケーション層</li>
<li>プレゼンテーション層</li>
<li>セッション層</li>
<li>トランスポート層</li>
<li>ネットワーク層</li>
<li>データリンク層</li>
<li>物理層</li>
</ul>
<p>物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと相互作用する場所です。</p>
<p>さて、このモデルは、本当にやろうと思えば、自動車の修理ガイドとして使えるほど一般的なものです。Unix とより整合性のあるレイヤーモデルは、次のようなものでしょう。</p>
<ul>
<li>アプリケーション層 (<em>telnet, ftp, etc.</em>)</li>
<li>Host-to-Host トランスポート層 (<em>TCP, UDP</em>)</li>
<li>インターネット層 (<em>IP and routing</em>)</li>
<li>ネットワークアクセス層 (<em>Ethernet, wi-fi, or whatever</em>)</li>
</ul>
<p>この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。</p>
<p>シンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ！そして、&quot;<code>cat</code>&quot; を使って自分でパケットヘッダを入力しなければならないのです！冗談です。ストリームソケットでやるべきことは、データを <code>send()</code> することだけです。データグラムソケットでは、あなたが選んだメソッドでパケットをカプセル化し、<code>sendto()</code> で送り出すだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築します。ああ、現代の技術ですね。</p>
<p>というわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていました：何もありません！（笑）。その通り、全く話すつもりはありません。ルータはパケットを IP ヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、<a href="https://datatracker.ietf.org/doc/html/rfc791">IP RFC</a> をチェックしてみてください。もしあなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-ip-アドレス-構造体-データマンジング"><a class="header" href="#3-ip-アドレス-構造体-データマンジング">3 IP アドレス, 構造体, データマンジング</a></h1>
<p>ここからは気分転換にコードの話をするところです。</p>
<p>その前に、もっとノンコードの話をしましょう！イエーイ！まず最初に IP アドレスとポートについて少しお話したいと思いますので、それを整理します。それからソケット API がどのように IP アドレスや他のデータを保存し、操作するかについて話します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-ip-アドレスバージョン4と6"><a class="header" href="#31-ip-アドレスバージョン4と6">3.1 IP アドレス、バージョン4と6</a></h1>
<p>ベン・ケノービがまだオビワン・ケノービと呼ばれていた頃、インターネット・プロトコル・バージョン4（IPv4）と呼ばれる素晴らしいネットワーク・ルーティング・システムが存在しました。IPv4 は 4 バイト（4オクテット）で構成されるアドレスで、一般に&quot;ドットと数字&quot;で表記されるのが一般的でした。<code>192.0.2.111</code> のように。</p>
<p>皆さんも一度は目にしたことがあるのではないでしょうか。</p>
<p>実際、この記事を書いている時点では、インターネット上のほぼすべてのサイトが IPv4 を使っています。</p>
<p>オビ・ワンをはじめ、誰もが幸せでした。しかし、ヴィント・サーフという名の否定的な人物が、IPv4 アドレスが足りなくなると警告を発したのです！</p>
<p>（<a href="https://en.wikipedia.org/wiki/Vint_Cerf">ヴィント・サーフ</a>氏は、IPv4 による&quot;破滅と暗黒の黙示録&quot;の到来を警告するとともに、&quot;インターネットの父&quot;としても有名です。だから、私は彼の判断に二の足を踏む立場にはないのです。）</p>
<p>アドレスが足りなくなる？そんなことがあるのでしょうか？つまり、32ビットの IPv4 アドレスには何十億もの IP アドレスが存在するのです。本当に何十億台ものコンピュータがあるのでしょうか？</p>
<p>Yes.</p>
<p>また、コンピュータが数台しかなく、10億という数字があり得ないほど大きいと誰もが思っていた当初、いくつかの大きな組織は、自分たちが使うために何百万というIPアドレスを惜しげもなく割り当てていたのです。（ゼロックス、MIT、フォード、HP、IBM、GE、AT&amp;T、そしてアップルという小さな会社などです。）</p>
<p>実際、いくつかの応急処置がなかったら、とっくに使い果たしていたでしょう。</p>
<p>しかし今は、すべての人間がIPアドレスを持ち、すべてのコンピュータ、電卓、電話、パーキングメーター、そして（なぜか）子犬も、という時代です。</p>
<p>そして、IPv6 が誕生したのです。ヴィント・サーフはおそらく不死身なので（たとえ肉体がこの世を去ったとしても、おそらく彼はすでにインターネット2の奥深くにある超知的な <a href="https://en.wikipedia.org/wiki/ELIZA">ELIZA</a> プログラムとして存在しているはずです）、もし次のバージョンのインターネットプロトコルで十分なアドレスが確保できなければ、誰も彼の&quot;だから言っただろう&quot;という言葉を再び聞きたくはないでしょう。</p>
<p>これは何を示唆しているのでしょうか？</p>
<p>もっとたくさんのアドレスが必要だということです。2倍どころか10億倍でもなく1000兆倍でもなく 7900万ビリオン・トリリオンの数のアドレスが必要なのです！そうこなくちゃ！</p>
<p>ビージェイ、それは本当なの？大きな数字を信じない理由があるんだ。&quot;32ビットと128ビットの差は大したことないように聞こえるかもしれない、96ビット多いだけだろ？しかし、私たちはここで累乗の話をしていることを忘れてはなりません。32ビットは約40億の数字（2^32）を表し、128ビットは約340兆の数字（2^128）を表します。これは、宇宙の星1つに対して、100万個の IPv4 インターネットがあるようなものです。</p>
<p>IPv4のドットや数字も忘れて、16進数では、2バイトの塊をコロンで区切って、このように表現しています。</p>
<pre><code>2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551
</code></pre>
<p>それだけではありません！多くの場合、IPアドレスにはたくさんのゼロが含まれていますが、それらを2つのコロンで区切って圧縮することができます。そして、各バイトペアの先頭のゼロを省くことができます。例えば、次のようなアドレスのペアは、それぞれ等価です。</p>
<pre><code>2001:0db8:c9d2:0012:0000:0000:0000:0051
2001:db8:c9d2:12::51

2001:0db8:ab00:0000:0000:0000:0000:0000
2001:db8:ab00::

0000:0000:0000:0000:0000:0000:0000:0001
::1
</code></pre>
<p>アドレス <code>::1</code> はループバックアドレスです。常に「今走っているこのマシン」という意味です。IPv4 では、ループバックアドレスは <code>127.0.0.1</code> です。</p>
<p>最後に、IPv6 アドレスの IPv4 互換モードですが、これは皆さんが遭遇する可能性のあるものです。例えば、<code>192.0.2.33</code>という IPv4 アドレスを IPv6 アドレスとして表現したい場合、次のような表記をします。&quot;<code>::ffff:192.0.2.33</code>&quot;。</p>
<p>本気で楽しみたいんです。</p>
<p>実際、IPv6 の開発者たちは、何兆個ものアドレスを軽率にも予約用に切り捨てたほど、IPv6 は楽しいものなのですが、数が多すぎて、正直言って、もう誰が数えているのでしょうか？銀河系のすべての惑星のすべての男性、女性、子供、子犬、そしてパーキングメーターのために十分な数が残されています。 信じてくれ、銀河系のどの星にもパーキングメーターはあるんだ。本当なんだ。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="311-サブネット"><a class="header" href="#311-サブネット">3.1.1 サブネット</a></h1>
<p>組織上、「この IP アドレスの先頭からこのビットまでがネットワーク部分、それ以外がホスト部分」と宣言するのが便利な場合があります。</p>
<p>例えば、IPv4 では <code>192.0.2.12</code> というように、最初の3バイトがネットワークで、最後の1バイトがホストと言えるでしょう。あるいは、別の言い方をすれば、ネットワーク <code>192.0.2.0</code> 上のホスト <code>12</code> について話していることになります（ホストであるバイトをゼロにしているところをご覧ください）。</p>
<p>そして、さらに時代遅れの情報を! 準備はいいですか？古代では、サブネットには「クラス」があり、アドレスの最初の1バイト、2バイト、3バイトがネットワーク部分でした。運良く1バイトがネットワーク、3バイトがホストの場合、ネットワーク上に24ビット分のホスト（1600万程度）を持つことができます。これが「クラス A」のネットワークである。一方、「クラス C」は、ネットワークが3バイト、ホストが1バイトで、256台のホスト（ただし、予約された数台は除く）を持ちます。</p>
<p>ご覧のように、A クラスがほんの少し、C クラスが大量に、そして真ん中に B クラスが何個かある状態でした。</p>
<p>IP アドレスのネットワーク部分は、ネットマスクと呼ばれるもので記述されており、IP アドレスとビット単位で AND することでネットワーク番号を取得します。ネットマスクは通常 <code>255.255.255.0</code> のような形をしています。（例えば、このネットマスクでは、あなたの IP が <code>192.0.2.12</code> なら、あなたのネットワークは <code>192.0.2.12</code> AND <code>255.255.255.0</code> で、 <code>192.0.2.0</code> となります。）</p>
<p>しかし、残念ながら、これはインターネットの最終的なニーズに対して十分なきめ細かさではないことが判明しました。クラスCのネットワークはすぐに足りなくなったし、クラスAのネットワークも足りなくなったので、わざわざ尋ねる必要はありません。この問題を解決するために、権力者たちはネットマスクを 8、16、24 のどれでもなく、任意のビット数にすることを許可しました。例えば <code>255.255.255.252</code> というネットマスクは、30 ビットのネットワークと 2 ビットのホストで、 ネットワーク上に 4 つのホストを置くことができます。（ネットマスクは常に1ビットの束と0ビットの束からなることに注意してください。）</p>
<p>しかし、<code>255.192.0.0</code> のような大きな数字の羅列をネットマスクとして使うのは、少し扱いにくいです。まず、それが何ビットなのかが直感的にわからないし、コンパクトでもありません。そこで新スタイルが登場したのですが、これはもっとすっきりしています。IP アドレスの後にスラッシュを付けて、その後に10進数でネットワークのビット数を指定するだけです。こんな感じです。<code>192.0.2.12/30</code>。</p>
<p>あるいは、IPv6 の場合、このようなものです。<code>2001:db8::/32</code> または <code>2001:db8:5413:4028::9db9/64</code> です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="312-ポート番号"><a class="header" href="#312-ポート番号">3.1.2 ポート番号</a></h1>
<p>以前、インターネット層（IP）とホスト間トランスポート層（TCPとUDP）を分離した<a href="ip-addresses-structs-and-data-munging/docs/what-is-a-socket/#lowlevel">レイヤードネットワークモデル</a>をご紹介しましたが、覚えていらっしゃいますか？次の段落の前に、そのことをしっかり覚えておいてください。</p>
<p>IP アドレス（IP 層で使われる）の他に、TCP（ストリームソケット）や、偶然にも UDP（データグラムソケット）で使われるアドレスがあることが判明したのです。それは、ポート番号です。これは16ビットの数字で、接続のためのローカルアドレスのようなものです。</p>
<p>IP アドレスはホテルの番地、ポート番号は部屋番号だと思ってください。後で自動車業界の例も考えてみましょう。</p>
<p>例えば、受信メールとウェブサービスの両方を扱うコンピュータを用意したい場合、1つのIPアドレスを持つコンピュータでその2つを区別する方法はあるでしょうか？</p>
<p>さて、インターネット上のサービスには、それぞれ異なるウェルノウン・ポート番号が設定されています。 <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">IANA のポート一覧</a>か、Unix であれば <code>/etc/services</code> ファイルで確認することができます。HTTP（ウェブ）はポート80、telnet はポート23、SMTP はポート25、ゲーム <a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)">DOOM</a> はポート666、などなど。1024以下のポートはしばしば特殊とみなされ、通常、使用するには OS の特別な権限が必要です。</p>
<p>といったところでしょうか。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-バイトオーダー"><a class="header" href="#32-バイトオーダー">3.2 バイトオーダー</a></h1>
<p>レルムの命令で！バイトの並び順は2種類とします。今後、Lame and Magnificent と呼ばれるようになります。</p>
<p>というのは冗談ですが、本当にどちらか一方が優れているのです。<code>:-)</code></p>
<p>あなたのコンピュータは、あなたの背後でバイトを逆順に保存しているかもしれないのです。そうなんです。誰もあなたに言いたくはなかったのです。</p>
<p>つまり、2バイトの16進数、たとえば <code>b34f</code> を表現する場合、<code>b3</code> と <code>4f</code> の2バイトに続けて格納する、というのがインターネットの世界の共通認識になっているのです。これは理にかなっているし、<a href="https://en.wikipedia.org/wiki/Wilford_Brimley">ウィルフォード・ブリムリー</a>も言うように、正しい行為です。このように、大きい方の端が先になるように格納された数字をビッグエンディアン（Big-Endian）と呼びます。</p>
<p>残念ながら、世界中に散在する一部のコンピュータ、すなわちインテルまたはインテル互換のプロセッサを搭載したものは、バイトを逆に格納しているため、<code>b34f</code>は <code>4f</code> と <code>b3</code> の連続したバイトとしてメモリに格納されることになります。この記憶方式をリトルエンディアンと呼びます。</p>
<p>でも、ちょっと待ってください！用語の説明はまだ終わっていないのです。もっとまともなビッグエンディアンはネットワークバイトオーダーとも呼ばれ、私たちネットワーク系が好む順序だからです。</p>
<p>コンピュータはホストバイトオーダーで数字を記憶しています。インテル 80x86 であれば、ホストバイト順はリトルエンディアンです。モトローラ 68K の場合は、ビッグエンディアンです。PowerPC なら、ホストバイトの並びは......まあ、人それぞれですね。</p>
<p>パケットを作成するときやデータ構造を埋めるときに、2バイトや4バイトの数値がネットワークバイトオーダーになっていることを確認する必要があることがよくあります。しかし、ネイティブなホストバイトオーダーがわからない場合、どのようにすればよいのでしょうか。</p>
<p>朗報です。ホストのバイトオーダーが正しくないと仮定して、値をネットワークバ イトオーダーに設定するための関数を常に実行するようにすればよいのです。この関数は、必要であれば魔法のような変換を行い、エンディアンが異なるマシンにもコードを移植することができます。</p>
<p>よしよし。変換できる数値は、<code>short</code>（2バイト）と <code>long</code>（4バイト）の2種類です。これらの関数は、符号なしのバリエーションでも動作します。例えば、<code>short</code> をホストバイトオーダーからネットワークバイトオーダーに変換したいとします。まず &quot;h&quot; でホスト、その後に &quot;to&quot; をつけます。そして、&quot;n&quot; は &quot;network&quot;、&quot;s&quot; は &quot;short&quot; を表します。h-to-n-s または htons() (読み方: &quot;ホストからネットワークへのショート&quot;) です。</p>
<p>簡単すぎるくらいに...。</p>
<p>&quot;n&quot;、&quot;h&quot;、&quot;s&quot;、&quot;l&quot; の組み合わせは、本当にくだらないものを除いて、すべて使うことができるのです。たとえば、<code>stolh()</code> (&quot;Short to Long Host&quot;) という関数はありません---とにかく、このパーティーでは。しかし、あるのです。</p>
<table><thead><tr><th>関数</th><th>説明</th></tr></thead><tbody>
<tr><td><code>htons()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>s</code>hort</td></tr>
<tr><td><code>htonl()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>l</code>ong</td></tr>
<tr><td><code>ntohs()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>s</code>hort</td></tr>
<tr><td><code>ntohl()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>l</code>ong</td></tr>
</tbody></table>
<p>基本的には、送出する前にネットワークバイトオーダーに変換し、送出後にホストバイトオーダーに変換します。</p>
<p>64bitのバリエーションは知らないです、すみません。また、浮動小数点をやりたい場合は、ずっと下の<a href="ip-addresses-structs-and-data-munging/byte-order.html#serialization">Serialization</a> の章をチェックしてください。</p>
<p>この文書では、特に断らない限り、数値はホストバイトオーダーであると仮定しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-構造体"><a class="header" href="#33-構造体">3.3 構造体</a></h1>
<p>さて、ついにここまで来ました。そろそろプログラミングの話をしましょう。この章では、ソケットインターフェイスで使用される様々なデータ型について説明します。</p>
<p>まず、簡単なものからです。ソケットディスクリプタです。ソケットディスクリプタは以下のような型です。</p>
<pre><code class="language-c">int
</code></pre>
<p>普通の <code>int</code> です。</p>
<p>ここからは変な話なので、我慢して読んでください。</p>
<p>My First Struct™---<code>struct addrinfo</code>。この構造体は最近開発されたもので、ソケットアドレス構造体を後で使用するために準備するために使用されます。また、ホスト名のルックアップやサービス名のルックアップにも使用されます。これは、後で実際の使い方を説明するときに、より意味をなすと思いますが、今は、接続を行うときに最初に呼び出されるものの1つであることを知っておいてください。</p>
<pre><code class="language-c">struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for &quot;any&quot;
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
};
</code></pre>
<p>この構造体を少し読み込んでから、<code>getaddrinfo()</code> を呼び出します。この構造体のリンクリストへのポインタが返され、必要なものがすべて満たされます。</p>
<p><code>ai_family</code> フィールドで IPv4 か IPv6 を使うように強制することもできますし、<code>AF_UNSPEC</code> のままにして何でも使えるようにすることも可能です。これは、あなたのコードが IP バージョンに依存しないので、クールです。</p>
<p>これはリンクされたリストであることに注意してください：<code>ai_next</code> は次の要素を指しています---そこから選択するためにいくつかの結果があるかもしれません。私は最初にうまくいった結果を使いますが、あなたは異なるビジネスニーズを持っているかもしれません。何でもかんでも知ってるわけじゃないんです！</p>
<p><code>struct addrinfo</code> の <code>ai_addr</code> フィールドは <code>struct sockaddr</code> へのポインタであることがわかります。ここからが、IP アドレス構造体の中身についての細かい話になります。</p>
<p>通常、これらの構造体に書き込む必要はありません。多くの場合、<code>addrinfo</code> 構造体を埋めるために <code>getaddrinfo()</code> を呼び出すだけでよいでしょう。しかし、これらの構造体の内部を覗いて値を取得する必要があるため、ここでそれらを紹介します。</p>
<p>(また、構造体 <code>addrinfo</code> が発明される前に書かれたコードはすべて、これらのものをすべて手作業で梱包していたので、まさにそのような IPv4 コードを多く見かけることができます。このガイドの古いバージョンなどでもそうです)。</p>
<p>ある構造体は IPv4 で、ある構造体は IPv6 で、ある構造体はその両方です。どれが何なのか、メモしておきます。</p>
<p>とにかく、構造体 <code>sockaddr</code> は、多くの種類のソケットのためのソケットアドレス情報を保持します。</p>
<pre><code class="language-c">struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
};
</code></pre>
<p><code>sa_family</code> には様々なものを指定できますが、この文書ではすべて <code>AF_INET</code> (IPv4) または <code>AF_INET6</code> (IPv6) とします。<code>sa_data</code> にはソケットの宛先アドレスとポート番号を指定します。<code>sa_data</code> にアドレスを手で詰め込むのは面倒なので、これはかなり扱いにくいです。</p>
<p>構造体 <code>sockaddr</code> を扱うために、プログラマは IPv4 で使用する構造体 <code>sockaddr_in</code>（&quot;in&quot; は &quot;Internet&quot; の意）を並列に作成しました。</p>
<p><code>sockaddr_in</code> 構造体へのポインタは <code>sockaddr</code> 構造体へのポインタにキャストすることができ、その逆も可能です。つまり、<code>connect()</code> が <code>struct sockaddr*</code> を要求しても、<code>struct sockaddr_in</code> を使用して、最後の最後でキャストすることができるのです！</p>
<pre><code class="language-c">// (IPv4 only--see struct sockaddr_in6 for IPv6)

struct sockaddr_in {
    short int          sin_family;  // Address family, AF_INET
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
};
</code></pre>
<p>この構造体により、ソケットアドレスの要素を簡単に参照することができます。<code>sin_zero</code> (構造体を <code>struct sockaddr</code> の長さに合わせるために含まれます) は、関数 <code>memset()</code> ですべて 0 に設定する必要があることに注意すること。また、<code>sin_family</code> は <code>struct sockaddr</code> の <code>sa_family</code> に相当し、&quot;<code>AF_INET</code>&quot; に設定されることに注意します。最後に、<code>sin_port</code> はネットワークバイトオーダーでなければなりません（<code>htons()</code> を使用することで！）。</p>
<p>もっと掘り下げましょう！<code>sin_addr</code> フィールドは <code>in_addr</code> 構造体であることがわかりますね。あれは何なんだ？まあ、大げさではなく、史上最も恐ろしい組合せの1つです。</p>
<pre><code class="language-c">// (IPv4 only--see struct in6_addr for IPv6)

// Internet address (a structure for historical reasons)
struct in_addr {
    uint32_t s_addr; // that's a 32-bit int (4 bytes)
};
</code></pre>
<p>うおぉ まあ、昔はユニオンだったんだけど、今はもうそういう時代じゃないみたいだね。おつかれさまでした。つまり、<code>ina</code> を <code>struct sockaddr_in</code> 型と宣言した場合、<code>ina.sin_addr.s_addr</code> は4バイトの IP アドレス（ネットワークバイトオーダー）を参照することになります。あなたのシステムがまだ <code>struct in_addr</code> のための神々しいユニオンを使用している場合でも、あなたはまだ私が上記のように全く同じ方法で4バイトの IP アドレスを参照することができます（これは <code>#defines</code> によるものです）ことに注意してください。</p>
<p>IPv6 ではどうでしょうか。これについても同様の構造体が存在します。</p>
<pre><code class="language-c">// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)

struct sockaddr_in6 {
    u_int16_t       sin6_family;   // address family, AF_INET6
    u_int16_t       sin6_port;     // port number, Network Byte Order
    u_int32_t       sin6_flowinfo; // IPv6 flow information
    struct in6_addr sin6_addr;     // IPv6 address
    u_int32_t       sin6_scope_id; // Scope ID
};

struct in6_addr {
    unsigned char   s6_addr[16];   // IPv6 address
};
</code></pre>
<p>IPv4 が IPv4 アドレスとポート番号を持つように、IPv6 も IPv6 アドレスとポート番号を持つことに注意してください。</p>
<p>また、IPv6 フロー情報やスコープ ID のフィールドについては、今のところ触れないことに注意してください。<code>:-)</code></p>
<p>最後になりますが、こちらもシンプルな構造体である <code>struct sockaddr_storage</code> は、IPv4 と IPv6 の両方の構造体を保持できるように十分な大きさに設計されています。コールによっては、<code>struct sockaddr</code> に IPv4 と IPv6 のどちらのアドレスが記入されるのか事前にわからないことがありますよね。そこで、この並列構造体を渡しますが、サイズが大きい以外は <code>struct sockaddr</code> とよく似ており、必要な型にキャストします。</p>
<pre><code class="language-c">struct sockaddr_storage {
    sa_family_t  ss_family;     // address family

    // all this is padding, implementation specific, ignore it:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};
</code></pre>
<p>重要なのは、<code>ss_family</code> フィールドでアドレスファミリーを確認できることで、これが <code>AF_INET</code> か <code>AF_INET6</code>（IPv4 か IPv6 か）かを確認することです。それから、必要なら <code>struct sockaddr_in</code> や <code>struct sockaddr_in6</code> にキャストすることができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-ip-アドレスパート2"><a class="header" href="#34-ip-アドレスパート2">3.4 IP アドレス、パート2</a></h1>
<p>幸いなことに、IP アドレスを操作するための関数がたくさんあります。手書きで把握して <code>&lt;&lt;</code> 演算子で <code>long</code> に詰め込む必要はありません。</p>
<p>まず、<code>struct sockaddr_in ina</code> があり、そこに格納したい IP アドレスが <code>10.12.110.57</code> または <code>2001:db8:63b3:1::3490</code> だとしましょう。<code>inet_pton()</code> という関数は、数字とドットで表記された IP アドレスを、<code>AF_INET</code> か <code>AF_INET6</code> の指定によって、<code>in_addr</code> 構造体か <code>in6_addr</code> 構造体に変換する関数です。(&quot;<code>pton</code>&quot; は &quot;presentation to network&quot; の略で、覚えやすければ &quot;printable to network&quot; と呼んでも構いません)。変換は次のように行うことができます。</p>
<pre><code class="language-c">struct sockaddr_in sa; // IPv4
struct sockaddr_in6 sa6; // IPv6

inet_pton(AF_INET, &quot;10.12.110.57&quot;, &amp;(sa.sin_addr)); // IPv4
inet_pton(AF_INET6, &quot;2001:db8:63b3:1::3490&quot;, &amp;(sa6.sin6_addr)); // IPv6
</code></pre>
<p>(クイックメモ: 古い方法では、<code>inet_addr()</code> という関数や <code>inet_aton()</code> という別の関数を使っていましたが、これらはもう時代遅れで IPv6 では動きません。)</p>
<p>さて、上記のコードスニペットは、エラーチェックがないため、あまり堅牢ではありません。<code>inet_pton()</code> はエラー時に <code>-1</code> を返し、アドレスがめちゃくちゃになった場合は 0 を返します。ですから、使用する前に結果が 0 よりも大きいことを確認してください！</p>
<p>さて、これで文字列の IP アドレスをバイナリ表現に変換することができるようになりました。では、その逆はどうでしょうか？<code>in_addr</code> 構造体を持っていて、それを数字とドットの表記で印刷したい場合はどうでしょうか。(この場合、関数 <code>inet_ntop()</code> (&quot;<code>ntop</code>&quot; は &quot;network to presentation&quot; という意味です。覚えやすければ &quot;network to printable&quot; と呼んでも構いません) を次のように使用します。</p>
<pre><code class="language-c">// IPv4:

char ip4[INET_ADDRSTRLEN];  // space to hold the IPv4 string
struct sockaddr_in sa;      // pretend this is loaded with something

inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);

printf(&quot;The IPv4 address is: %s\n&quot;, ip4);


// IPv6:

char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string
struct sockaddr_in6 sa6;    // pretend this is loaded with something

inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);

printf(&quot;The address is: %s\n&quot;, ip6);
</code></pre>
<p>呼び出す際には、アドレスの種類（IPv4 または IPv6）、アドレス、結果を格納する文字列へのポインタ、その文字列の最大長を渡すことになります。(2つのマクロは、最大の IPv4 または IPv6 アドレスを保持するために必要な文字列のサイズを都合よく保持します。<code>INET_ADDRSTRLEN</code> と <code>INET6_ADDRSTRLEN</code> です)。</p>
<p>(古いやり方についてもう一度簡単に触れておくと、この変換を行う歴史的な関数は <code>inet_ntoa()</code> と呼ばれるものでした。これも時代遅れで、IPv6 では動きません。)</p>
<p>最後に、これらの関数は数値の IP アドレスに対してのみ動作します。&quot;<code>www.example.com</code>&quot; のようなホスト名に対してネームサーバの DNS ルックアップは行いません。後ほど説明するように、そのためには <code>getaddrinfo()</code> を使用します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="341-プライベートまたはディスコネクトネットワーク"><a class="header" href="#341-プライベートまたはディスコネクトネットワーク">3.4.1 プライベート（またはディスコネクト）ネットワーク</a></h1>
<p>多くの場所では、自分たちを守るために、ネットワークを他の地域から隠すファイアウォールがあります。そして多くの場合、ファイアウォールは、ネットワークアドレス変換（NAT）と呼ばれるプロセスを使って、&quot;内部&quot; IP アドレスを&quot;外部&quot;（世界中の誰もが知っている）IP アドレスに変換しています。</p>
<p>もう緊張してきましたか？&quot;こんな変なことして どこへ行くんだろう？&quot;</p>
<p>まあ、ノンアルコール飲料でも買ってリラックスしてください。初心者の場合、NAT は透過的に行われるので、心配する必要もありませんから。しかし、あなたが見ているネットワーク番号に混乱し始めた場合に備えて、ファイアウォールの背後にあるネットワークについて話したいと思います。</p>
<p>例えば、私の自宅にはファイアウォールがあります。DSL 会社から割り当てられた2つの固定 IPv4 アドレスを持っていますが、ネットワーク上に7台のコンピューターがあります。どうしてこんなことが可能なのでしょうか？2台のコンピュータが同じ IP アドレスを共有することはできませんし、そうでなければデータはどちらに行けばいいのかわからなくなってしまいます。</p>
<p>答えは、&quot;同じIPアドレスを共有していない&quot;です。2400万個の IP アドレスが割り当てられたプライベートネットワーク上にあるのです。それらはすべて私のためだけのものです。まあ、他の人たちから見れば、すべて私のためのものなのですが。ここで、何が起こっているのかを説明します。</p>
<p>リモートコンピューターにログインすると、ISP から提供されたパブリック IP アドレスである <code>192.0.2.33</code> からログインしていると表示されるのです。しかし、ローカルコンピューターにその IP アドレスを尋ねると、<code>10.0.0.5</code> と答えるのです。誰が IP アドレスを変換しているのでしょうか？そうです、ファイアウォールです。ファイアウォールが NAT しているのです。</p>
<p><code>10.x.x.x</code> は、完全に切断されたネットワークか、ファイアウォールの内側にあるネットワークでのみ使用される、数少ない予約ネットワークの1つです。どのプライベート・ネットワーク番号が使用できるかの詳細は、<a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a> に概説されていますが、一般的によく目にするのは、<code>10.x.x.x</code> と <code>192.168.x.x</code> で、<code>x</code> は通常 0 ～ 255 です。一般的ではないのは、<code>172.y.x.x</code> で、<code>y</code> は16から31の間です。</p>
<p>NAT するファイアウォールの内側のネットワークは、これらの予約されたネットワークのいずれかにある必要はありませんが、一般的にはそうなっています。</p>
<p>(楽しい事実！私の外部 IP アドレスは、本当は <code>192.0.2.33</code> ではないのです。<code>192.0.2.x</code> ネットワークは、このガイドのように、ドキュメントで使用するための架空の&quot;本当の&quot; IP アドレスのために予約されているのです！わーい、すごい！)</p>
<p>IPv6 にも、ある意味プライベートネットワークがあります。<a href="https://datatracker.ietf.org/doc/html/rfc4193">RFC 4193</a> にあるように、<code>fdXX:</code>（将来的には <code>fcXX:</code>）で始まります。しかし、NAT と IPv6 は一般的に混ざりません(このドキュメントの範囲外である IPv6 から IPv4 へのゲートウェイを行う場合を除きます)。理論的には、自由に使えるアドレスが非常に多くなるため、NAT を使用する必要はなくなるはずです。しかし、外部にルーティングしないネットワーク上で自分のためにアドレスを割り当てたい場合は、このようにします。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-ipv4-から-ipv6-へのジャンプ"><a class="header" href="#4-ipv4-から-ipv6-へのジャンプ">4 IPv4 から IPv6 へのジャンプ</a></h1>
<p>しかし、IPv6 で動作させるためには、私のコードのどこを変えればいいのか知りたいのです！今すぐ教えてください！</p>
<p>Ok! Ok!</p>
<p>ここに書かれていることはほとんどすべて、私が上で説明したことですが、せっかちな人のためのショートバージョンです。（もちろん、これ以外にもありますが、このガイドに該当するのはこれです。）</p>
<ol>
<li>
<p>まず、構造体を手で詰めるのではなく、<a href="jumping-from-ipv4-to-ipv6/docs/ip-addresses-structs-and-data-munging/#structs"><code>getaddrinfo()</code></a> を使ってすべての <code>sockaddr</code> 構造体の情報を取得するようにしてください。こうすることで、IP のバージョンに左右されず、また、その後の多くのステップを省くことができます。</p>
</li>
<li>
<p>IP バージョンに関連する何かをハードコーディングしていることが分かったら、ヘルパー関数でラップするようにします。</p>
</li>
<li>
<p><code>AF_INET</code> を <code>AF_INET6</code> に変更します。</p>
</li>
<li>
<p><code>PF_INET</code> を <code>PF_INET6</code> に変更します。</p>
</li>
<li>
<p><code>INADDR_ANY</code> の割り当てを <code>in6addr_any</code> の割り当てに変更し、若干の差異が生じます。</p>
<pre><code class="language-c">struct sockaddr_in sa;
struct sockaddr_in6 sa6;

sa.sin_addr.s_addr = INADDR_ANY;  // use my IPv4 address
sa6.sin6_addr = in6addr_any; // use my IPv6 address
</code></pre>
<p>Also, the value <code>IN6ADDR_ANY_INIT</code> can be used as an initializer when
the <code>struct in6_addr</code> is declared, like so:</p>
<pre><code class="language-c">struct in6_addr ia6 = IN6ADDR_ANY_INIT;
</code></pre>
</li>
<li>
<p><code>struct sockaddr_in</code> の代わりに <code>struct sockaddr_in6</code> を使用し、必要に応じてフィールドに &quot;6&quot; を追加してください（上記の <a href="jumping-from-ipv4-to-ipv6/docs/ip-addresses-structs-and-data-munging/#structs"><code>struct</code>s</a> を参照）。<code>sin6_zero</code> フィールドはありません。</p>
</li>
<li>
<p><code>struct in_addr</code> の代わりに <code>struct in6_addr</code> を使用し、必要に応じてフィールドに &quot;6&quot; を追加してください（上記の <a href="jumping-from-ipv4-to-ipv6/docs/ip-addresses-structs-and-data-munging/#structs"><code>struct</code>s</a> を参照）。</p>
</li>
<li>
<p><code>inet_aton()</code> や <code>inet_addr()</code> の代わりに、<code>inet_apton()</code> を使用してください。</p>
</li>
<li>
<p><code>inet_ntoa()</code> の代わりに <code>inet_ntop()</code> を使用してください。</p>
</li>
<li>
<p><code>gethostbyname()</code> の代わりに、優れた <code>getaddrinfo()</code> を使用してください。</p>
</li>
<li>
<p><code>gethostbyaddr()</code> の代わりに、優れた <code>getnameinfo()</code> を使用してください（<code>gethostbyaddr()</code>は IPv6 でも動作可能です）。</p>
</li>
<li>
<p><code>INADDR_BROADCAST</code> は動作しなくなりました。代わりに IPv6 マルチキャストを使用してください。</p>
</li>
</ol>
<p>出来上がり！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-システムコールかバスト"><a class="header" href="#5-システムコールかバスト">5 システムコールかバスト</a></h1>
<p>このセクションでは、Unix マシンのネットワーク機能にアクセスするためのシステムコールやその他のライブラリコールに触れることができますし、ソケット API をサポートしているあらゆるマシン (BSD, Windows, Linux, Mac, など) も同様です。これらの関数を呼び出すと、カーネルが引き継ぎ、すべての作業を自動で行ってくれます。</p>
<p>このあたりで多くの人がつまづくのは、これらのものをどのような順序で呼び出すかということです。これについては、皆さんもお分かりのように、<code>man</code> ページが役に立ちません。そこで、この恐ろしい状況を改善するために、以下の章のシステムコールを、あなたがプログラムの中で呼び出す必要があるのと全く（おおよそ）同じ順序で並べることにしました。</p>
<p>これに、あちこちにあるサンプルコード、ミルクとクッキー（自分で用意しなければならないのが怖い）、そして生粋のガッツと勇気があれば、ジョン・ポステルの息子のようにインターネット上でデータを発信することができるのです！</p>
<p>（なお、以下の多くのコードでは、簡潔にするため、必要なエラーチェックは行っていません。また、<code>getaddrinfo()</code> の呼び出しが成功し、リンクリストの有効なエントリを返すと仮定することが非常に一般的です。これらの状況はいずれもスタンドアロン・プログラムで適切に対処されているので、それらをモデルとして使用してください。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="51-getaddrinfo---起動の準備をしよう"><a class="header" href="#51-getaddrinfo---起動の準備をしよう">5.1 <code>getaddrinfo()</code>---起動の準備をしよう！</a></h1>
<p>この関数は多くのオプションを持つ真の主力関数ですが、使い方はいたってシンプルです。後で必要な構造体をセットアップするのに役立ちます。</p>
<p>昔は、<code>gethostbyname()</code> という関数を使って DNS のルックアップを行っていました。そして、その情報を <code>sockaddr_in</code> 構造体に手作業でロードし、それを呼び出しに使用するのです。</p>
<p>これは、ありがたいことに、もう必要ありません。(IPv4 と IPv6 の両方で動作するコードを書きたいのであれば、望ましいことではありません！) 現代では、DNS やサービス名のルックアップなど、あらゆる種類の良いことをやってくれる <code>getaddrinfo()</code> という関数があり、さらに必要な <code>struct</code> も埋めてくれます！</p>
<p>それでは、ご覧ください！</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *node,     // e.g. &quot;www.example.com&quot; or IP
                const char *service,  // e.g. &quot;http&quot; or port number
                const struct addrinfo *hints,
                struct addrinfo **res);
</code></pre>
<p>この関数に3つの入力パラメータを与えると、結果のリンクリストである <code>res</code> へのポインタが得られます。</p>
<p><code>node</code> パラメータには、接続先のホスト名、または IP アドレスを指定します。</p>
<p>次にパラメータ <code>service</code> ですが、これは &quot;80&quot; のようなポート番号か、&quot;http&quot;, &quot;ftp&quot;, &quot;telnet&quot;, &quot;smtp&quot; などの特定のサービスの名前（<a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">IANAポートリスト</a>や Unix マシンの <code>/etc/services</code> ファイルで見つけることができます）であることができます。</p>
<p>最後に、<code>hints</code> パラメータは、関連情報をすでに記入した <code>addrinfo</code> 構造体を指します。</p>
<p>以下は、自分のホストの IP アドレス、ポート 3490 をリッスンしたいサーバの場合の呼び出し例です。これは実際にはリスニングやネットワークの設定を行っていないことに注意してください。</p>
<pre><code class="language-c">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

if ((status = getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, &quot;getaddrinfo error: %s\n&quot;, gai_strerror(status));
    exit(1);
}

// servinfo now points to a linked list of 1 or more struct addrinfos

// ... do everything until you don't need servinfo anymore ....

freeaddrinfo(servinfo); // free the linked-list
</code></pre>
<p><code>ai_family</code> を <code>AF_UNSPEC</code> に設定することで、IPv4 や IPv6 を使うかどうかを気にしないことを表明していることに注意してください。もし、どちらか一方だけを使いたい場合は、<code>AF_INET</code> または <code>AF_INET6</code> に設定することができます。</p>
<p>また、<code>AI_PASSIVE</code> フラグがあるのがわかると思いますが、これは <code>getaddrinfo()</code> にローカルホストのアドレスをソケット構造体に割り当てるように指示しています。これは、ハードコードする必要がないのがいいところです。(あるいは、<code>getaddrinfo()</code> の最初のパラメータとして特定のアドレスを入れることもできます。私は現在 <code>NULL</code> を持っています。)</p>
<p>そして、呼び出しを行います。エラー(<code>getaddrinfo()</code> が0以外を返す)があれば、ご覧のように関数 <code>gai_strerror()</code> を使ってそれを表示することができます。しかし、すべてがうまくいけば、<code>servinfo</code> は <code>struct addrinfos</code> のリンクリストを指し、それぞれのリストには後で使用できる何らかの <code>sockaddr</code> 構造体が含まれています！素晴らしい！</p>
<p>最後に、<code>getaddrinfo()</code> が快く割り当ててくれたリンクリストをすべて使い終わったら、<code>freeaddrinfo()</code> を呼び出してすべてを解放することができます(そうすべき)です。</p>
<p>ここでは、クライアントが特定のサーバ、例えば &quot;www.example.net&quot; ポート 3490 に接続したい場合のサンプルコールを紹介します。繰り返しますが、これは実際には接続しませんが、後で使用する構造をセットアップしています。</p>
<pre><code class="language-c">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets

// get ready to connect
status = getaddrinfo(&quot;www.example.net&quot;, &quot;3490&quot;, &amp;hints, &amp;servinfo);

// servinfo now points to a linked list of 1 or more struct addrinfos

// etc.
</code></pre>
<p><code>servinfo</code> は、あらゆるアドレス情報を持つリンクリストだと言い続けています。この情報を披露するために、簡単なデモプログラムを書いてみよう。<a href="https://beej.us/guide/bgnet/examples/showip.c">この短いプログラム</a>は、コマンドラインで指定された任意のホストの IP アドレスを表示します。</p>
<pre><code class="language-c">/*
** showip.c -- show IP addresses for a host given on the command line
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;

int main(int argc, char *argv[])
{
    struct addrinfo hints, *res, *p;
    int status;
    char ipstr[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,&quot;usage: showip hostname\n&quot;);
        return 1;
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // AF_INET or AF_INET6 to force version
    hints.ai_socktype = SOCK_STREAM;

    if ((status = getaddrinfo(argv[1], NULL, &amp;hints, &amp;res)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(status));
        return 2;
    }

    printf(&quot;IP addresses for %s:\n\n&quot;, argv[1]);

    for(p = res;p != NULL; p = p-&gt;ai_next) {
        void *addr;
        char *ipver;

        // get the pointer to the address itself,
        // different fields in IPv4 and IPv6:
        if (p-&gt;ai_family == AF_INET) { // IPv4
            struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-&gt;ai_addr;
            addr = &amp;(ipv4-&gt;sin_addr);
            ipver = &quot;IPv4&quot;;
        } else { // IPv6
            struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-&gt;ai_addr;
            addr = &amp;(ipv6-&gt;sin6_addr);
            ipver = &quot;IPv6&quot;;
        }

        // convert the IP to a string and print it:
        inet_ntop(p-&gt;ai_family, addr, ipstr, sizeof ipstr);
        printf(&quot;  %s: %s\n&quot;, ipver, ipstr);
    }

    freeaddrinfo(res); // free the linked list

    return 0;
}
</code></pre>
<p>ご覧のように、このコードはコマンドラインで渡されたものに対して <code>getaddrinfo()</code> を呼び出し、<code>res</code> が指すリンクリストを埋めて、そのリストを繰り返し表示して何かを出力したりすることができます。</p>
<p>(そこには、IP バージョンによって異なるタイプの <code>struct sockaddrs</code> を掘り下げなければならない、ちょっとした醜さがあります。申し訳ありません。他にいい方法はないかなぁ...)</p>
<p>サンプル走行！みんな大好きスクリーンショット。</p>
<pre><code>$ showip www.example.net
IP addresses for www.example.net:

  IPv4: 192.0.2.88

$ showip ipv6.example.com
IP addresses for ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171
</code></pre>
<p>これで、<code>getaddrinfo()</code> の結果を他のソケット関数に渡して、ついにネットワーク接続を確立することができます。引き続きお読みください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="52-socket---ファイルディスクリプターを取得しよう"><a class="header" href="#52-socket---ファイルディスクリプターを取得しよう">5.2 <code>socket()</code>---ファイルディスクリプターを取得しよう！</a></h1>
<p>もう先延ばしにはできません。<code>socket()</code> システムコールの話をしなければならないのです。以下はその内訳です。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
</code></pre>
<p>しかし、これらの引数は何なのでしょうか？これらは、どのようなソケットが欲しいか（IPv4 か IPv6 か、ストリームかデータグラムか、TCP か UDP か）を指定することができます。</p>
<p>以前は、これらの値をハードコードする人がいましたが、今でも絶対にそうすることができます。(ドメインは <code>PF_INET</code> または <code>PF_INET6</code>、タイプは <code>SOCK_STREAM</code> または <code>SOCK_DGRAM</code>、プロトコルは <code>0</code> に設定すると、与えられたタイプに適したプロトコルを選択することができます。あるいは <code>getprotobyname()</code> を呼んで、&quot;tcp&quot; や &quot;udp&quot; などの欲しいプロトコルを調べることもできます。)</p>
<p>（この <code>PF_INET</code> は、<code>struct sockaddr_in</code> の <code>sin_family</code> フィールドを初期化するときに使用できる <code>AF_INET</code> の近縁種です。実際、両者は非常に密接な関係にあり、実際に同じ値を持っているので、多くのプログラマは <code>socket()</code> を呼び出して <code>PF_INET</code> の代わりに <code>AF_INET</code> を第一引数に渡しています。さて、ミルクとクッキーを用意して、お話の時間です。昔々、あるアドレスファミリ（<code>AF_INET</code> の AF）が、プロトコルファミリ（<code>PF_INET</code> の PF）で参照される複数のプロトコルをサポートするかもしれないと考えられたことがあります。しかし、そうはなりませんでした。そして、みんな幸せに暮らした、ザ・エンド。というわけで、最も正しいのは <code>struct sockaddr_in</code> で <code>AF_INET</code> を使い、<code>socket()</code> の呼び出しで <code>PF_INET</code> を使うことです。）</p>
<p>とにかく、もう十分です。本当にやりたいことは、<code>getaddrinfo()</code> の呼び出しの結果の値を使い、以下のように直接 <code>socket()</code> に送り込むことです。</p>
<pre><code class="language-c">int s;
struct addrinfo hints, *res;

// do the lookup
// [pretend we already filled out the &quot;hints&quot; struct]
getaddrinfo(&quot;www.example.com&quot;, &quot;http&quot;, &amp;hints, &amp;res);

// again, you should do error-checking on getaddrinfo(), and walk
// the &quot;res&quot; linked list looking for valid entries instead of just
// assuming the first one is good (like many of these examples do).
// See the section on client/server for real examples.

s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
</code></pre>
<p><code>socket()</code> は単に、後のシステムコールで使用できるソケットディスクリプタを返すか、エラーの場合は <code>-1</code> を返します。グローバル変数 <code>errno</code> にはエラーの値が設定されます（詳細については <a href="system-calls-or-bust/socket-get-the-file-descriptor.html#errnoman"><code>errno</code></a> のマニュアルページを参照してください。また、マルチスレッドプログラムで <code>errno</code> を使用する際の簡単な注意も参照してください。）</p>
<p>でも、このソケットは何の役に立つのでしょうか？答えは、これだけでは本当に意味がなく、もっと読み進めてシステムコールを作らないと意味がないのです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="53-bind---私はどのポートにいるのでしょうか"><a class="header" href="#53-bind---私はどのポートにいるのでしょうか">5.3 <code>bind()</code>---私はどのポートにいるのでしょうか？</a></h1>
<p>ソケットを取得したら、そのソケットをローカルマシンのポートに関連付ける必要があるかもしれません。（これは、特定のポートへの接続を <code>listen()</code> する場合によく行われます。多人数参加型ネットワークゲームで &quot;192.168.5.10 ポート 3490 に接続&quot; と指示されたときに行います。）ポート番号はカーネルが受信パケットを特定のプロセスのソケットディスクリプタにマッチさせるために使用されます。もしあなたが <code>connect()</code> を行うだけなら（あなたはクライアントであり、サーバではないので）、これはおそらく不要でしょう。とにかく読んでみてください。</p>
<p><code>bind()</code> システムコールの概要は以下のとおりです。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
</code></pre>
<p><code>sockfd</code> は <code>socket()</code> が返すソケットファイル記述子です。<code>my_addr</code> は自分のアドレスに関する情報、すなわちポートおよび IP アドレスを含む <code>sockaddr</code> 構造体へのポインタです。</p>
<p>ふぅー。一度に吸収するのはちょっと無理があるな。ソケットをプログラムが実行されているホスト、ポート 3490 にバインドする例を見てみましょう。</p>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<p><code>AI_PASSIVE</code> フラグを使うことで、プログラムが動作しているホストの IP にバインドするように指示しているのです。もし、特定のローカル IP アドレスにバインドしたい場合は、<code>AI_PASSIVE</code> を削除して、<code>getaddrinfo()</code> の最初の引数に IP アドレスを入れてください。</p>
<p><code>bind()</code> もエラー時には <code>-1</code> を返し、<code>errno</code> にエラーの値を設定します。</p>
<p>多くの古いコードでは、<code>bind()</code> を呼び出す前に、<code>struct sockaddr_in</code> を手動でパックしています。これは明らかに IPv4 特有のものですが、IPv6 で同じことをするのを止めるものは何もありません。ただし、一般的には <code>getaddrinfo()</code> を使う方が簡単になりそうです。とにかく、古いコードは次のようなものです。</p>
<pre><code class="language-c">// !!! THIS IS THE OLD WAY !!!

int sockfd;
struct sockaddr_in my_addr;

sockfd = socket(PF_INET, SOCK_STREAM, 0);

my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(MYPORT);     // short, network byte order
my_addr.sin_addr.s_addr = inet_addr(&quot;10.12.110.57&quot;);
memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);

bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof my_addr);
</code></pre>
<p>上記のコードでは、ローカルの IP アドレスにバインドしたい場合、<code>s_addr</code> フィールドに <code>INADDR_ANY</code> を代入することもできます（上記の <code>AI_PASSIVE</code> フラグのようなものです）。<code>INADDR_ANY</code> の IPv6 バージョンはグローバル変数 <code>in6addr_any</code> で、<code>struct sockaddr_in6</code> の <code>sin6_addr</code> フィールドに代入されます。(変数の初期化で使用できるマクロ <code>IN6ADDR_ANY_INIT</code> も存在します。)また、<code>IN6ADDR_ANY_INIT</code> を使用することで、IPv6 の IP アドレスにバインドできます。</p>
<p><code>bind()</code> を呼ぶときにもうひとつ気をつけなければならないのは、ポート番号で下手を打たないことです。1024 以下のポートはすべて予約済みです（あなたがスーパーユーザでない限り）！それ以上のポート番号は、（他のプログラムによってすでに使われていなければ） 65535 までの任意のポート番号を使用することができます。</p>
<p>時々、サーバを再実行しようとすると、<code>bind()</code> が &quot;Address already in use&quot; と言って失敗することに気がつくかもしれません。これはどういうことでしょう？それは、接続されたソケットの一部がまだカーネル内に残っていて、ポートを占有しているのです。それが消えるのを待つか（1分くらい）、次のようにポートが再利用できるようなコードをプログラムに追加します。</p>
<pre><code class="language-c">int yes=1;
//char yes='1'; // Solaris people use this

// lose the pesky &quot;Address already in use&quot; error message
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof yes) == -1) {
    perror(&quot;setsockopt&quot;);
    exit(1);
}
</code></pre>
<p><code>bind()</code> について、最後にちょっとした注意点があります。<code>bind()</code> を絶対に呼び出す必要がない場合があります。リモートマシンに <code>connect()</code> する際に、ローカルポートを気にしない場合（telnet のようにリモートポートを気にする場合）は、単に <code>connect()</code> をコールすれば、ソケットが未束縛かどうかをチェックし、必要なら未使用のローカルポートに <code>bind()</code> してくれます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="54-connect---やあこんにちは"><a class="header" href="#54-connect---やあこんにちは">5.4 <code>connect()</code>---やあ、こんにちは！</a></h1>
<p>ちょっとだけ、あなたが telnet アプリケーションであることを仮定してみましょう。ユーザが（映画 TRON のように）ソケットファイル記述子を取得するように命令します。あなたはそれに応じ、<code>socket()</code> を呼び出します。次に、ユーザはポート &quot;<code>23</code>&quot;（標準的な telnet ポート）で &quot;<code>10.12.110.57</code>&quot; に接続するように指示します。やったー！どうするんだ？</p>
<p>幸運なことに、あなたは今、<code>connect()</code> の章---リモートホストに接続する方法を読んでいるところです。だから、猛烈に読み進めよう！時間がない！</p>
<p><code>connect()</code> の呼び出しは以下の通りです。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
</code></pre>
<p><code>sockfd</code> は <code>socket()</code> コールで返される、我々の身近なソケットファイル記述子、<code>serv_addr</code> は宛先ポートと IP アドレスを含む <code>struct sockaddr</code>、<code>addrlen</code> はサーバアドレス構造体のバイト長です。</p>
<p>これらの情報はすべて、<code>getaddrinfo()</code> の呼び出しの結果から得ることができ、これはロックします。</p>
<p>だんだん分かってきたかな？ここからは聞こえないので、そうであることを祈るしかないですね。ポート <code>3490</code> の &quot;<code>www.example.com</code>&quot; にソケット接続する例を見てみましょう。</p>
<pre><code class="language-c">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo(&quot;www.example.com&quot;, &quot;3490&quot;, &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// connect!

connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
</code></pre>
<p>繰り返しになりますが、古いタイプのプログラムでは、独自の <code>struct sockaddr_ins</code> を作成して <code>connect()</code> に渡していました。必要であれば、そうすることができます。上の <a href="system-calls-or-bust/docs/system-calls-or-bust/#bind"><code>bind()</code></a> の節で同様のことを書いています。</p>
<p><code>connect()</code> の戻り値を必ず確認してください。エラー時に <code>-1</code> が返され、<code>errno</code> という変数がセットされます。</p>
<p>また、<code>bind()</code> を呼んでいないことに注意してください。基本的に、私たちはローカルのポート番号には関心がありません。カーネルは私たちのためにローカルポートを選択し、接続先のサイトは自動的にこの情報を取得します。心配はいりません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="55-listen---誰か電話してくれない"><a class="header" href="#55-listen---誰か電話してくれない">5.5 <code>listen()</code>---誰か電話してくれない？</a></h1>
<p>よし、気分転換の時間です。リモートホストに接続したくない場合はどうすればいいのでしょう。例えば、接続が来るのを待ち、何らかの方法でそれを処理したいとします。この処理は2段階です。まず <code>listen()</code> を行い、次に <code>accept()</code> を行います (後述)。</p>
<p><code>listen()</code> の呼び出しはかなり単純ですが、少し説明が必要です。</p>
<pre><code class="language-c">int listen(int sockfd, int backlog);
</code></pre>
<p><code>sockfd</code> は <code>socket()</code> システムコールから得られる通常のソケットファイル記述子です。これはどういう意味でしょうか？着信した接続は、<code>accept()</code> (後述) するまでこのキューで待機することになりますが、このキューに入れることができる数の上限を表しているのです。ほとんどのシステムでは、この数を黙って約 20 に制限しています。おそらく、<code>5</code> や <code>10</code> に設定しても大丈夫でしょう。</p>
<p>ここでも、いつものように <code>listen()</code> はエラー時に <code>-1</code> を返し、<code>errno</code> をセットします。</p>
<p>さて、想像がつくと思いますが、サーバが特定のポートで動作するように <code>listen()</code> を呼び出す前に <code>bind()</code> を呼び出す必要があります。(どのポートに接続するかを仲間に伝えることができなければなりません！) ですから、もし接続を待ち受けるのであれば、一連のシステムコールは次のようになります。</p>
<pre><code class="language-c">getaddrinfo();
socket();
bind();
listen();
/* accept() goes here */
</code></pre>
<p>かなり自明なので、サンプルコードの代わりに置いておきます。（以下の <code>accept()</code> 章のコードはより完全なものです。）この全体の中で本当に厄介なのは、<code>accept()</code> の呼び出しです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="56-accept---3490番ポートにコールいただきありがとうございます"><a class="header" href="#56-accept---3490番ポートにコールいただきありがとうございます">5.6 <code>accept()</code>---&quot;3490番ポートにコールいただきありがとうございます。&quot;</a></h1>
<p><code>accept()</code> の呼び出しはちょっと変です。これから起こることはこうです。遠く離れた誰かが、あなたが <code>listen()</code> しているポートであなたのマシンに <code>connect()</code> しようとするでしょう。その接続は、<code>accept()</code> されるのを待つためにキューに入れられることになります。あなたは <code>accept()</code> をコールし、保留中の接続を取得するように指示します。すると、この接続に使用する新しいソケットファイル記述子が返されます！そうです、1つの値段で2つのソケットファイル記述子を手に入れたことになります。元のソケットファイル記述子はまだ新しい接続を待ち続けており、新しく作成されたソケットファイル記述子はようやく <code>send()</code> と <code>recv()</code> を行う準備が整いました。着いたぞ！</p>
<p>コールは以下の通りです。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>
<p><code>sockfd</code> は <code>listen()</code> するソケットディスクリプタです。<code>addr</code> は通常、ローカルの<code>struct sockaddr_storage</code> へのポインタになります。この構造体には、着信接続に関する情報が格納されます（これにより、どのホストがどのポートから電話をかけてきたかを判断することができます。）<code>addrlen</code> はローカルの整数型変数で、そのアドレスが <code>accept()</code> に渡される前に <code>sizeof(struct sockaddr_storage)</code> に設定されなければなりません。<code>accept()</code> は、<code>addr</code> にそれ以上のバイト数を入れることはありません。もし、それ以下のバイト数であれば、<code>addrlen</code> の値を変更します。</p>
<p>何だと思いますか？<code>accept()</code> はエラーが発生した場合は <code>-1</code> を返し、<code>errno</code> をセットします。そうだったんですか。</p>
<p>前回と同様、一度に吸収するのは大変なので、サンプルコードの一部をご覧ください。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

#define MYPORT &quot;3490&quot;  // the port users will be connecting to
#define BACKLOG 10     // how many pending connections queue will hold

int main(void)
{
    struct sockaddr_storage their_addr;
    socklen_t addr_size;
    struct addrinfo hints, *res;
    int sockfd, new_fd;

    // !! don't forget your error checking for these calls !!

    // first, load up address structs with getaddrinfo():

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

    getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

    // make a socket, bind it, and listen on it:

    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
    listen(sockfd, BACKLOG);

    // now accept an incoming connection:

    addr_size = sizeof their_addr;
    new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

    // ready to communicate on socket descriptor new_fd!
    .
    .
    .
</code></pre>
<p>ここでも、すべての <code>send()</code> と <code>recv()</code> の呼び出しに、ソケットディスクリプタ <code>new_fd</code> を使用することに注意してください。もし、一度しか接続がないのであれば、同じポートからの接続を防ぐために、<code>listen</code> している <code>sockfd</code> を <code>close()</code> することができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="57-send-and-recv---話せよベイビー"><a class="header" href="#57-send-and-recv---話せよベイビー">5.7 <code>send()</code> and <code>recv()</code>---話せよ、ベイビー！</a></h1>
<p>この2つの関数は、ストリームソケットまたは接続されたデータグラムソケットで通信を行うためのものです。通常の非接続型データグラムソケットを使いたい場合は、以下の <a href="system-calls-or-bust/docs/system-calls-or-bust/#sendtorecv"><code>sendto()</code> and <code>recvfrom()</code></a> の節を参照する必要があります。</p>
<p><code>send()</code> 呼び出し。</p>
<pre><code class="language-c">int send(int sockfd, const void *msg, int len, int flags);
</code></pre>
<p><code>sockfd</code> はデータを送信したいソケットディスクリプタ（<code>socket()</code> で返されたものでも <code>accept()</code> で取得したものでも可）、<code>msg</code> は送信したいデータへのポインタ、<code>len</code> はそのデータの長さ(バイト数)です。<code>flags</code> を <code>0</code> に設定するだけです(フラグに関する詳しい情報は <code>send()</code> の man ページを参照してください)。</p>
<p>サンプルコードとしては、以下のようなものがあります。</p>
<pre><code class="language-c">char *msg = &quot;Beej was here!&quot;;
int len, bytes_sent;
.
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
.
</code></pre>
<p><code>send()</code> は実際に送信されたバイト数を返しますが、これは送信するように指示した数よりも少ないかもしれません！つまり、大量のデータを送信するように指示しても、それが処理しきれないことがあるのです。その場合、できる限りのデータを送信し、残りは後で送信するように指示します。<code>send()</code> が返す値が <code>len</code> の値と一致しない場合、残りの文字列を送信するかどうかはあなた次第だということを覚えておいてください。良いニュースはこれです。パケットが小さければ（1K以下とか）、 おそらく全部を一度に送信することができるでしょう。ここでも、エラー時には <code>-1</code> が返され、 <code>errno</code> にはエラー番号がセットされます。</p>
<p><code>recv()</code> 呼び出しは、多くの点で類似しています。</p>
<pre><code class="language-c">int recv(int sockfd, void *buf, int len, int flags);
</code></pre>
<p><code>sockfd</code> は読み込むソケットディスクリプタ、<code>buf</code> は情報を読み込むバッファ、<code>len</code> はバッファの最大長、<code>flags</code> は再び <code>0</code> に設定できます(フラグについては <code>recv()</code> の man ページを参照してください)。</p>
<p><code>recv()</code> は、実際にバッファに読み込まれたバイト数を返し、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<p>待ってください！<code>recv()</code> は <code>0</code> を返すことがあります。これは、リモート側が接続を切断したことを意味します！<code>0</code> という返り値は、<code>recv()</code> がこのような事態が発生したことをあなたに知らせるためのものです。</p>
<p>ほら、簡単だったでしょう？これでストリームソケットでデータのやり取りができるようになったぞ。やったー！あなたは Unix ネットワークプログラマーです！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="58-sendto-and-recvfrom---dgram-スタイルで話して"><a class="header" href="#58-sendto-and-recvfrom---dgram-スタイルで話して">5.8 <code>sendto()</code> and <code>recvfrom()</code>---DGRAM スタイルで話して。</a></h1>
<p>&quot;これはすべて素晴らしく、ダンディーです&quot;、&quot;しかし、データグラムソケットを接続しないままにしておくのはどうなんだ？&quot;、という声が聞こえてきそうです。大丈夫だ、アミーゴ。ちょうどいいものがありますよ。</p>
<p>データグラムソケットはリモートホストに接続されていないので、パケットを送信する前にどのような情報を与える必要があるか分かりますか？そうです！宛先アドレスです！これがそのスコープです。</p>
<pre><code class="language-c">int sendto(int sockfd, const void *msg, int len, unsigned int flags,
           const struct sockaddr *to, socklen_t tolen);
</code></pre>
<p>見ての通り、この呼び出しは基本的に <code>send()</code> の呼び出しと同じで、他に2つの情報が追加されています。<code>to</code> は <code>struct sockaddr</code> へのポインタで（おそらく直前にキャストした別の <code>struct sockaddr_in</code> や <code>struct sockaddr_in6</code>、<code>struct sockaddr_storage</code> になるでしょう）、送信先の IP アドレスとポートが含まれています。<code>tolen</code> は <code>int</code> 型ですが、単純に <code>sizeof *to</code> または <code>sizeof(struct sockaddr_storage)</code> に設定することができます。</p>
<p>宛先アドレスの構造体を手に入れるには、<code>getaddrinfo()</code> や以下の <code>recvfrom()</code> から取得するか、手で記入することになると思います。</p>
<p><code>send()</code> と同様、<code>sendto()</code> は実際に送信したバイト数 (これも、送信するように指示したバイト数よりも少ないかもしれません！) を返し、エラーの場合は <code>-1</code> を返します。</p>
<p>同様に、<code>recv()</code> と <code>recvfrom()</code> も類似しています。<code>recvfrom()</code> の概要は以下の通りです。</p>
<pre><code class="language-c">int recvfrom(int sockfd, void *buf, int len, unsigned int flags,
             struct sockaddr *from, int *fromlen);
</code></pre>
<p>これも <code>recv()</code> と同様であるが、いくつかのフィールドが追加されています。<code>from</code> はローカルの <code>struct sockaddr_storage</code> へのポインタで、送信元のマシンの IP アドレスとポートが格納されます。<code>fromlen</code> はローカルの <code>int</code> へのポインタであり、<code>sizeof *from</code> または <code>sizeof(struct sockaddr_storage)</code> に初期化する必要があります。この関数が戻ったとき、<code>fromlen</code> は実際に <code>from</code> に格納されたアドレスの長さを含みます。</p>
<p><code>recvfrom()</code> は受信したバイト数を返し、エラーの場合は <code>-1</code> を返します（<code>errno</code> はそれに応じて設定されます）。</p>
<p>そこで質問ですが、なぜソケットの型として <code>struct sockaddr_storage</code> を使うのでしょうか？なぜ、<code>struct sockaddr_in</code> ではないのでしょうか？なぜなら、私たちは IPv4 や IPv6 に縛られたくないからです。そこで、汎用的な構造体である <code>sockaddr_storage</code> を使用するのですが、これはどちらにも十分な大きさであることが分かっています。</p>
<p>（そこで...ここでまた疑問なのですが、なぜ <code>struct sockaddr</code> 自体はどんなアドレスに対しても十分な大きさがないのでしょうか？汎用 <code>struct sockaddr_storage</code> を汎用 <code>struct sockaddr</code> にキャストしているくらいなのに！？余計なことをしたような気がしますね。答えは、十分な大きさがなく、この時点で変更するのは問題がある、ということでしょう。だから新しいのを作ったんだ。）</p>
<p>データグラムソケットを <code>connect()</code> すれば、すべてのトランザクションに <code>send()</code> と <code>recv()</code> を使用できることを覚えておいてください。ソケット自体はデータグラムソケットであり、パケットは UDP を使用しますが、ソケットインターフェイスが自動的に宛先と送信元の情報を追加してくれるのです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="59-close-and-shutdown---私の前から失せな"><a class="header" href="#59-close-and-shutdown---私の前から失せな">5.9 <code>close()</code> and <code>shutdown()</code>---私の前から失せな！</a></h1>
<p>ふぅー、一日中データの送受信（<code>send()</code>ing と <code>recv()</code>ing）をしていて、もう限界です。ソケットディスクリプタの接続を閉じる準備ができました。これは簡単です。通常の Unix ファイルディスクリプタの <code>close()</code> 関数を使えばいいのです。</p>
<pre><code class="language-c">close(sockfd);
</code></pre>
<p>これにより、それ以上のソケットへの読み書きができなくなります。リモート側でソケットの読み書きをしようとすると、エラーが発生します。</p>
<p>ソケットの閉じ方をもう少し制御したい場合は、<code>shutdown()</code> 関数を使用します。この関数では、特定の方向、あるいは両方の通信を遮断することができます (ちょうど <code>close()</code> がそうであるように)。概要:</p>
<pre><code class="language-c">int shutdown(int sockfd, int how);
</code></pre>
<p><code>sockfd</code> はシャットダウンしたいソケットファイル記述子、<code>how</code> は以下のいずれかです。</p>
<table><thead><tr><th style="text-align: center"><code>how</code></th><th>Effect</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>0</code></td><td>それ以上の受信は不可</td></tr>
<tr><td style="text-align: center"><code>1</code></td><td>それ以上の送信は禁止</td></tr>
<tr><td style="text-align: center"><code>2</code></td><td>それ以上の送受信は禁止(<code>close()</code>のように)</td></tr>
</tbody></table>
<p><code>shutdown()</code> は成功すると <code>0</code> を、エラーが発生すると <code>-1</code> を返します（<code>errno</code> は適宜設定されます）。</p>
<p>データグラムソケットが接続されていない状態で <code>shutdown()</code> を使用すると、それ以降の <code>send()</code> および <code>recv()</code> 呼び出しに使用できなくなります（データグラムソケットを <code>connect()</code> した場合、これらを使用できることを忘れないでください）。</p>
<p><code>shutdown()</code> は実際にはファイルディスクリプタを閉じないことに注意することが重要です。ソケットディスクリプタを解放するには、<code>close()</code> を使用する必要があります。</p>
<p>何もないんだけどね。</p>
<p>（ただし、Windows と Winsock を使用している場合は、<code>close()</code> ではなく <code>closesocket()</code> を呼び出すべきであることを忘れないでください。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="510-getpeername---あなたは誰ですか"><a class="header" href="#510-getpeername---あなたは誰ですか">5.10 <code>getpeername()</code>---あなたは誰ですか？</a></h1>
<p>この関数はとても簡単です。</p>
<p>あまりに簡単なので、ほとんど独自のセクションを設けなかったほどです。でも、とりあえずここに書いておきます。</p>
<p><code>getpeername()</code> 関数は、接続されたストリームソケットのもう一方の端にいるのが誰であるかを教えてくれます。その概要は</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);
</code></pre>
<p><code>sockfd</code> は接続したストリームソケットのディスクリプタ、<code>addr</code> は接続の相手側の情報を保持する <code>struct sockaddr</code>（または <code>struct sockaddr_in</code>）へのポインタ、<code>addrlen</code> は <code>int</code> へのポインタであり、 <code>sizeof *addr</code> または <code>sizeof(struct sockaddr)</code> で初期化される必要があります。</p>
<p>この関数は，エラーが発生すると <code>-1</code> を返し，それに応じて <code>errno</code> を設定します。</p>
<p>アドレスがわかれば、<code>inet_ntop()</code>、<code>getnameinfo()</code>、<code>gethostbyaddr()</code> を使って、より詳しい情報を表示したり取得したりすることができます。いいえ、ログイン名を取得することはできません。（OK、OK。相手のコンピュータで ident デーモンが動いていれば、可能です。しかし、これはこのドキュメントの範囲外です。詳しくは <a href="https://datatracker.ietf.org/doc/html/rfc1413">RFC 1413</a> をチェックしてください。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="511-gethostname---私は誰なのか"><a class="header" href="#511-gethostname---私は誰なのか">5.11 <code>gethostname()</code>---私は誰なのか？</a></h1>
<p><code>getpeername()</code> よりもさらに簡単なのは、<code>gethostname()</code> という関数です。これは、あなたのプログラムが動作しているコンピュータの名前を返します。この名前は、後述の <code>gethostbyname()</code> でローカルマシンの IP アドレスを決定するために使用されます。</p>
<p>これ以上楽しいことはないでしょう？いくつか思いつきましたが、ソケットプログラミングには関係ないですね。とにかく、内訳はこんな感じです。</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int gethostname(char *hostname, size_t size);
</code></pre>
<p>引数は単純で、<code>hostname</code> はこの関数が戻ったときにホスト名を格納する文字列の配列へのポインタ、<code>size</code> はホスト名配列のバイト長です。</p>
<p>この関数は，正常に終了した場合は <code>0</code> を，エラーの場合は <code>-1</code> を返し，通常通り <code>errno</code> を設定します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-クライアント-サーバの背景"><a class="header" href="#6-クライアント-サーバの背景">6 クライアント-サーバの背景</a></h1>
<p>クライアント-サーバの世界なのです。ネットワーク上のあらゆることが、クライアント・プロセスとサーバ・プロセスとの対話、またはその逆を扱っています。たとえば、<code>telnet</code> を考えてみよう。ポート 23 のリモートホストに <code>telnet</code> で接続すると（クライアント）、そのホスト上のプログラム（telnetd と呼ばれるサーバ）が起動します。このプログラムは、送られてきた <code>telnet</code> 接続を処理し、ログインプロンプトを表示するなどの設定を行います。</p>
<figure>
  <img
  src="images/cs.svg"
  alt="[Client-Server Interaction Diagram]">
  <figcaption>クライアント-サーバの相互作用</figcaption>
</figure>
<p>クライアントとサーバ間の情報のやりとりは、上の図のようにまとめられます。</p>
<p>クライアントとサーバのペアは、<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、その他（同じことを話している限り）何でも話すことができることに注意してください。クライアントとサーバのペアの良い例としては、<code>telnet</code>/<code>telnetd</code>、<code>ftp</code>/<code>ftpd</code>、<code>Firefox</code>/<code>Apache</code> などがあります。<code>ftp</code> を使うときはいつも、リモートプログラム <code>ftpd</code> があなたにサービスを提供します。</p>
<p>多くの場合、1つのマシンには1つのサーバしかなく、そのサーバは <code>fork()</code> を使用して複数のクライアントを処理します。基本的なルーチンは、サーバが接続を待ち、それを <code>accept()</code> し、それを処理するために子プロセスを <code>fork()</code> する、というものです。これが、次の節で紹介するサンプルサーバが行っていることです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="61-シンプルなストリームサーバ"><a class="header" href="#61-シンプルなストリームサーバ">6.1 シンプルなストリームサーバ</a></h1>
<p>このサーバがすることは、ストリーム接続で <code>Hello, world!</code> という文字列を送り出すだけです。このサーバをテストするために必要なことは、あるウィンドウでこのサーバを実行し、別のウィンドウからこのサーバに telnet でアクセスすることだけです。</p>
<pre><code>$ telnet remotehostname 3490
</code></pre>
<p>ここで、<code>remotehostname</code> は実行するマシンの名前です。</p>
<p><a href="https://beej.us/guide/bgnet/examples/server.c">サーバコード</a></p>
<pre><code class="language-c">/*
** server.c -- a stream socket server demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define PORT &quot;3490&quot;  // the port users will be connecting to

#define BACKLOG 10   // how many pending connections queue will hold

void sigchld_handler(int s)
{
    // waitpid() might overwrite errno, so we save and restore it:
    int saved_errno = errno;

    while(waitpid(-1, NULL, WNOHANG) &gt; 0);

    errno = saved_errno;
}


// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct addrinfo hints, *servinfo, *p;
    struct sockaddr_storage their_addr; // connector's address information
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;
    char s[INET6_ADDRSTRLEN];
    int rv;

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
        return 1;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror(&quot;server: socket&quot;);
            continue;
        }

        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                sizeof(int)) == -1) {
            perror(&quot;setsockopt&quot;);
            exit(1);
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror(&quot;server: bind&quot;);
            continue;
        }

        break;
    }

    freeaddrinfo(servinfo); // all done with this structure

    if (p == NULL)  {
        fprintf(stderr, &quot;server: failed to bind\n&quot;);
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror(&quot;listen&quot;);
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
        perror(&quot;sigaction&quot;);
        exit(1);
    }

    printf(&quot;server: waiting for connections...\n&quot;);

    while(1) {  // main accept() loop
        sin_size = sizeof their_addr;
        new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
        if (new_fd == -1) {
            perror(&quot;accept&quot;);
            continue;
        }

        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s);
        printf(&quot;server: got connection from %s\n&quot;, s);

        if (!fork()) { // this is the child process
            close(sockfd); // child doesn't need the listener
            if (send(new_fd, &quot;Hello, world!&quot;, 13, 0) == -1)
                perror(&quot;send&quot;);
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
}
</code></pre>
<p>一応、構文的にわかりやすいように、1つの大きな <code>main()</code> 関数にまとめてあります。もし、その方が良いと思われるなら、自由に小さな関数に分割してください。</p>
<p>（また、この <code>sigaction()</code> 全体は、あなたにとって新しいものかもしれません---それは大丈夫です。このコードは、<code>fork()</code> された子プロセスが終了するときに現れるゾンビプロセスを刈り取る役割を担っているのです。ゾンビをたくさん作ってそれを刈り取らないと、システム管理者が怒りますよ。）</p>
<p>このサーバからデータを取得するには、次の節に記載されているクライアントを使用します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="62-シンプルなストリームクライアント"><a class="header" href="#62-シンプルなストリームクライアント">6.2 シンプルなストリームクライアント</a></h1>
<p>こいつはサーバよりもっと簡単です。このクライアントがすることはコマンドラインで指定したホスト、ポート 3490 に接続するだけです。サーバが送信する文字列を取得します。</p>
<p><a href="https://beej.us/guide/bgnet/examples/client.c">クライアントソース</a>。</p>
<pre><code class="language-c">/*
** client.c -- a stream socket client demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#define PORT &quot;3490&quot; // the port client will be connecting to

#define MAXDATASIZE 100 // max number of bytes we can get at once

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(int argc, char *argv[])
{
    int sockfd, numbytes;
    char buf[MAXDATASIZE];
    struct addrinfo hints, *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,&quot;usage: client hostname\n&quot;);
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(argv[1], PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
        return 1;
    }

    // loop through all the results and connect to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror(&quot;client: socket&quot;);
            continue;
        }

        if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror(&quot;client: connect&quot;);
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, &quot;client: failed to connect\n&quot;);
        return 2;
    }

    inet_ntop(p-&gt;ai_family, get_in_addr((struct sockaddr *)p-&gt;ai_addr),
            s, sizeof s);
    printf(&quot;client: connecting to %s\n&quot;, s);

    freeaddrinfo(servinfo); // all done with this structure

    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror(&quot;recv&quot;);
        exit(1);
    }

    buf[numbytes] = '\0';

    printf(&quot;client: received '%s'\n&quot;,buf);

    close(sockfd);

    return 0;
}
</code></pre>
<p>クライアントを実行する前にサーバを実行しない場合、<code>connect()</code> は &quot;Connection refused&quot; を返すことに注意してください。非常に便利です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="63-データグラムソケット"><a class="header" href="#63-データグラムソケット">6.3 データグラムソケット</a></h1>
<p>UDP データグラムソケットの基本は、上記の <a href="client-server-background/docs/system-calls-or-bust/#sendtorecv">5.8 sendto() and recvfrom()</a> ですでに説明しましたので、ここでは <code>talker.c</code> と <code>listener.c</code> という2つのサンプルプログラムのみを紹介します。</p>
<p><code>listener</code> は、ポート 4950 で入ってくるパケットを待つマシンに座っています。<code>talker</code> は、指定されたマシンのそのポートに、ユーザがコマンドラインに入力したものを含むパケットを送信します。</p>
<p>データグラムソケットはコネクションレス型であり、パケットを無慈悲に発射するだけなので、クライアントとサーバには IPv6 を使用するように指示することにしています。こうすることで、サーバが IPv6 でリッスンしていて、クライアントが IPv4 で送信するような状況を避けることができます。（接続された TCP ストリームソケットの世界では、まだ不一致があるかもしれませんが、一方のアドレスファミリーの <code>connect()</code> でエラーが発生すると、他方のアドレスファミリーの再試行が行われます。）</p>
<p><a href="https://beej.us/guide/bgnet/examples/listener.c">listener.c ソースコード</a></p>
<pre><code class="language-c">/*
** listener.c -- a datagram sockets &quot;server&quot; demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define MYPORT &quot;4950&quot;	// the port users will be connecting to

#define MAXBUFLEN 100

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
	if (sa-&gt;sa_family == AF_INET) {
		return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
	}

	return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
	int sockfd;
	struct addrinfo hints, *servinfo, *p;
	int rv;
	int numbytes;
	struct sockaddr_storage their_addr;
	char buf[MAXBUFLEN];
	socklen_t addr_len;
	char s[INET6_ADDRSTRLEN];

	memset(&amp;hints, 0, sizeof hints);
	hints.ai_family = AF_INET6; // set to AF_INET to use IPv4
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_PASSIVE; // use my IP

	if ((rv = getaddrinfo(NULL, MYPORT, &amp;hints, &amp;servinfo)) != 0) {
		fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
		return 1;
	}

	// loop through all the results and bind to the first we can
	for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
		if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
				p-&gt;ai_protocol)) == -1) {
			perror(&quot;listener: socket&quot;);
			continue;
		}

		if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
			close(sockfd);
			perror(&quot;listener: bind&quot;);
			continue;
		}

		break;
	}

	if (p == NULL) {
		fprintf(stderr, &quot;listener: failed to bind socket\n&quot;);
		return 2;
	}

	freeaddrinfo(servinfo);

	printf(&quot;listener: waiting to recvfrom...\n&quot;);

	addr_len = sizeof their_addr;
	if ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN-1 , 0,
		(struct sockaddr *)&amp;their_addr, &amp;addr_len)) == -1) {
		perror(&quot;recvfrom&quot;);
		exit(1);
	}

	printf(&quot;listener: got packet from %s\n&quot;,
		inet_ntop(their_addr.ss_family,
			get_in_addr((struct sockaddr *)&amp;their_addr),
			s, sizeof s));
	printf(&quot;listener: packet is %d bytes long\n&quot;, numbytes);
	buf[numbytes] = '\0';
	printf(&quot;listener: packet contains \&quot;%s\&quot;\n&quot;, buf);

	close(sockfd);

	return 0;
}
</code></pre>
<p><code>getaddrinfo()</code> の呼び出しで、最終的に <code>SOCK_DGRAM</code> を使用していることに注意してください。また、<code>listen()</code> や <code>accept()</code> は必要ないことに注意してください。これは非接続型データグラムソケットを使用する利点の1つです！</p>
<p><a href="https://beej.us/guide/bgnet/examples/talker.c">talker.c ソースコード</a></p>
<pre><code class="language-c">/*
** talker.c -- a datagram &quot;client&quot; demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT &quot;4950&quot;	// the port users will be connecting to

int main(int argc, char *argv[])
{
	int sockfd;
	struct addrinfo hints, *servinfo, *p;
	int rv;
	int numbytes;

	if (argc != 3) {
		fprintf(stderr,&quot;usage: talker hostname message\n&quot;);
		exit(1);
	}

	memset(&amp;hints, 0, sizeof hints);
	hints.ai_family = AF_INET6; // set to AF_INET to use IPv4
	hints.ai_socktype = SOCK_DGRAM;

	if ((rv = getaddrinfo(argv[1], SERVERPORT, &amp;hints, &amp;servinfo)) != 0) {
		fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(rv));
		return 1;
	}

	// loop through all the results and make a socket
	for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
		if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
				p-&gt;ai_protocol)) == -1) {
			perror(&quot;talker: socket&quot;);
			continue;
		}

		break;
	}

	if (p == NULL) {
		fprintf(stderr, &quot;talker: failed to create socket\n&quot;);
		return 2;
	}

	if ((numbytes = sendto(sockfd, argv[2], strlen(argv[2]), 0,
			 p-&gt;ai_addr, p-&gt;ai_addrlen)) == -1) {
		perror(&quot;talker: sendto&quot;);
		exit(1);
	}

	freeaddrinfo(servinfo);

	printf(&quot;talker: sent %d bytes to %s\n&quot;, numbytes, argv[1]);
	close(sockfd);

	return 0;
}
</code></pre>
<p>と、これだけです！<code>listener</code> をあるマシンで実行し、次に <code>takler</code> を別のマシンで実行します。それらのコミュニケーションをご覧ください！核家族で楽しめるG級興奮体験です！</p>
<p>今回はサーバを動かす必要もありません。<code>talker</code> はただ楽しくパケットをエーテルに発射し、相手側に <code>recvfrom()</code> の準備が出来ていなければ消えてしまうのです。UDP データグラムソケットを使用して送信されたデータは、到着が保証されていないことを思い出してください！</p>
<p>過去に何度も述べた、もうひとつの小さなディテールを除いては、コネクテッド・データグラム・ソケットです。このドキュメントのデータグラムセクションにいるので、ここでこれについて話す必要があります。例えば、<code>talker</code> が <code>connect()</code> を呼び出して <code>listener</code> のアドレスを指定したとします。それ以降、<code>talker</code> は <code>connect()</code> で指定されたアドレスにのみ送信と受信ができます。このため、<code>sendto()</code> と <code>recvfrom()</code> を使う必要はなく、単に <code>send()</code> と <code>recv()</code> を使えばいいのです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/theme-solarized_dark.js"></script>
        <script type="text/javascript" src="theme/theme-solarized_light.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
