<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="6 Client-Server Background #  クライアント-サーバの世界なのです。ネットワーク上のあらゆることが、クライアント・プロセスとサーバ・プロセスとの対話、またはその逆を扱っています。たとえば、telnet を考えてみよう。ポート 23 のリモートホストに telnet で接続すると（クライアント）、そのホスト上のプログラム（telnetd と呼ばれるサーバ）が起動します。このプログラムは、送られてきた telnet 接続を処理し、ログインプロンプトを表示するなどの設定を行います。
 クライアント-サーバの相互作用  クライアントとサーバ間の情報のやりとりは、上の図のようにまとめられます。
クライアントとサーバのペアは、SOCK_STREAM、SOCK_DGRAM、その他（同じことを話している限り）何でも話すことができることに注意してください。クライアントとサーバのペアの良い例としては、telnet/telnetd、ftp/ftpd、Firefox/Apache などがあります。ftp を使うときはいつも、リモートプログラム ftpd があなたにサービスを提供します。
多くの場合、1つのマシンには1つのサーバしかなく、そのサーバは fork() を使用して複数のクライアントを処理します。基本的なルーチンは、サーバが接続を待ち、それを accept() し、それを処理するために子プロセスを fork() する、というものです。これが、次の節で紹介するサンプルサーバが行っていることです。
6.1 A Simple Stream Server #  このサーバがすることは、ストリーム接続で Hello, world! という文字列を送り出すだけです。このサーバをテストするために必要なことは、あるウィンドウでこのサーバを実行し、別のウィンドウからこのサーバに telnet でアクセスすることだけです。
$ telnet remotehostname 3490 ここで、remotehostname は実行するマシンの名前です。
 サーバコード
/* ** server.c -- a stream socket server demo */ #include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <errno.h>#include <string.h>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <netdb.">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content="6 Client-Server Background">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="https://solareenlo.com/bgnet/docs/client-server-background/">
<title>6 Client-Server Background | Beej's Guide to Network Programming</title>
<link rel=manifest href=/bgnet/manifest.json>
<link rel=icon href=/bgnet/favicon.png type=image/x-icon>
<link rel=stylesheet href=/bgnet/book.min.3fc729a37471ee87e40517478b6ab5936d22fcb6008d40985724e4295d1a74c0.css integrity="sha256-P8cpo3Rx7ofkBRdHi2q1k20i/LYAjUCYVyTkKV0adMA=" crossorigin=anonymous>
<script defer src=/bgnet/flexsearch.min.js></script>
<script defer src=/bgnet/en.search.min.8359b7a63bdb43c9177e9d067fc1524c325fcb61e9a3843ed2d7708e4cd5fdbe.js integrity="sha256-g1m3pjvbQ8kXfp0Gf8FSTDJfy2Hpo4Q+0tdwjkzV/b4=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=https://solareenlo.com/bgnet/docs/client-server-background/index.xml title="Beej's Guide to Network Programming">
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/bgnet/><span>Beej's Guide to Network Programming</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li>
<a href=/bgnet/docs/intro><strong>1</strong> Intro</a>
<ul>
<li>
<a href=/bgnet/docs/intro/#11-audience><strong>1.1</strong> Audience</a></li>
<li>
<a href=/bgnet/docs/intro/#12-platform-and-compiler><strong>1.2</strong> Platform and Compiler</a></li>
<li>
<a href=/bgnet/docs/intro/#13-official-homepage-and-books-for-sale><strong>1.3</strong> Official Homepage and Books For Sale</a></li>
<li>
<a href=/bgnet/docs/intro/#solaris><strong>1.4</strong> Note for Solaris/SunOS Programmers</a></li>
<li>
<a href=/bgnet/docs/intro/#windows><strong>1.5</strong> Note for Windows Programmers</a></li>
<li>
<a href=/bgnet/docs/intro/#16-email-policy><strong>1.6</strong> Email Policy</a></li>
<li>
<a href=/bgnet/docs/intro/#17-mirroring><strong>1.7</strong> Mirroring</a></li>
<li>
<a href=/bgnet/docs/intro/#18-note-for-translators><strong>1.8</strong> Note for Translators</a></li>
<li>
<a href=/bgnet/docs/intro/#legal><strong>1.9</strong> Copyright, Distribution, and Legal</a></li>
<li>
<a href=/bgnet/docs/intro/#110-dedication><strong>1.10</strong> Dedication</a></li>
<li>
<a href=/bgnet/docs/intro/#111-publishing-information><strong>1.11</strong> Publishing Information</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/what-is-a-socket><strong>2</strong> What is a socket?</a>
<ul>
<li>
<a href=/bgnet/docs/what-is-a-socket/#21-two-types-of-internet-sockets><strong>2.1</strong> Two Types of Internet Sockets</a></li>
<li>
<a href=/bgnet/docs/what-is-a-socket/#lowlevel><strong>2.2</strong> Low level Nonsense and Network Theory</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging><strong>3</strong> IP Addresses, structs, and Data Munging</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#31-ip-addresses-versions-4-and-6><strong>3.1</strong> IP Addresses, versions 4 and 6</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#311-subnets><strong>3.1.1</strong> Subnets</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#312-port-numbers><strong>3.1.2</strong> Port Numbers</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#32-byte-order><strong>3.2</strong> Byte Order</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#structs><strong>3.3</strong> structs</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#34-ip-addresses-part-deux><strong>3.4</strong> IP Addresses, Part Deux</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#341-private-or-disconnected-networks><strong>3.4.1</strong> Private (Or Disconnected) Networks</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=/bgnet/docs/jumping-from-ipv4-to-ipv6><strong>4</strong> Jumping from IPv4 to IPv6</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust><strong>5</strong> System Calls or Bust</a>
<ul>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#51-getaddrinfo---prepare-to-launch><strong>5.1</strong> getaddrinfo()—Prepare to launch!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#socket><strong>5.2</strong> socket()—Get the File Descriptor!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#bind><strong>5.3</strong> bind()—What port am I on?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#connect><strong>5.4</strong> connect()—Hey, you!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#listen><strong>5.5</strong> listen()—Will somebody please call me?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#56-accept---thank-you-for-calling-port-3490><strong>5.6</strong> accept()—“Thank you for calling port 3490.”</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#sendrecv><strong>5.7</strong> send() and recv()—Talk to me, baby!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#sendtorecv><strong>5.8</strong> sendto() and recvfrom()—Talk to me, DGRAM-style</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#59-close-and-shutdown---get-outta-my-face><strong>5.9</strong> close() and shutdown()—Get outta my face!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#510-getpeername---who-are-you><strong>5.10</strong> getpeername()—Who are you?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#511-gethostname---who-am-i><strong>5.11</strong> gethostname()—Who am I?</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/client-server-background><strong>6</strong> Client-Server Background</a>
<ul>
<li>
<a href=/bgnet/docs/client-server-background/#61-a-simple-stream-server><strong>6.1</strong> A Simple Stream Server</a></li>
<li>
<a href=/bgnet/docs/client-server-background/#62-a-simple-stream-client><strong>6.2</strong> A Simple Stream Client</a></li>
<li>
<a href=/bgnet/docs/client-server-background/#datagram><strong>6.3</strong> Datagram Sockets</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques><strong>7</strong> Slightly Advanced Techniques</a>
<ul>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#blocking><strong>7.1</strong> Blocking</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#poll><strong>7.2</strong> poll()—Synchronous I/O Multiplexing</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#select><strong>7.3</strong> select()—Synchronous I/O Multiplexing, Old School</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#sendall><strong>7.4</strong> Handling Partial <code>send()</code>s</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#serialization><strong>7.5</strong> Serialization&mdash;How to Pack Data</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#sonofdataencap><strong>7.6</strong> Son of Data Encapsulation</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#77-broadcast-packets---hello-world><strong>7.7</strong> Broadcast Packets&mdash;Hello, World!</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/common-questions><strong>8</strong> Common Questions</a>
<br></li>
</ul>
<ul>
<li>
<a href=https://github.com/solareenlo/bgnet target=_blank rel=noopener>
Github
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/bgnet/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>6 Client-Server Background</strong>
<label for=toc-control>
<img src=/bgnet/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#6-client-server-background>6 Client-Server Background</a>
<ul>
<li><a href=#61-a-simple-stream-server>6.1 A Simple Stream Server</a></li>
<li><a href=#62-a-simple-stream-client>6.2 A Simple Stream Client</a></li>
<li><a href=#datagram>6.3 Datagram Sockets</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h1 id=6-client-server-background>
6 Client-Server Background
<a class=anchor href=#6-client-server-background>#</a>
</h1>
<p>クライアント-サーバの世界なのです。ネットワーク上のあらゆることが、クライアント・プロセスとサーバ・プロセスとの対話、またはその逆を扱っています。たとえば、<code>telnet</code> を考えてみよう。ポート 23 のリモートホストに <code>telnet</code> で接続すると（クライアント）、そのホスト上のプログラム（telnetd と呼ばれるサーバ）が起動します。このプログラムは、送られてきた <code>telnet</code> 接続を処理し、ログインプロンプトを表示するなどの設定を行います。</p>
<figure>
<img src=/bgnet/images/cs.svg alt="[Client-Server Interaction Diagram]">
<figcaption>クライアント-サーバの相互作用</figcaption>
</figure>
<p>クライアントとサーバ間の情報のやりとりは、上の図のようにまとめられます。</p>
<p>クライアントとサーバのペアは、<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、その他（同じことを話している限り）何でも話すことができることに注意してください。クライアントとサーバのペアの良い例としては、<code>telnet</code>/<code>telnetd</code>、<code>ftp</code>/<code>ftpd</code>、<code>Firefox</code>/<code>Apache</code> などがあります。<code>ftp</code> を使うときはいつも、リモートプログラム <code>ftpd</code> があなたにサービスを提供します。</p>
<p>多くの場合、1つのマシンには1つのサーバしかなく、そのサーバは <code>fork()</code> を使用して複数のクライアントを処理します。基本的なルーチンは、サーバが接続を待ち、それを <code>accept()</code> し、それを処理するために子プロセスを <code>fork()</code> する、というものです。これが、次の節で紹介するサンプルサーバが行っていることです。</p>
<h2 id=61-a-simple-stream-server>
6.1 A Simple Stream Server
<a class=anchor href=#61-a-simple-stream-server>#</a>
</h2>
<p>このサーバがすることは、ストリーム接続で <code>Hello, world!</code> という文字列を送り出すだけです。このサーバをテストするために必要なことは、あるウィンドウでこのサーバを実行し、別のウィンドウからこのサーバに telnet でアクセスすることだけです。</p>
<pre tabindex=0><code>$ telnet remotehostname 3490
</code></pre><p>ここで、<code>remotehostname</code> は実行するマシンの名前です。</p>
<p>
<a href=https://beej.us/guide/bgnet/examples/server.c>サーバコード</a></p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#586e75>/*
</span><span style=color:#586e75>** server.c -- a stream socket server demo
</span><span style=color:#586e75>*/</span>

<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdlib.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;errno.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/socket.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netinet/in.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netdb.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;arpa/inet.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/wait.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;signal.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#define PORT &#34;3490&#34;  </span><span style=color:#586e75>// the port users will be connecting to
</span><span style=color:#586e75></span>
<span style=color:#719e07>#define BACKLOG 10   </span><span style=color:#586e75>// how many pending connections queue will hold
</span><span style=color:#586e75></span>
<span style=color:#dc322f>void</span> <span style=color:#268bd2>sigchld_handler</span>(<span style=color:#dc322f>int</span> s)
{
    <span style=color:#586e75>// waitpid() might overwrite errno, so we save and restore it:
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> saved_errno <span style=color:#719e07>=</span> errno;

    <span style=color:#719e07>while</span>(waitpid(<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>, <span style=color:#b58900>NULL</span>, WNOHANG) <span style=color:#719e07>&gt;</span> <span style=color:#2aa198>0</span>);

    errno <span style=color:#719e07>=</span> saved_errno;
}


<span style=color:#586e75>// get sockaddr, IPv4 or IPv6:
</span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>get_in_addr</span>(<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>sa)
{
    <span style=color:#719e07>if</span> (sa<span style=color:#719e07>-&gt;</span>sa_family <span style=color:#719e07>==</span> AF_INET) {
        <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin_addr);
    }

    <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in6<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin6_addr);
}

<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
    <span style=color:#dc322f>int</span> sockfd, new_fd;  <span style=color:#586e75>// listen on sock_fd, new connection on new_fd
</span><span style=color:#586e75></span>    <span style=color:#719e07>struct</span> addrinfo hints, <span style=color:#719e07>*</span>servinfo, <span style=color:#719e07>*</span>p;
    <span style=color:#719e07>struct</span> sockaddr_storage their_addr; <span style=color:#586e75>// connector&#39;s address information
</span><span style=color:#586e75></span>    socklen_t sin_size;
    <span style=color:#719e07>struct</span> sigaction sa;
    <span style=color:#dc322f>int</span> yes<span style=color:#719e07>=</span><span style=color:#2aa198>1</span>;
    <span style=color:#dc322f>char</span> s[INET6_ADDRSTRLEN];
    <span style=color:#dc322f>int</span> rv;

    memset(<span style=color:#719e07>&amp;</span>hints, <span style=color:#2aa198>0</span>, <span style=color:#719e07>sizeof</span> hints);
    hints.ai_family <span style=color:#719e07>=</span> AF_UNSPEC;
    hints.ai_socktype <span style=color:#719e07>=</span> SOCK_STREAM;
    hints.ai_flags <span style=color:#719e07>=</span> AI_PASSIVE; <span style=color:#586e75>// use my IP
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> ((rv <span style=color:#719e07>=</span> getaddrinfo(<span style=color:#b58900>NULL</span>, PORT, <span style=color:#719e07>&amp;</span>hints, <span style=color:#719e07>&amp;</span>servinfo)) <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span>) {
        fprintf(stderr, <span style=color:#2aa198>&#34;getaddrinfo: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, gai_strerror(rv));
        <span style=color:#719e07>return</span> <span style=color:#2aa198>1</span>;
    }

    <span style=color:#586e75>// loop through all the results and bind to the first we can
</span><span style=color:#586e75></span>    <span style=color:#719e07>for</span>(p <span style=color:#719e07>=</span> servinfo; p <span style=color:#719e07>!=</span> <span style=color:#b58900>NULL</span>; p <span style=color:#719e07>=</span> p<span style=color:#719e07>-&gt;</span>ai_next) {
        <span style=color:#719e07>if</span> ((sockfd <span style=color:#719e07>=</span> socket(p<span style=color:#719e07>-&gt;</span>ai_family, p<span style=color:#719e07>-&gt;</span>ai_socktype,
                p<span style=color:#719e07>-&gt;</span>ai_protocol)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
            perror(<span style=color:#2aa198>&#34;server: socket&#34;</span>);
            <span style=color:#719e07>continue</span>;
        }

        <span style=color:#719e07>if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, <span style=color:#719e07>&amp;</span>yes,
                <span style=color:#719e07>sizeof</span>(<span style=color:#dc322f>int</span>)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
            perror(<span style=color:#2aa198>&#34;setsockopt&#34;</span>);
            exit(<span style=color:#2aa198>1</span>);
        }

        <span style=color:#719e07>if</span> (bind(sockfd, p<span style=color:#719e07>-&gt;</span>ai_addr, p<span style=color:#719e07>-&gt;</span>ai_addrlen) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
            close(sockfd);
            perror(<span style=color:#2aa198>&#34;server: bind&#34;</span>);
            <span style=color:#719e07>continue</span>;
        }

        <span style=color:#719e07>break</span>;
    }

    freeaddrinfo(servinfo); <span style=color:#586e75>// all done with this structure
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> (p <span style=color:#719e07>==</span> <span style=color:#b58900>NULL</span>)  {
        fprintf(stderr, <span style=color:#2aa198>&#34;server: failed to bind</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    <span style=color:#719e07>if</span> (listen(sockfd, BACKLOG) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        perror(<span style=color:#2aa198>&#34;listen&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    sa.sa_handler <span style=color:#719e07>=</span> sigchld_handler; <span style=color:#586e75>// reap all dead processes
</span><span style=color:#586e75></span>    sigemptyset(<span style=color:#719e07>&amp;</span>sa.sa_mask);
    sa.sa_flags <span style=color:#719e07>=</span> SA_RESTART;
    <span style=color:#719e07>if</span> (sigaction(SIGCHLD, <span style=color:#719e07>&amp;</span>sa, <span style=color:#b58900>NULL</span>) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        perror(<span style=color:#2aa198>&#34;sigaction&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    printf(<span style=color:#2aa198>&#34;server: waiting for connections...</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);

    <span style=color:#719e07>while</span>(<span style=color:#2aa198>1</span>) {  <span style=color:#586e75>// main accept() loop
</span><span style=color:#586e75></span>        sin_size <span style=color:#719e07>=</span> <span style=color:#719e07>sizeof</span> their_addr;
        new_fd <span style=color:#719e07>=</span> accept(sockfd, (<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>their_addr, <span style=color:#719e07>&amp;</span>sin_size);
        <span style=color:#719e07>if</span> (new_fd <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
            perror(<span style=color:#2aa198>&#34;accept&#34;</span>);
            <span style=color:#719e07>continue</span>;
        }

        inet_ntop(their_addr.ss_family,
            get_in_addr((<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>their_addr),
            s, <span style=color:#719e07>sizeof</span> s);
        printf(<span style=color:#2aa198>&#34;server: got connection from %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, s);

        <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>fork()) { <span style=color:#586e75>// this is the child process
</span><span style=color:#586e75></span>            close(sockfd); <span style=color:#586e75>// child doesn&#39;t need the listener
</span><span style=color:#586e75></span>            <span style=color:#719e07>if</span> (send(new_fd, <span style=color:#2aa198>&#34;Hello, world!&#34;</span>, <span style=color:#2aa198>13</span>, <span style=color:#2aa198>0</span>) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)
                perror(<span style=color:#2aa198>&#34;send&#34;</span>);
            close(new_fd);
            exit(<span style=color:#2aa198>0</span>);
        }
        close(new_fd);  <span style=color:#586e75>// parent doesn&#39;t need this
</span><span style=color:#586e75></span>    }

    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>一応、構文的にわかりやすいように、1つの大きな <code>main()</code> 関数にまとめてあります。もし、その方が良いと思われるなら、自由に小さな関数に分割してください。</p>
<p>（また、この <code>sigaction()</code> 全体は、あなたにとって新しいものかもしれません&mdash;それは大丈夫です。このコードは、<code>fork()</code> された子プロセスが終了するときに現れるゾンビプロセスを刈り取る役割を担っているのです。ゾンビをたくさん作ってそれを刈り取らないと、システム管理者が怒りますよ。）</p>
<p>このサーバからデータを取得するには、次の節に記載されているクライアントを使用します。</p>
<h2 id=62-a-simple-stream-client>
6.2 A Simple Stream Client
<a class=anchor href=#62-a-simple-stream-client>#</a>
</h2>
<p>こいつはサーバよりもっと簡単です。このクライアントがすることはコマンドラインで指定したホスト、ポート 3490 に接続するだけです。サーバが送信する文字列を取得します。</p>
<p>
<a href=https://beej.us/guide/bgnet/examples/client.c>クライアントソース</a>。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#586e75>/*
</span><span style=color:#586e75>** client.c -- a stream socket client demo
</span><span style=color:#586e75>*/</span>

<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdlib.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;errno.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netdb.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netinet/in.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/socket.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;arpa/inet.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#define PORT &#34;3490&#34; </span><span style=color:#586e75>// the port client will be connecting to
</span><span style=color:#586e75></span>
<span style=color:#719e07>#define MAXDATASIZE 100 </span><span style=color:#586e75>// max number of bytes we can get at once
</span><span style=color:#586e75></span>
<span style=color:#586e75>// get sockaddr, IPv4 or IPv6:
</span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>get_in_addr</span>(<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>sa)
{
    <span style=color:#719e07>if</span> (sa<span style=color:#719e07>-&gt;</span>sa_family <span style=color:#719e07>==</span> AF_INET) {
        <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin_addr);
    }

    <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in6<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin6_addr);
}

<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>int</span> argc, <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>argv[])
{
    <span style=color:#dc322f>int</span> sockfd, numbytes;
    <span style=color:#dc322f>char</span> buf[MAXDATASIZE];
    <span style=color:#719e07>struct</span> addrinfo hints, <span style=color:#719e07>*</span>servinfo, <span style=color:#719e07>*</span>p;
    <span style=color:#dc322f>int</span> rv;
    <span style=color:#dc322f>char</span> s[INET6_ADDRSTRLEN];

    <span style=color:#719e07>if</span> (argc <span style=color:#719e07>!=</span> <span style=color:#2aa198>2</span>) {
        fprintf(stderr,<span style=color:#2aa198>&#34;usage: client hostname</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    memset(<span style=color:#719e07>&amp;</span>hints, <span style=color:#2aa198>0</span>, <span style=color:#719e07>sizeof</span> hints);
    hints.ai_family <span style=color:#719e07>=</span> AF_UNSPEC;
    hints.ai_socktype <span style=color:#719e07>=</span> SOCK_STREAM;

    <span style=color:#719e07>if</span> ((rv <span style=color:#719e07>=</span> getaddrinfo(argv[<span style=color:#2aa198>1</span>], PORT, <span style=color:#719e07>&amp;</span>hints, <span style=color:#719e07>&amp;</span>servinfo)) <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span>) {
        fprintf(stderr, <span style=color:#2aa198>&#34;getaddrinfo: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, gai_strerror(rv));
        <span style=color:#719e07>return</span> <span style=color:#2aa198>1</span>;
    }

    <span style=color:#586e75>// loop through all the results and connect to the first we can
</span><span style=color:#586e75></span>    <span style=color:#719e07>for</span>(p <span style=color:#719e07>=</span> servinfo; p <span style=color:#719e07>!=</span> <span style=color:#b58900>NULL</span>; p <span style=color:#719e07>=</span> p<span style=color:#719e07>-&gt;</span>ai_next) {
        <span style=color:#719e07>if</span> ((sockfd <span style=color:#719e07>=</span> socket(p<span style=color:#719e07>-&gt;</span>ai_family, p<span style=color:#719e07>-&gt;</span>ai_socktype,
                p<span style=color:#719e07>-&gt;</span>ai_protocol)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
            perror(<span style=color:#2aa198>&#34;client: socket&#34;</span>);
            <span style=color:#719e07>continue</span>;
        }

        <span style=color:#719e07>if</span> (connect(sockfd, p<span style=color:#719e07>-&gt;</span>ai_addr, p<span style=color:#719e07>-&gt;</span>ai_addrlen) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
            close(sockfd);
            perror(<span style=color:#2aa198>&#34;client: connect&#34;</span>);
            <span style=color:#719e07>continue</span>;
        }

        <span style=color:#719e07>break</span>;
    }

    <span style=color:#719e07>if</span> (p <span style=color:#719e07>==</span> <span style=color:#b58900>NULL</span>) {
        fprintf(stderr, <span style=color:#2aa198>&#34;client: failed to connect</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
        <span style=color:#719e07>return</span> <span style=color:#2aa198>2</span>;
    }

    inet_ntop(p<span style=color:#719e07>-&gt;</span>ai_family, get_in_addr((<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>)p<span style=color:#719e07>-&gt;</span>ai_addr),
            s, <span style=color:#719e07>sizeof</span> s);
    printf(<span style=color:#2aa198>&#34;client: connecting to %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, s);

    freeaddrinfo(servinfo); <span style=color:#586e75>// all done with this structure
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> ((numbytes <span style=color:#719e07>=</span> recv(sockfd, buf, MAXDATASIZE<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>, <span style=color:#2aa198>0</span>)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        perror(<span style=color:#2aa198>&#34;recv&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    buf[numbytes] <span style=color:#719e07>=</span> <span style=color:#2aa198>&#39;\0&#39;</span>;

    printf(<span style=color:#2aa198>&#34;client: received &#39;%s&#39;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>,buf);

    close(sockfd);

    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>クライアントを実行する前にサーバを実行しない場合、<code>connect()</code> は &ldquo;Connection refused&rdquo; を返すことに注意してください。非常に便利です。</p>
<h2 id=datagram>
6.3 Datagram Sockets
<a class=anchor href=#datagram>#</a>
</h2>
<p>UDP データグラムソケットの基本は、上記の
<a href=/bgnet/docs/system-calls-or-bust/#sendtorecv>5.8 sendto() and recvfrom()</a> ですでに説明しましたので、ここでは <code>talker.c</code> と <code>listener.c</code> という2つのサンプルプログラムのみを紹介します。</p>
<p><code>listener</code> は、ポート 4950 で入ってくるパケットを待つマシンに座っています。<code>talker</code> は、指定されたマシンのそのポートに、ユーザがコマンドラインに入力したものを含むパケットを送信します。</p>
<p>データグラムソケットはコネクションレス型であり、パケットを無慈悲に発射するだけなので、クライアントとサーバには IPv6 を使用するように指示することにしています。こうすることで、サーバが IPv6 でリッスンしていて、クライアントが IPv4 で送信するような状況を避けることができます。（接続された TCP ストリームソケットの世界では、まだ不一致があるかもしれませんが、一方のアドレスファミリーの <code>connect()</code> でエラーが発生すると、他方のアドレスファミリーの再試行が行われます。）</p>
<p>
<a href=https://beej.us/guide/bgnet/examples/listener.c>listener ソースコード</a></p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#586e75>/*
</span><span style=color:#586e75>** listener.c -- a datagram sockets &#34;server&#34; demo
</span><span style=color:#586e75>*/</span>

<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdlib.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;errno.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/socket.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netinet/in.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;arpa/inet.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netdb.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#define MYPORT &#34;4950&#34;	</span><span style=color:#586e75>// the port users will be connecting to
</span><span style=color:#586e75></span>
<span style=color:#719e07>#define MAXBUFLEN 100
</span><span style=color:#719e07></span>
<span style=color:#586e75>// get sockaddr, IPv4 or IPv6:
</span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>get_in_addr</span>(<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>sa)
{
	<span style=color:#719e07>if</span> (sa<span style=color:#719e07>-&gt;</span>sa_family <span style=color:#719e07>==</span> AF_INET) {
		<span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin_addr);
	}

	<span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in6<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin6_addr);
}

<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
	<span style=color:#dc322f>int</span> sockfd;
	<span style=color:#719e07>struct</span> addrinfo hints, <span style=color:#719e07>*</span>servinfo, <span style=color:#719e07>*</span>p;
	<span style=color:#dc322f>int</span> rv;
	<span style=color:#dc322f>int</span> numbytes;
	<span style=color:#719e07>struct</span> sockaddr_storage their_addr;
	<span style=color:#dc322f>char</span> buf[MAXBUFLEN];
	socklen_t addr_len;
	<span style=color:#dc322f>char</span> s[INET6_ADDRSTRLEN];

	memset(<span style=color:#719e07>&amp;</span>hints, <span style=color:#2aa198>0</span>, <span style=color:#719e07>sizeof</span> hints);
	hints.ai_family <span style=color:#719e07>=</span> AF_INET6; <span style=color:#586e75>// set to AF_INET to use IPv4
</span><span style=color:#586e75></span>	hints.ai_socktype <span style=color:#719e07>=</span> SOCK_DGRAM;
	hints.ai_flags <span style=color:#719e07>=</span> AI_PASSIVE; <span style=color:#586e75>// use my IP
</span><span style=color:#586e75></span>
	<span style=color:#719e07>if</span> ((rv <span style=color:#719e07>=</span> getaddrinfo(<span style=color:#b58900>NULL</span>, MYPORT, <span style=color:#719e07>&amp;</span>hints, <span style=color:#719e07>&amp;</span>servinfo)) <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span>) {
		fprintf(stderr, <span style=color:#2aa198>&#34;getaddrinfo: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, gai_strerror(rv));
		<span style=color:#719e07>return</span> <span style=color:#2aa198>1</span>;
	}

	<span style=color:#586e75>// loop through all the results and bind to the first we can
</span><span style=color:#586e75></span>	<span style=color:#719e07>for</span>(p <span style=color:#719e07>=</span> servinfo; p <span style=color:#719e07>!=</span> <span style=color:#b58900>NULL</span>; p <span style=color:#719e07>=</span> p<span style=color:#719e07>-&gt;</span>ai_next) {
		<span style=color:#719e07>if</span> ((sockfd <span style=color:#719e07>=</span> socket(p<span style=color:#719e07>-&gt;</span>ai_family, p<span style=color:#719e07>-&gt;</span>ai_socktype,
				p<span style=color:#719e07>-&gt;</span>ai_protocol)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
			perror(<span style=color:#2aa198>&#34;listener: socket&#34;</span>);
			<span style=color:#719e07>continue</span>;
		}

		<span style=color:#719e07>if</span> (bind(sockfd, p<span style=color:#719e07>-&gt;</span>ai_addr, p<span style=color:#719e07>-&gt;</span>ai_addrlen) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
			close(sockfd);
			perror(<span style=color:#2aa198>&#34;listener: bind&#34;</span>);
			<span style=color:#719e07>continue</span>;
		}

		<span style=color:#719e07>break</span>;
	}

	<span style=color:#719e07>if</span> (p <span style=color:#719e07>==</span> <span style=color:#b58900>NULL</span>) {
		fprintf(stderr, <span style=color:#2aa198>&#34;listener: failed to bind socket</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
		<span style=color:#719e07>return</span> <span style=color:#2aa198>2</span>;
	}

	freeaddrinfo(servinfo);

	printf(<span style=color:#2aa198>&#34;listener: waiting to recvfrom...</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);

	addr_len <span style=color:#719e07>=</span> <span style=color:#719e07>sizeof</span> their_addr;
	<span style=color:#719e07>if</span> ((numbytes <span style=color:#719e07>=</span> recvfrom(sockfd, buf, MAXBUFLEN<span style=color:#719e07>-</span><span style=color:#2aa198>1</span> , <span style=color:#2aa198>0</span>,
		(<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>their_addr, <span style=color:#719e07>&amp;</span>addr_len)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
		perror(<span style=color:#2aa198>&#34;recvfrom&#34;</span>);
		exit(<span style=color:#2aa198>1</span>);
	}

	printf(<span style=color:#2aa198>&#34;listener: got packet from %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>,
		inet_ntop(their_addr.ss_family,
			get_in_addr((<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>their_addr),
			s, <span style=color:#719e07>sizeof</span> s));
	printf(<span style=color:#2aa198>&#34;listener: packet is %d bytes long</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, numbytes);
	buf[numbytes] <span style=color:#719e07>=</span> <span style=color:#2aa198>&#39;\0&#39;</span>;
	printf(<span style=color:#2aa198>&#34;listener: packet contains </span><span style=color:#cb4b16>\&#34;</span><span style=color:#2aa198>%s</span><span style=color:#cb4b16>\&#34;\n</span><span style=color:#2aa198>&#34;</span>, buf);

	close(sockfd);

	<span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p><code>getaddrinfo()</code> の呼び出しで、最終的に <code>SOCK_DGRAM</code> を使用していることに注意してください。また、<code>listen()</code> や <code>accept()</code> は必要ないことに注意してください。これは非接続型データグラムソケットを使用する利点の1つです！</p>
<p>
<a href=https://beej.us/guide/bgnet/examples/talker.c>talker.c ソースコード</a></p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#586e75>/*
</span><span style=color:#586e75>** talker.c -- a datagram &#34;client&#34; demo
</span><span style=color:#586e75>*/</span>

<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdlib.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;errno.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/socket.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netinet/in.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;arpa/inet.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netdb.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#define SERVERPORT &#34;4950&#34;	</span><span style=color:#586e75>// the port users will be connecting to
</span><span style=color:#586e75></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>int</span> argc, <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>argv[])
{
	<span style=color:#dc322f>int</span> sockfd;
	<span style=color:#719e07>struct</span> addrinfo hints, <span style=color:#719e07>*</span>servinfo, <span style=color:#719e07>*</span>p;
	<span style=color:#dc322f>int</span> rv;
	<span style=color:#dc322f>int</span> numbytes;

	<span style=color:#719e07>if</span> (argc <span style=color:#719e07>!=</span> <span style=color:#2aa198>3</span>) {
		fprintf(stderr,<span style=color:#2aa198>&#34;usage: talker hostname message</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
		exit(<span style=color:#2aa198>1</span>);
	}

	memset(<span style=color:#719e07>&amp;</span>hints, <span style=color:#2aa198>0</span>, <span style=color:#719e07>sizeof</span> hints);
	hints.ai_family <span style=color:#719e07>=</span> AF_INET6; <span style=color:#586e75>// set to AF_INET to use IPv4
</span><span style=color:#586e75></span>	hints.ai_socktype <span style=color:#719e07>=</span> SOCK_DGRAM;

	<span style=color:#719e07>if</span> ((rv <span style=color:#719e07>=</span> getaddrinfo(argv[<span style=color:#2aa198>1</span>], SERVERPORT, <span style=color:#719e07>&amp;</span>hints, <span style=color:#719e07>&amp;</span>servinfo)) <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span>) {
		fprintf(stderr, <span style=color:#2aa198>&#34;getaddrinfo: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, gai_strerror(rv));
		<span style=color:#719e07>return</span> <span style=color:#2aa198>1</span>;
	}

	<span style=color:#586e75>// loop through all the results and make a socket
</span><span style=color:#586e75></span>	<span style=color:#719e07>for</span>(p <span style=color:#719e07>=</span> servinfo; p <span style=color:#719e07>!=</span> <span style=color:#b58900>NULL</span>; p <span style=color:#719e07>=</span> p<span style=color:#719e07>-&gt;</span>ai_next) {
		<span style=color:#719e07>if</span> ((sockfd <span style=color:#719e07>=</span> socket(p<span style=color:#719e07>-&gt;</span>ai_family, p<span style=color:#719e07>-&gt;</span>ai_socktype,
				p<span style=color:#719e07>-&gt;</span>ai_protocol)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
			perror(<span style=color:#2aa198>&#34;talker: socket&#34;</span>);
			<span style=color:#719e07>continue</span>;
		}

		<span style=color:#719e07>break</span>;
	}

	<span style=color:#719e07>if</span> (p <span style=color:#719e07>==</span> <span style=color:#b58900>NULL</span>) {
		fprintf(stderr, <span style=color:#2aa198>&#34;talker: failed to create socket</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
		<span style=color:#719e07>return</span> <span style=color:#2aa198>2</span>;
	}

	<span style=color:#719e07>if</span> ((numbytes <span style=color:#719e07>=</span> sendto(sockfd, argv[<span style=color:#2aa198>2</span>], strlen(argv[<span style=color:#2aa198>2</span>]), <span style=color:#2aa198>0</span>,
			 p<span style=color:#719e07>-&gt;</span>ai_addr, p<span style=color:#719e07>-&gt;</span>ai_addrlen)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
		perror(<span style=color:#2aa198>&#34;talker: sendto&#34;</span>);
		exit(<span style=color:#2aa198>1</span>);
	}

	freeaddrinfo(servinfo);

	printf(<span style=color:#2aa198>&#34;talker: sent %d bytes to %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, numbytes, argv[<span style=color:#2aa198>1</span>]);
	close(sockfd);

	<span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>と、これだけです！<code>listener</code> をあるマシンで実行し、次に <code>takler</code> を別のマシンで実行します。それらのコミュニケーションをご覧ください！核家族で楽しめるG級興奮体験です！</p>
<p>今回はサーバを動かす必要もありません。<code>talker</code> はただ楽しくパケットをエーテルに発射し、相手側に <code>recvfrom()</code> の準備が出来ていなければ消えてしまうのです。UDP データグラムソケットを使用して送信されたデータは、到着が保証されていないことを思い出してください！</p>
<p>過去に何度も述べた、もうひとつの小さなディテールを除いては、コネクテッド・データグラム・ソケットです。このドキュメントのデータグラムセクションにいるので、ここでこれについて話す必要があります。例えば、<code>talker</code> が <code>connect()</code> を呼び出して <code>listener</code> のアドレスを指定したとします。それ以降、<code>talker</code> は <code>connect()</code> で指定されたアドレスにのみ送信と受信ができます。このため、<code>sendto()</code> と <code>recvfrom()</code> を使う必要はなく、単に <code>send()</code> と <code>recv()</code> を使えばいいのです。</p>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
<div><a class="flex align-center" href=https://github.com/solareenlo/bgnet/commit/40aef5ecbdba45291c22bc533fd69c896a82e1bf title="Last modified by solareenlo | Jan 5, 2022" target=_blank rel=noopener>
<img src=/bgnet/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 5, 2022</span>
</a>
</div>
<div>
<a class="flex align-center" href=https://github.com/solareenlo/bgnet/edit/master/content/content/docs/client-server-background/_index.md target=_blank rel=noopener>
<img src=/bgnet/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span>
</a>
</div>
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#6-client-server-background>6 Client-Server Background</a>
<ul>
<li><a href=#61-a-simple-stream-server>6.1 A Simple Stream Server</a></li>
<li><a href=#62-a-simple-stream-client>6.2 A Simple Stream Client</a></li>
<li><a href=#datagram>6.3 Datagram Sockets</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>