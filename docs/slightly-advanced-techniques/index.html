<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="7 Slightly Advanced Techniques #  これらは本当に高度なものではありませんが、私たちがすでにカバーしたより基本的なレベルから抜け出したものです。実際、ここまでくれば、Unix ネットワークプログラミングの基本をかなり習得したと考えてよいでしょう！おめでとうございます！
さて、ここからは、より難解な事柄の勇敢な新世界に突入します。ソケットについて学ぶことができます。どうぞお楽しみに！
7.1 Blocking #  ブロッキング。聞いたことがあると思います&mdash;さて、一体何でしょう？一言で言えば、&ldquo;ブロック&#34;は技術用語で&#34;スリープ&#34;のことです。上で listener を実行したとき、パケットが到着するまでただそこに座っていることに気付いたと思います。何が起こったかというと、recvfrom() を呼び出したのですが、データがなかったので、recvfrom() はデータが到着するまで &ldquo;block&rdquo;（つまり、そこで眠る）と言われているのです。
多くの関数がブロックします。accept() がブロックします。すべての recv() 関数がブロックします。このようなことができるのは、ブロックすることが許されているからです。最初に socket() でソケットディスクリプタを作成するとき、カーネルはそれをブロッキングに設定します。もし、ソケットをブロッキングさせたくなければ、fcntl() を呼び出す必要があります。
#include <unistd.h>#include <fcntl.h>. . . sockfd = socket(PF_INET, SOCK_STREAM, 0); fcntl(sockfd, F_SETFL, O_NONBLOCK); . . . ソケットをノンブロッキングに設定することで、効果的にソケットの情報を&#34;ポール&#34;することができます。ノンブロッキングソケットから読み込もうとしたときに、そこにデータがない場合、ブロックすることは許されません&mdash;その際には -1 が返り、errno には EAGAIN または EWOULDBLOCK がセットされます。
（待てよ&ndash;EAGAIN や EWOULDBLOCK を返すこともあるのか？どちらをチェックする？仕様では実際にあなたのシステムがどちらを返すかは指定されていないので、移植性のために両方チェックしましょう。）
しかし、一般的に言って、この種のポーリングは悪い考えです。ソケットのデータを探すためにプログラムをビジーウェイト状態にすると、流行遅れのように CPU 時間を吸い取られてしまうからです。読み込み待ちのデータがあるかどうかを確認するための、よりエレガントなソリューションが、次の poll() の節で紹介されています。
7.2 poll()&mdash;Synchronous I/O Multiplexing #  本当にやりたいことは、一度にたくさんのソケットを監視して、データの準備ができたものを処理することです。そうすれば、すべてのソケットを継続的にポーリングして、どれが読み込み可能な状態にあるかを確認する必要がなくなります。
 警告: poll() は膨大な数のコネクションを持つ場合、恐ろしく遅くなります。そのような状況では、システムで利用可能な最も高速なメソッドを使用しようとする libevent のようなイベントライブラリの方が良いパフォーマンスを得ることができるでしょう。">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content="7 Slightly Advanced Techniques">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="https://solareenlo.com/bgnet/docs/slightly-advanced-techniques/">
<title>7 Slightly Advanced Techniques | Beej's Guide to Network Programming</title>
<link rel=manifest href=/bgnet/manifest.json>
<link rel=icon href=/bgnet/favicon.png type=image/x-icon>
<link rel=stylesheet href=/bgnet/book.min.3fc729a37471ee87e40517478b6ab5936d22fcb6008d40985724e4295d1a74c0.css integrity="sha256-P8cpo3Rx7ofkBRdHi2q1k20i/LYAjUCYVyTkKV0adMA=" crossorigin=anonymous>
<script defer src=/bgnet/flexsearch.min.js></script>
<script defer src=/bgnet/en.search.min.96186359677d3260e56b54ad32896768914aa874b07c8dc22b598beaa926b613.js integrity="sha256-lhhjWWd9MmDla1StMolnaJFKqHSwfI3CK1mL6qkmthM=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=https://solareenlo.com/bgnet/docs/slightly-advanced-techniques/index.xml title="Beej's Guide to Network Programming">
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/bgnet/><span>Beej's Guide to Network Programming</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li>
<a href=/bgnet/docs/intro><strong>1</strong> Intro</a>
<ul>
<li>
<a href=/bgnet/docs/intro/#11-audience><strong>1.1</strong> Audience</a></li>
<li>
<a href=/bgnet/docs/intro/#12-platform-and-compiler><strong>1.2</strong> Platform and Compiler</a></li>
<li>
<a href=/bgnet/docs/intro/#13-official-homepage-and-books-for-sale><strong>1.3</strong> Official Homepage and Books For Sale</a></li>
<li>
<a href=/bgnet/docs/intro/#solaris><strong>1.4</strong> Note for Solaris/SunOS Programmers</a></li>
<li>
<a href=/bgnet/docs/intro/#windows><strong>1.5</strong> Note for Windows Programmers</a></li>
<li>
<a href=/bgnet/docs/intro/#16-email-policy><strong>1.6</strong> Email Policy</a></li>
<li>
<a href=/bgnet/docs/intro/#17-mirroring><strong>1.7</strong> Mirroring</a></li>
<li>
<a href=/bgnet/docs/intro/#18-note-for-translators><strong>1.8</strong> Note for Translators</a></li>
<li>
<a href=/bgnet/docs/intro/#legal><strong>1.9</strong> Copyright, Distribution, and Legal</a></li>
<li>
<a href=/bgnet/docs/intro/#110-dedication><strong>1.10</strong> Dedication</a></li>
<li>
<a href=/bgnet/docs/intro/#111-publishing-information><strong>1.11</strong> Publishing Information</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/what-is-a-socket><strong>2</strong> What is a socket?</a>
<ul>
<li>
<a href=/bgnet/docs/what-is-a-socket/#21-two-types-of-internet-sockets><strong>2.1</strong> Two Types of Internet Sockets</a></li>
<li>
<a href=/bgnet/docs/what-is-a-socket/#lowlevel><strong>2.2</strong> Low level Nonsense and Network Theory</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging><strong>3</strong> IP Addresses, structs, and Data Munging</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#31-ip-addresses-versions-4-and-6><strong>3.1</strong> IP Addresses, versions 4 and 6</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#311-subnets><strong>3.1.1</strong> Subnets</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#312-port-numbers><strong>3.1.2</strong> Port Numbers</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#32-byte-order><strong>3.2</strong> Byte Order</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#structs><strong>3.3</strong> structs</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#34-ip-addresses-part-deux><strong>3.4</strong> IP Addresses, Part Deux</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#341-private-or-disconnected-networks><strong>3.4.1</strong> Private (Or Disconnected) Networks</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=/bgnet/docs/jumping-from-ipv4-to-ipv6><strong>4</strong> Jumping from IPv4 to IPv6</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust><strong>5</strong> System Calls or Bust</a>
<ul>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#51-getaddrinfo---prepare-to-launch><strong>5.1</strong> getaddrinfo()—Prepare to launch!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#socket><strong>5.2</strong> socket()—Get the File Descriptor!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#bind><strong>5.3</strong> bind()—What port am I on?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#connect><strong>5.4</strong> connect()—Hey, you!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#listen><strong>5.5</strong> listen()—Will somebody please call me?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#56-accept---thank-you-for-calling-port-3490><strong>5.6</strong> accept()—“Thank you for calling port 3490.”</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#sendrecv><strong>5.7</strong> send() and recv()—Talk to me, baby!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#sendtorecv><strong>5.8</strong> sendto() and recvfrom()—Talk to me, DGRAM-style</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#59-close-and-shutdown---get-outta-my-face><strong>5.9</strong> close() and shutdown()—Get outta my face!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#510-getpeername---who-are-you><strong>5.10</strong> getpeername()—Who are you?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#511-gethostname---who-am-i><strong>5.11</strong> gethostname()—Who am I?</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/client-server-background><strong>6</strong> Client-Server Background</a>
<ul>
<li>
<a href=/bgnet/docs/client-server-background/#61-a-simple-stream-server><strong>6.1</strong> A Simple Stream Server</a></li>
<li>
<a href=/bgnet/docs/client-server-background/#62-a-simple-stream-client><strong>6.2</strong> A Simple Stream Client</a></li>
<li>
<a href=/bgnet/docs/client-server-background/#datagram><strong>6.3</strong> Datagram Sockets</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques><strong>7</strong> Slightly Advanced Techniques</a>
<ul>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#blocking><strong>7.1</strong> Blocking</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#poll><strong>7.2</strong> poll()—Synchronous I/O Multiplexing</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#select><strong>7.3</strong> select()—Synchronous I/O Multiplexing, Old School</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#sendall><strong>7.4</strong> Handling Partial <code>send()</code>s</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#serialization><strong>7.5</strong> Serialization&mdash;How to Pack Data</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#sonofdataencap><strong>7.6</strong> Son of Data Encapsulation</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#77-broadcast-packets---hello-world><strong>7.7</strong> Broadcast Packets&mdash;Hello, World!</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/common-questions><strong>8</strong> Common Questions</a>
<br></li>
</ul>
<ul>
<li>
<a href=https://github.com/solareenlo/bgnet target=_blank rel=noopener>
Github
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/bgnet/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>7 Slightly Advanced Techniques</strong>
<label for=toc-control>
<img src=/bgnet/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#7-slightly-advanced-techniques>7 Slightly Advanced Techniques</a>
<ul>
<li><a href=#blocking>7.1 Blocking</a></li>
<li><a href=#poll>7.2 <code>poll()</code>&mdash;Synchronous I/O Multiplexing</a></li>
<li><a href=#select>7.3 <code>select()</code>&mdash;Synchronous I/O Multiplexing, Old School</a></li>
<li><a href=#sendall>7.4 Handling Partial <code>send()</code>s</a></li>
<li><a href=#serialization>7.5 Serialization&mdash;How to Pack Data</a></li>
<li><a href=#sonofdataencap>7.6 Son of Data Encapsulation</a></li>
<li><a href=#77-broadcast-packets---hello-world>7.7 Broadcast Packets&mdash;Hello, World!</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h1 id=7-slightly-advanced-techniques>
7 Slightly Advanced Techniques
<a class=anchor href=#7-slightly-advanced-techniques>#</a>
</h1>
<p>これらは本当に高度なものではありませんが、私たちがすでにカバーしたより基本的なレベルから抜け出したものです。実際、ここまでくれば、Unix ネットワークプログラミングの基本をかなり習得したと考えてよいでしょう！おめでとうございます！</p>
<p>さて、ここからは、より難解な事柄の勇敢な新世界に突入します。ソケットについて学ぶことができます。どうぞお楽しみに！</p>
<h2 id=blocking>
7.1 Blocking
<a class=anchor href=#blocking>#</a>
</h2>
<p>ブロッキング。聞いたことがあると思います&mdash;さて、一体何でしょう？一言で言えば、&ldquo;ブロック"は技術用語で"スリープ"のことです。上で <code>listener</code> を実行したとき、パケットが到着するまでただそこに座っていることに気付いたと思います。何が起こったかというと、<code>recvfrom()</code> を呼び出したのですが、データがなかったので、<code>recvfrom()</code> はデータが到着するまで &ldquo;block&rdquo;（つまり、そこで眠る）と言われているのです。</p>
<p>多くの関数がブロックします。<code>accept()</code> がブロックします。すべての <code>recv()</code> 関数がブロックします。このようなことができるのは、ブロックすることが許されているからです。最初に <code>socket()</code> でソケットディスクリプタを作成するとき、カーネルはそれをブロッキングに設定します。もし、ソケットをブロッキングさせたくなければ、<code>fcntl()</code> を呼び出す必要があります。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;fcntl.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>.
.
.
sockfd <span style=color:#719e07>=</span> socket(PF_INET, SOCK_STREAM, <span style=color:#2aa198>0</span>);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
.
</code></pre></div><p>ソケットをノンブロッキングに設定することで、効果的にソケットの情報を"ポール"することができます。ノンブロッキングソケットから読み込もうとしたときに、そこにデータがない場合、ブロックすることは許されません&mdash;その際には <code>-1</code> が返り、<code>errno</code> には <code>EAGAIN</code> または <code>EWOULDBLOCK</code> がセットされます。</p>
<p>（待てよ&ndash;<code>EAGAIN</code> や <code>EWOULDBLOCK</code> を返すこともあるのか？どちらをチェックする？仕様では実際にあなたのシステムがどちらを返すかは指定されていないので、移植性のために両方チェックしましょう。）</p>
<p>しかし、一般的に言って、この種のポーリングは悪い考えです。ソケットのデータを探すためにプログラムをビジーウェイト状態にすると、流行遅れのように CPU 時間を吸い取られてしまうからです。読み込み待ちのデータがあるかどうかを確認するための、よりエレガントなソリューションが、次の <code>poll()</code> の節で紹介されています。</p>
<h2 id=poll>
7.2 <code>poll()</code>&mdash;Synchronous I/O Multiplexing
<a class=anchor href=#poll>#</a>
</h2>
<p>本当にやりたいことは、一度にたくさんのソケットを監視して、データの準備ができたものを処理することです。そうすれば、すべてのソケットを継続的にポーリングして、どれが読み込み可能な状態にあるかを確認する必要がなくなります。</p>
<blockquote>
<p>警告: <code>poll()</code> は膨大な数のコネクションを持つ場合、恐ろしく遅くなります。そのような状況では、システムで利用可能な最も高速なメソッドを使用しようとする
<a href=https://libevent.org/>libevent</a> のようなイベントライブラリの方が良いパフォーマンスを得ることができるでしょう。</p>
</blockquote>
<p>では、どうすればポーリングを回避できるのでしょうか。少し皮肉なことに、<code>poll()</code> システムコールを使えばポーリングを避けることができます。簡単に言うと、オペレーティングシステムにすべての汚い仕事を代行してもらい、どのソケットでデータが読めるようになったかだけを知らせてもらうのです。その間、我々のプロセスはスリープして、システムリソースを節約することができます。</p>
<p>一般的なゲームプランは、どのソケットディスクリプタを監視したいか、どのような種類のイベントを監視したいかという情報を <code>struct pollfd</code> の配列として保持することです。OS は、これらのイベントのいずれかが発生するか（例えば &ldquo;socket ready to read!"）またはユーザが指定したタイムアウトが発生するまで <code>poll()</code> 呼び出しでブロックします。</p>
<p>便利なことに、 <code>listen()</code>しているソケットは、新しい接続が <code>accept()</code> される準備ができたときに &ldquo;ready to read&rdquo; を返します。</p>
<p>雑談はこのくらいにして。これをどう使うかです？</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;poll.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>poll</span>(<span style=color:#719e07>struct</span> pollfd fds[], nfds_t nfds, <span style=color:#dc322f>int</span> timeout);
</code></pre></div><p><code>fds</code> は情報の配列（どのソケットの何を監視するか）、<code>nfds</code> は配列の要素数、そして <code>timeout</code> はミリ秒単位のタイムアウトです。<code>timeout</code> はミリ秒単位のタイムアウトで、<code>poll</code> はイベントが発生した配列の要素数を返します。</p>
<p><code>struct pollfd</code> を見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>struct</span> pollfd {
    <span style=color:#dc322f>int</span> fd;         <span style=color:#586e75>// the socket descriptor
</span><span style=color:#586e75></span>    <span style=color:#dc322f>short</span> events;   <span style=color:#586e75>// bitmap of events we&#39;re interested in
</span><span style=color:#586e75></span>    <span style=color:#dc322f>short</span> revents;  <span style=color:#586e75>// when poll() returns, bitmap of events that occurred
</span><span style=color:#586e75></span>};
</code></pre></div><p>そして、その配列を用意するんだ。各要素の <code>fd</code> フィールドに、監視したいソケットディスクリプタを指定します。そして、<code>events</code> フィールドには、監視するイベントの種類を指定します。</p>
<p><code>events</code> フィールドは、以下のビット単位の OR です。</p>
<table>
<thead>
<tr>
<th>Macro</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POLLIN</code></td>
<td>このソケットで <code>recv()</code> のためのデータが準備できたときに警告を出す。</td>
</tr>
<tr>
<td><code>POLLOUT</code></td>
<td>このソケットにブロックせずにデータを <code>send()</code> できるようになったら警告します。</td>
</tr>
</tbody>
</table>
<p>一旦 <code>struct pollfd</code> の配列を整えたら、それを <code>poll()</code> に渡すことができます。配列のサイズと、ミリ秒単位のタイムアウト値も一緒に渡してください。（タイムアウトに負の値を指定すると、永遠に待つことができます。）</p>
<p><code>poll()</code> が返った後、<code>revents</code> フィールドをチェックして、<code>POLLIN</code> または <code>POLLOUT</code> がセットされているかどうかを確認し、イベントが発生したことを示すことができます。</p>
<p>（実際には <code>poll()</code> の呼び出しでできることはもっとたくさんあります。詳細は以下の
<a href=/bgnet/#pollman><code>poll()</code> man ページ</a>を参照してください。）</p>
<p>ここでは、標準入力からデータを読み込めるようになるまで、つまり <code>RETURN</code> を押したときに 2.5 秒間待つ
<a href=https://beej.us/guide/bgnet/examples/poll.c>例</a>を示します。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;poll.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
    <span style=color:#719e07>struct</span> pollfd pfds[<span style=color:#2aa198>1</span>]; <span style=color:#586e75>// More if you want to monitor more
</span><span style=color:#586e75></span>
    pfds[<span style=color:#2aa198>0</span>].fd <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;          <span style=color:#586e75>// Standard input
</span><span style=color:#586e75></span>    pfds[<span style=color:#2aa198>0</span>].events <span style=color:#719e07>=</span> POLLIN; <span style=color:#586e75>// Tell me when ready to read
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// If you needed to monitor other things, as well:
</span><span style=color:#586e75></span>    <span style=color:#586e75>//pfds[1].fd = some_socket; // Some socket descriptor
</span><span style=color:#586e75></span>    <span style=color:#586e75>//pfds[1].events = POLLIN;  // Tell me when ready to read
</span><span style=color:#586e75></span>
    printf(<span style=color:#2aa198>&#34;Hit RETURN or wait 2.5 seconds for timeout</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);

    <span style=color:#dc322f>int</span> num_events <span style=color:#719e07>=</span> poll(pfds, <span style=color:#2aa198>1</span>, <span style=color:#2aa198>2500</span>); <span style=color:#586e75>// 2.5 second timeout
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> (num_events <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span>) {
        printf(<span style=color:#2aa198>&#34;Poll timed out!</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
    } <span style=color:#719e07>else</span> {
        <span style=color:#dc322f>int</span> pollin_happened <span style=color:#719e07>=</span> pfds[<span style=color:#2aa198>0</span>].revents <span style=color:#719e07>&amp;</span> POLLIN;

        <span style=color:#719e07>if</span> (pollin_happened) {
            printf(<span style=color:#2aa198>&#34;File descriptor %d is ready to read</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, pfds[<span style=color:#2aa198>0</span>].fd);
        } <span style=color:#719e07>else</span> {
            printf(<span style=color:#2aa198>&#34;Unexpected event occurred: %d</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, pfds[<span style=color:#2aa198>0</span>].revents);
        }
    }

    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p><code>poll()</code> が <code>pfds</code> 配列の中でイベントが発生した要素の数を返していることに再度注目してください。これは配列のどの要素かを教えてくれるわけではありませんが（そのためにはまだスキャンしなければなりません）、<code>revents</code> フィールドが <code>0</code> 以外のエントリがいくつあるかを教えてくれます（したがって、その数がわかったらスキャンをやめることができます。）</p>
<p>ここで、いくつかの疑問が出てくるかもしれません。<code>poll()</code> に渡したセットに新しいファイルディスクリプタを追加するにはどうしたらいいのでしょうか？これについては、単に配列に必要なだけのスペースがあることを確認するか、必要に応じて <code>realloc()</code> でスペースを追加してください。</p>
<p>セットから項目を削除する場合はどうすればよいのでしょうか。この場合は、配列の最後の要素をコピーして、削除する要素の上に置くことができます。そして、その数をひとつ減らして <code>poll()</code> に渡します。もうひとつの方法として、<code>fd</code> フィールドに負の数を設定すると、<code>poll()</code> はそれを無視します。</p>
<p>どうすれば、<code>telnet</code> できるチャットサーバにまとめることができるのでしょうか？</p>
<p>これから行うのは、リスナーソケットを起動し、それをファイルディスクリプタのセットに追加して <code>poll()</code> に送ることです。（これは、接続があったときに読み込み可能な状態を表示します。）</p>
<p>そして、新しい接続を <code>struct pollfd</code> 配列に追加していきます。そして、容量が足りなくなったら、動的にそれを増やしていきます。</p>
<p>接続が終了したら、その接続を配列から削除します。</p>
<p>そして、ある接続が読み取り可能になったら、そこからデータを読み取り、そのデータを他のすべての接続に送ることで、他のユーザが入力した内容を見ることができるようにします。</p>
<p>そこで、
<a href=https://beej.us/guide/bgnet/examples/pollserver.c>このポール・サーバ</a>を試してみてください。あるウィンドウで実行し、他の多くのターミナルウィンドウから <code>telnet localhost 9034</code> を実行してみてください。一つのウィンドウで入力したものが他のウィンドウでも（RETURNを押した後で）見られるようになるはずです。</p>
<p>それだけでなく、<code>CTRL-]</code> を押して <code>quit</code> とタイプして <code>telnet</code> を終了すると、サーバは切断を検出し、ファイルディスクリプタの配列からあなたを削除するはずです。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#586e75>/*
</span><span style=color:#586e75>** pollserver.c -- a cheezy multiperson chat server
</span><span style=color:#586e75>*/</span>

<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdlib.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/socket.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netinet/in.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;arpa/inet.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netdb.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;poll.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#define PORT &#34;9034&#34;   </span><span style=color:#586e75>// Port we&#39;re listening on
</span><span style=color:#586e75></span>
<span style=color:#586e75>// Get sockaddr, IPv4 or IPv6:
</span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>get_in_addr</span>(<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>sa)
{
    <span style=color:#719e07>if</span> (sa<span style=color:#719e07>-&gt;</span>sa_family <span style=color:#719e07>==</span> AF_INET) {
        <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin_addr);
    }

    <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in6<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin6_addr);
}

<span style=color:#586e75>// Return a listening socket
</span><span style=color:#586e75></span><span style=color:#dc322f>int</span> <span style=color:#268bd2>get_listener_socket</span>(<span style=color:#dc322f>void</span>)
{
    <span style=color:#dc322f>int</span> listener;     <span style=color:#586e75>// Listening socket descriptor
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> yes<span style=color:#719e07>=</span><span style=color:#2aa198>1</span>;        <span style=color:#586e75>// For setsockopt() SO_REUSEADDR, below
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> rv;

    <span style=color:#719e07>struct</span> addrinfo hints, <span style=color:#719e07>*</span>ai, <span style=color:#719e07>*</span>p;

    <span style=color:#586e75>// Get us a socket and bind it
</span><span style=color:#586e75></span>    memset(<span style=color:#719e07>&amp;</span>hints, <span style=color:#2aa198>0</span>, <span style=color:#719e07>sizeof</span> hints);
    hints.ai_family <span style=color:#719e07>=</span> AF_UNSPEC;
    hints.ai_socktype <span style=color:#719e07>=</span> SOCK_STREAM;
    hints.ai_flags <span style=color:#719e07>=</span> AI_PASSIVE;
    <span style=color:#719e07>if</span> ((rv <span style=color:#719e07>=</span> getaddrinfo(<span style=color:#b58900>NULL</span>, PORT, <span style=color:#719e07>&amp;</span>hints, <span style=color:#719e07>&amp;</span>ai)) <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span>) {
        fprintf(stderr, <span style=color:#2aa198>&#34;selectserver: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, gai_strerror(rv));
        exit(<span style=color:#2aa198>1</span>);
    }

    <span style=color:#719e07>for</span>(p <span style=color:#719e07>=</span> ai; p <span style=color:#719e07>!=</span> <span style=color:#b58900>NULL</span>; p <span style=color:#719e07>=</span> p<span style=color:#719e07>-&gt;</span>ai_next) {
        listener <span style=color:#719e07>=</span> socket(p<span style=color:#719e07>-&gt;</span>ai_family, p<span style=color:#719e07>-&gt;</span>ai_socktype, p<span style=color:#719e07>-&gt;</span>ai_protocol);
        <span style=color:#719e07>if</span> (listener <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) {
            <span style=color:#719e07>continue</span>;
        }

        <span style=color:#586e75>// Lose the pesky &#34;address already in use&#34; error message
</span><span style=color:#586e75></span>        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, <span style=color:#719e07>&amp;</span>yes, <span style=color:#719e07>sizeof</span>(<span style=color:#dc322f>int</span>));

        <span style=color:#719e07>if</span> (bind(listener, p<span style=color:#719e07>-&gt;</span>ai_addr, p<span style=color:#719e07>-&gt;</span>ai_addrlen) <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) {
            close(listener);
            <span style=color:#719e07>continue</span>;
        }

        <span style=color:#719e07>break</span>;
    }

    freeaddrinfo(ai); <span style=color:#586e75>// All done with this
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// If we got here, it means we didn&#39;t get bound
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (p <span style=color:#719e07>==</span> <span style=color:#b58900>NULL</span>) {
        <span style=color:#719e07>return</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>;
    }

    <span style=color:#586e75>// Listen
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (listen(listener, <span style=color:#2aa198>10</span>) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        <span style=color:#719e07>return</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>;
    }

    <span style=color:#719e07>return</span> listener;
}

<span style=color:#586e75>// Add a new file descriptor to the set
</span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#268bd2>add_to_pfds</span>(<span style=color:#719e07>struct</span> pollfd <span style=color:#719e07>*</span>pfds[], <span style=color:#dc322f>int</span> newfd, <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>fd_count, <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>fd_size)
{
    <span style=color:#586e75>// If we don&#39;t have room, add more space in the pfds array
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (<span style=color:#719e07>*</span>fd_count <span style=color:#719e07>==</span> <span style=color:#719e07>*</span>fd_size) {
        <span style=color:#719e07>*</span>fd_size <span style=color:#719e07>*=</span> <span style=color:#2aa198>2</span>; <span style=color:#586e75>// Double it
</span><span style=color:#586e75></span>
        <span style=color:#719e07>*</span>pfds <span style=color:#719e07>=</span> realloc(<span style=color:#719e07>*</span>pfds, <span style=color:#719e07>sizeof</span>(<span style=color:#719e07>**</span>pfds) <span style=color:#719e07>*</span> (<span style=color:#719e07>*</span>fd_size));
    }

    (<span style=color:#719e07>*</span>pfds)[<span style=color:#719e07>*</span>fd_count].fd <span style=color:#719e07>=</span> newfd;
    (<span style=color:#719e07>*</span>pfds)[<span style=color:#719e07>*</span>fd_count].events <span style=color:#719e07>=</span> POLLIN; <span style=color:#586e75>// Check ready-to-read
</span><span style=color:#586e75></span>
    (<span style=color:#719e07>*</span>fd_count)<span style=color:#719e07>++</span>;
}

<span style=color:#586e75>// Remove an index from the set
</span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#268bd2>del_from_pfds</span>(<span style=color:#719e07>struct</span> pollfd pfds[], <span style=color:#dc322f>int</span> i, <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>fd_count)
{
    <span style=color:#586e75>// Copy the one from the end over this one
</span><span style=color:#586e75></span>    pfds[i] <span style=color:#719e07>=</span> pfds[<span style=color:#719e07>*</span>fd_count<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>];

    (<span style=color:#719e07>*</span>fd_count)<span style=color:#719e07>--</span>;
}

<span style=color:#586e75>// Main
</span><span style=color:#586e75></span><span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
    <span style=color:#dc322f>int</span> listener;     <span style=color:#586e75>// Listening socket descriptor
</span><span style=color:#586e75></span>
    <span style=color:#dc322f>int</span> newfd;        <span style=color:#586e75>// Newly accept()ed socket descriptor
</span><span style=color:#586e75></span>    <span style=color:#719e07>struct</span> sockaddr_storage remoteaddr; <span style=color:#586e75>// Client address
</span><span style=color:#586e75></span>    socklen_t addrlen;

    <span style=color:#dc322f>char</span> buf[<span style=color:#2aa198>256</span>];    <span style=color:#586e75>// Buffer for client data
</span><span style=color:#586e75></span>
    <span style=color:#dc322f>char</span> remoteIP[INET6_ADDRSTRLEN];

    <span style=color:#586e75>// Start off with room for 5 connections
</span><span style=color:#586e75></span>    <span style=color:#586e75>// (We&#39;ll realloc as necessary)
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> fd_count <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
    <span style=color:#dc322f>int</span> fd_size <span style=color:#719e07>=</span> <span style=color:#2aa198>5</span>;
    <span style=color:#719e07>struct</span> pollfd <span style=color:#719e07>*</span>pfds <span style=color:#719e07>=</span> malloc(<span style=color:#719e07>sizeof</span> <span style=color:#719e07>*</span>pfds <span style=color:#719e07>*</span> fd_size);

    <span style=color:#586e75>// Set up and get a listening socket
</span><span style=color:#586e75></span>    listener <span style=color:#719e07>=</span> get_listener_socket();

    <span style=color:#719e07>if</span> (listener <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        fprintf(stderr, <span style=color:#2aa198>&#34;error getting listening socket</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    <span style=color:#586e75>// Add the listener to set
</span><span style=color:#586e75></span>    pfds[<span style=color:#2aa198>0</span>].fd <span style=color:#719e07>=</span> listener;
    pfds[<span style=color:#2aa198>0</span>].events <span style=color:#719e07>=</span> POLLIN; <span style=color:#586e75>// Report ready to read on incoming connection
</span><span style=color:#586e75></span>
    fd_count <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>; <span style=color:#586e75>// For the listener
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// Main loop
</span><span style=color:#586e75></span>    <span style=color:#719e07>for</span>(;;) {
        <span style=color:#dc322f>int</span> poll_count <span style=color:#719e07>=</span> poll(pfds, fd_count, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>);

        <span style=color:#719e07>if</span> (poll_count <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
            perror(<span style=color:#2aa198>&#34;poll&#34;</span>);
            exit(<span style=color:#2aa198>1</span>);
        }

        <span style=color:#586e75>// Run through the existing connections looking for data to read
</span><span style=color:#586e75></span>        <span style=color:#719e07>for</span>(<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; i <span style=color:#719e07>&lt;</span> fd_count; i<span style=color:#719e07>++</span>) {

            <span style=color:#586e75>// Check if someone&#39;s ready to read
</span><span style=color:#586e75></span>            <span style=color:#719e07>if</span> (pfds[i].revents <span style=color:#719e07>&amp;</span> POLLIN) { <span style=color:#586e75>// We got one!!
</span><span style=color:#586e75></span>
                <span style=color:#719e07>if</span> (pfds[i].fd <span style=color:#719e07>==</span> listener) {
                    <span style=color:#586e75>// If listener is ready to read, handle new connection
</span><span style=color:#586e75></span>
                    addrlen <span style=color:#719e07>=</span> <span style=color:#719e07>sizeof</span> remoteaddr;
                    newfd <span style=color:#719e07>=</span> accept(listener,
                        (<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>remoteaddr,
                        <span style=color:#719e07>&amp;</span>addrlen);

                    <span style=color:#719e07>if</span> (newfd <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
                        perror(<span style=color:#2aa198>&#34;accept&#34;</span>);
                    } <span style=color:#719e07>else</span> {
                        add_to_pfds(<span style=color:#719e07>&amp;</span>pfds, newfd, <span style=color:#719e07>&amp;</span>fd_count, <span style=color:#719e07>&amp;</span>fd_size);

                        printf(<span style=color:#2aa198>&#34;pollserver: new connection from %s on &#34;</span>
                            <span style=color:#2aa198>&#34;socket %d</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>,
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((<span style=color:#719e07>struct</span> sockaddr<span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } <span style=color:#719e07>else</span> {
                    <span style=color:#586e75>// If not the listener, we&#39;re just a regular client
</span><span style=color:#586e75></span>                    <span style=color:#dc322f>int</span> nbytes <span style=color:#719e07>=</span> recv(pfds[i].fd, buf, <span style=color:#719e07>sizeof</span> buf, <span style=color:#2aa198>0</span>);

                    <span style=color:#dc322f>int</span> sender_fd <span style=color:#719e07>=</span> pfds[i].fd;

                    <span style=color:#719e07>if</span> (nbytes <span style=color:#719e07>&lt;=</span> <span style=color:#2aa198>0</span>) {
                        <span style=color:#586e75>// Got error or connection closed by client
</span><span style=color:#586e75></span>                        <span style=color:#719e07>if</span> (nbytes <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span>) {
                            <span style=color:#586e75>// Connection closed
</span><span style=color:#586e75></span>                            printf(<span style=color:#2aa198>&#34;pollserver: socket %d hung up</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, sender_fd);
                        } <span style=color:#719e07>else</span> {
                            perror(<span style=color:#2aa198>&#34;recv&#34;</span>);
                        }

                        close(pfds[i].fd); <span style=color:#586e75>// Bye!
</span><span style=color:#586e75></span>
                        del_from_pfds(pfds, i, <span style=color:#719e07>&amp;</span>fd_count);

                    } <span style=color:#719e07>else</span> {
                        <span style=color:#586e75>// We got some good data from a client
</span><span style=color:#586e75></span>
                        <span style=color:#719e07>for</span>(<span style=color:#dc322f>int</span> j <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; j <span style=color:#719e07>&lt;</span> fd_count; j<span style=color:#719e07>++</span>) {
                            <span style=color:#586e75>// Send to everyone!
</span><span style=color:#586e75></span>                            <span style=color:#dc322f>int</span> dest_fd <span style=color:#719e07>=</span> pfds[j].fd;

                            <span style=color:#586e75>// Except the listener and ourselves
</span><span style=color:#586e75></span>                            <span style=color:#719e07>if</span> (dest_fd <span style=color:#719e07>!=</span> listener <span style=color:#719e07>&amp;&amp;</span> dest_fd <span style=color:#719e07>!=</span> sender_fd) {
                                <span style=color:#719e07>if</span> (send(dest_fd, buf, nbytes, <span style=color:#2aa198>0</span>) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
                                    perror(<span style=color:#2aa198>&#34;send&#34;</span>);
                                }
                            }
                        }
                    }
                } <span style=color:#586e75>// END handle data from client
</span><span style=color:#586e75></span>            } <span style=color:#586e75>// END got ready-to-read from poll()
</span><span style=color:#586e75></span>        } <span style=color:#586e75>// END looping through file descriptors
</span><span style=color:#586e75></span>    } <span style=color:#586e75>// END for(;;)--and you thought it would never end!
</span><span style=color:#586e75></span>
    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>次の節では、似たような古い関数である <code>select()</code> について見ていきます。<code>select()</code> と <code>poll()</code> はどちらも似たような機能とパフォーマンスを持っており、どのように使うかが違うだけです。<code>select()</code> の方が若干移植性が高いかもしれませんが、使い勝手は少し悪いかもしれません。あなたのシステムでサポートされている限り、一番好きなものを選んでください。</p>
<h2 id=select>
7.3 <code>select()</code>&mdash;Synchronous I/O Multiplexing, Old School
<a class=anchor href=#select>#</a>
</h2>
<p>この関数、ちょっと不思議なんですが、とても便利なんです。次のような状況を考えてみましょう。あなたはサーバで、入ってくるコネクションをリッスンするだけでなく、すでに持っているコネクションを読み続けたいのです。</p>
<p>問題ありません。<code>accept()</code> と <code>recv()</code> を数回実行するだけです。そうはいかないよ、バスター！もし <code>accept()</code> の呼び出しがブロックされていたらどうでしょう？どうやって <code>recv()</code> を同時に行うんだ？&ldquo;ノンブロッキングソケットを使いましょう！&ldquo;まさか！CPU を占有するようなことはしない方がいい。じゃあ、何？</p>
<p><code>select()</code> は同時に複数のソケットを監視する力を与えてくれます。どのソケットが読み込み可能で、どのソケットが書き込み可能か、そしてどのソケットが例外を発生させたか、本当に知りたければ教えてくれるでしょう。</p>
<blockquote>
<p>警告: <code>select()</code> は非常にポータブルですが、巨大な数の接続が発生した場合には恐ろしく遅くなります。そのような状況では、
<a href=https://libevent.org/>libevent</a> のようなイベントライブラリの方が、あなたのシステムで利用可能な最も高速なメソッドを使用しようとするため、より良いパフォーマンスを得ることができることでしょう。</p>
</blockquote>
<p>さっそくですが、<code>select()</code>の概要を説明します。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/time.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>select</span>(<span style=color:#dc322f>int</span> numfds, fd_set <span style=color:#719e07>*</span>readfds, fd_set <span style=color:#719e07>*</span>writefds,
           fd_set <span style=color:#719e07>*</span>exceptfds, <span style=color:#719e07>struct</span> timeval <span style=color:#719e07>*</span>timeout);
</code></pre></div><p>この関数は、ファイルディスクリプタの"集合&rdquo;、特に <code>readfds</code>、<code>writefds</code>、<code>exceptfds</code> を監視します。標準入力とソケットディスクリプタ <code>sockfd</code> から読み込めるかどうかを確認したい場合、ファイルディスクリプタ <code>0</code> と <code>sockfd</code> を <code>readfds</code> の集合に追加するだけでよいです。パラメータ <code>numfds</code> には、最も大きいファイルディスクリプタの値に <code>1</code> を足した値を設定する必要があります。この例では、標準入力 (<code>0</code>) よりも確実に大きいので、<code>sockfd+1</code> に設定する必要があります。</p>
<p><code>select()</code> が戻ると、<code>readfds</code> は、選択したファイルディスクリプタのうち、どれが読み込める状態にあるかを反映するように変更されます。以下のマクロ <code>FD_ISSET()</code> を用いて、それらをテストすることができます。</p>
<p>この先に進む前に、これらのセットを操作する方法について説明します。各セットは <code>fd_set</code> 型です。以下のマクロはこの型を操作します。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FD_SET(int fd, fd_set *set);</code></td>
<td><code>set</code> に <code>fd</code> を追加します。</td>
</tr>
<tr>
<td><code>FD_CLR(int fd, fd_set *set);</code></td>
<td><code>set</code> から <code>fd</code> を削除します。</td>
</tr>
<tr>
<td><code>FD_ISSET(int fd, fd_set *set);</code></td>
<td><code>fd</code> が <code>set</code> に含まれる場合は true を返します。</td>
</tr>
<tr>
<td><code>FD_ZERO(fd_set *set);</code></td>
<td><code>set</code> からすべてのエントリをクリアします。</td>
</tr>
</tbody>
</table>
<p>最後に、この奇妙な <code>struct timeval</code> とは何でしょうか？まあ、誰かがデータを送ってくるのをいつまでも待っていたくない場合もあるでしょう。例えば、96 秒ごとに &ldquo;Still Going&mldr;&rdquo; とターミナルに表示させたい、でも何も起きていない。この time 構造体では、タイムアウト時間を指定することができます。タイムアウト時間を超えても <code>select()</code> がまだ準備のできたファイルディスクリプタを見つけられなければ、処理を続行できるように返されます。</p>
<p><code>struct timeval</code> は以下のフィールドを持ちます。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#719e07>struct</span> timeval {
    <span style=color:#dc322f>int</span> tv_sec;     <span style=color:#586e75>// seconds
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> tv_usec;    <span style=color:#586e75>// microseconds
</span><span style=color:#586e75></span>};
</code></pre></div><p><code>tv_sec</code> に待ち時間の秒数を、<code>tv_usec</code> に待ち時間のマイクロ秒数を設定するだけです。そう、これはミリ秒ではなくマイクロ秒なのです。ミリ秒の中には 1000 マイクロ秒があり、1 秒の中には 1000 ミリ秒があります。したがって、1 秒の中には 1,000,000 マイクロ秒があることになります。なぜ &ldquo;usec"なのか？&ldquo;u"は、私たちが"マイクロ"に使っているギリシャ文字の μ（ミュー）に似ていると思われるからです。また、関数が戻ってきたとき、<code>timeout</code> はまだ残っている時間を表示するように更新されるかもしれません。これは、あなたが使っている Unix のフレーバーに依存します。</p>
<p>やったー！マイクロ秒の分解能のタイマーを手に入れたぞ！まあ、当てにしない方がいいです。どんなに小さな <code>struct timeval</code> を設定しても、おそらく標準的な Unix のタイムスライスの一部を待つ必要があります。</p>
<p>その他、気になること。もし <code>struct timeval</code> のフィールドを <code>0</code> に設定すると、<code>select()</code> は直ちにタイムアウトし、セット内のすべてのファイルディスクリプタを効率よくポーリングします。パラメータ <code>timeout</code> を <code>NULL</code> に設定すると、決してタイムアウトせず、最初のファイルディスクリプタが準備できるまで待ちます。最後に、特定のセットを待つことを気にしないのであれば、<code>select()</code> のコールでそれを <code>NULL</code> に設定することができます。</p>
<p>
<a href=https://beej.us/guide/bgnet/examples/select.c>次のコード</a>では、標準入力に何か表示されるまで 2.5 秒待ちます。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#586e75>/*
</span><span style=color:#586e75>** select.c -- a select() demo
</span><span style=color:#586e75>*/</span>

<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/time.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#define STDIN 0  </span><span style=color:#586e75>// file descriptor for standard input
</span><span style=color:#586e75></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
    <span style=color:#719e07>struct</span> timeval tv;
    fd_set readfds;

    tv.tv_sec <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span>;
    tv.tv_usec <span style=color:#719e07>=</span> <span style=color:#2aa198>500000</span>;

    FD_ZERO(<span style=color:#719e07>&amp;</span>readfds);
    FD_SET(STDIN, <span style=color:#719e07>&amp;</span>readfds);

    <span style=color:#586e75>// don&#39;t care about writefds and exceptfds:
</span><span style=color:#586e75></span>    select(STDIN<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>, <span style=color:#719e07>&amp;</span>readfds, <span style=color:#b58900>NULL</span>, <span style=color:#b58900>NULL</span>, <span style=color:#719e07>&amp;</span>tv);

    <span style=color:#719e07>if</span> (FD_ISSET(STDIN, <span style=color:#719e07>&amp;</span>readfds))
        printf(<span style=color:#2aa198>&#34;A key was pressed!</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
    <span style=color:#719e07>else</span>
        printf(<span style=color:#2aa198>&#34;Timed out.</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);

    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>ラインバッファ端末の場合、押すキーは RETURN でないと、とにかくタイムアウトしてしまいます。</p>
<p>さて、この方法はデータグラムソケットでデータを待つのに最適な方法だと思う人もいるかもしれませんね。Unice の中にはこの方法で select を使えるものもあれば、使えないものもあります。試してみたいなら、ローカルの man ページに何が書いてあるか見てみるといいです。</p>
<p>Unices の中には、タイムアウトまでの残り時間を反映して、<code>struct timeval</code> の時間を更新するものがあります。しかし、そうでないものもあります。ポータブルにしたいのであれば、そのようなことが起こることを当てにしないでください。（経過時間を追跡する必要がある場合は、<code>gettimeofday()</code> を使ってください。残念なことですが、それが現実なのです。）</p>
<p>リードセット内のソケットがコネクションをクローズした場合はどうなるのでしょうか？その場合、<code>select()</code> はそのソケットディスクリプタを &ldquo;ready to read&rdquo; に設定して返す。実際にそこから <code>recv()</code> を実行すると、<code>recv()</code> は <code>0</code> を返します。これが、クライアントが接続を閉じたことを知るための方法です。</p>
<p>もうひとつ <code>select()</code> について書いておくと、<code>listen()</code> しているソケットがある場合、そのソケットのファイルディスクリプタを <code>readfds</code> セットに入れておけば、新しい接続があるかどうかチェックすることができます。</p>
<p>以上、全能の関数 <code>select()</code> の概要を簡単に説明しました。</p>
<p>しかし、ご要望の多かった、より詳細な例をご紹介します。残念ながら、上記のごく簡単な例と、こちらの例では、大きな違いがあります。しかし、ご覧になってから、その後に続く説明をお読みください。</p>
<p>
<a href=https://beej.us/guide/bgnet/examples/selectserver.c>このプログラム</a>は、簡単なマルチユーザチャットサーバのように動作します。一つのウィンドウで起動し、他の複数のウィンドウから <code>telnet</code> ("<code>telnet hostname 9034</code>") で接続してください。ある <code>telnet</code> セッションで何かを入力すると、他のすべてのウィンドウに表示されるはずです。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#586e75>/*
</span><span style=color:#586e75>** selectserver.c -- a cheezy multiperson chat server
</span><span style=color:#586e75>*/</span>

<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdlib.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/socket.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netinet/in.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;arpa/inet.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netdb.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#define PORT &#34;9034&#34;   </span><span style=color:#586e75>// port we&#39;re listening on
</span><span style=color:#586e75></span>
<span style=color:#586e75>// get sockaddr, IPv4 or IPv6:
</span><span style=color:#586e75></span><span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>get_in_addr</span>(<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>sa)
{
    <span style=color:#719e07>if</span> (sa<span style=color:#719e07>-&gt;</span>sa_family <span style=color:#719e07>==</span> AF_INET) {
        <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin_addr);
    }

    <span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>(((<span style=color:#719e07>struct</span> sockaddr_in6<span style=color:#719e07>*</span>)sa)<span style=color:#719e07>-&gt;</span>sin6_addr);
}

<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
    fd_set master;    <span style=color:#586e75>// master file descriptor list
</span><span style=color:#586e75></span>    fd_set read_fds;  <span style=color:#586e75>// temp file descriptor list for select()
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> fdmax;        <span style=color:#586e75>// maximum file descriptor number
</span><span style=color:#586e75></span>
    <span style=color:#dc322f>int</span> listener;     <span style=color:#586e75>// listening socket descriptor
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> newfd;        <span style=color:#586e75>// newly accept()ed socket descriptor
</span><span style=color:#586e75></span>    <span style=color:#719e07>struct</span> sockaddr_storage remoteaddr; <span style=color:#586e75>// client address
</span><span style=color:#586e75></span>    socklen_t addrlen;

    <span style=color:#dc322f>char</span> buf[<span style=color:#2aa198>256</span>];    <span style=color:#586e75>// buffer for client data
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> nbytes;

    <span style=color:#dc322f>char</span> remoteIP[INET6_ADDRSTRLEN];

    <span style=color:#dc322f>int</span> yes<span style=color:#719e07>=</span><span style=color:#2aa198>1</span>;        <span style=color:#586e75>// for setsockopt() SO_REUSEADDR, below
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> i, j, rv;

    <span style=color:#719e07>struct</span> addrinfo hints, <span style=color:#719e07>*</span>ai, <span style=color:#719e07>*</span>p;

    FD_ZERO(<span style=color:#719e07>&amp;</span>master);    <span style=color:#586e75>// clear the master and temp sets
</span><span style=color:#586e75></span>    FD_ZERO(<span style=color:#719e07>&amp;</span>read_fds);

    <span style=color:#586e75>// get us a socket and bind it
</span><span style=color:#586e75></span>    memset(<span style=color:#719e07>&amp;</span>hints, <span style=color:#2aa198>0</span>, <span style=color:#719e07>sizeof</span> hints);
    hints.ai_family <span style=color:#719e07>=</span> AF_UNSPEC;
    hints.ai_socktype <span style=color:#719e07>=</span> SOCK_STREAM;
    hints.ai_flags <span style=color:#719e07>=</span> AI_PASSIVE;
    <span style=color:#719e07>if</span> ((rv <span style=color:#719e07>=</span> getaddrinfo(<span style=color:#b58900>NULL</span>, PORT, <span style=color:#719e07>&amp;</span>hints, <span style=color:#719e07>&amp;</span>ai)) <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span>) {
        fprintf(stderr, <span style=color:#2aa198>&#34;selectserver: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, gai_strerror(rv));
        exit(<span style=color:#2aa198>1</span>);
    }

    <span style=color:#719e07>for</span>(p <span style=color:#719e07>=</span> ai; p <span style=color:#719e07>!=</span> <span style=color:#b58900>NULL</span>; p <span style=color:#719e07>=</span> p<span style=color:#719e07>-&gt;</span>ai_next) {
        listener <span style=color:#719e07>=</span> socket(p<span style=color:#719e07>-&gt;</span>ai_family, p<span style=color:#719e07>-&gt;</span>ai_socktype, p<span style=color:#719e07>-&gt;</span>ai_protocol);
        <span style=color:#719e07>if</span> (listener <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) {
            <span style=color:#719e07>continue</span>;
        }

        <span style=color:#586e75>// lose the pesky &#34;address already in use&#34; error message
</span><span style=color:#586e75></span>        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, <span style=color:#719e07>&amp;</span>yes, <span style=color:#719e07>sizeof</span>(<span style=color:#dc322f>int</span>));

        <span style=color:#719e07>if</span> (bind(listener, p<span style=color:#719e07>-&gt;</span>ai_addr, p<span style=color:#719e07>-&gt;</span>ai_addrlen) <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) {
            close(listener);
            <span style=color:#719e07>continue</span>;
        }

        <span style=color:#719e07>break</span>;
    }

    <span style=color:#586e75>// if we got here, it means we didn&#39;t get bound
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (p <span style=color:#719e07>==</span> <span style=color:#b58900>NULL</span>) {
        fprintf(stderr, <span style=color:#2aa198>&#34;selectserver: failed to bind</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
        exit(<span style=color:#2aa198>2</span>);
    }

    freeaddrinfo(ai); <span style=color:#586e75>// all done with this
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// listen
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (listen(listener, <span style=color:#2aa198>10</span>) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        perror(<span style=color:#2aa198>&#34;listen&#34;</span>);
        exit(<span style=color:#2aa198>3</span>);
    }

    <span style=color:#586e75>// add the listener to the master set
</span><span style=color:#586e75></span>    FD_SET(listener, <span style=color:#719e07>&amp;</span>master);

    <span style=color:#586e75>// keep track of the biggest file descriptor
</span><span style=color:#586e75></span>    fdmax <span style=color:#719e07>=</span> listener; <span style=color:#586e75>// so far, it&#39;s this one
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// main loop
</span><span style=color:#586e75></span>    <span style=color:#719e07>for</span>(;;) {
        read_fds <span style=color:#719e07>=</span> master; <span style=color:#586e75>// copy it
</span><span style=color:#586e75></span>        <span style=color:#719e07>if</span> (select(fdmax<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>, <span style=color:#719e07>&amp;</span>read_fds, <span style=color:#b58900>NULL</span>, <span style=color:#b58900>NULL</span>, <span style=color:#b58900>NULL</span>) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
            perror(<span style=color:#2aa198>&#34;select&#34;</span>);
            exit(<span style=color:#2aa198>4</span>);
        }

        <span style=color:#586e75>// run through the existing connections looking for data to read
</span><span style=color:#586e75></span>        <span style=color:#719e07>for</span>(i <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; i <span style=color:#719e07>&lt;=</span> fdmax; i<span style=color:#719e07>++</span>) {
            <span style=color:#719e07>if</span> (FD_ISSET(i, <span style=color:#719e07>&amp;</span>read_fds)) { <span style=color:#586e75>// we got one!!
</span><span style=color:#586e75></span>                <span style=color:#719e07>if</span> (i <span style=color:#719e07>==</span> listener) {
                    <span style=color:#586e75>// handle new connections
</span><span style=color:#586e75></span>                    addrlen <span style=color:#719e07>=</span> <span style=color:#719e07>sizeof</span> remoteaddr;
                    newfd <span style=color:#719e07>=</span> accept(listener,
                        (<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>remoteaddr,
                        <span style=color:#719e07>&amp;</span>addrlen);

                    <span style=color:#719e07>if</span> (newfd <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
                        perror(<span style=color:#2aa198>&#34;accept&#34;</span>);
                    } <span style=color:#719e07>else</span> {
                        FD_SET(newfd, <span style=color:#719e07>&amp;</span>master); <span style=color:#586e75>// add to master set
</span><span style=color:#586e75></span>                        <span style=color:#719e07>if</span> (newfd <span style=color:#719e07>&gt;</span> fdmax) {    <span style=color:#586e75>// keep track of the max
</span><span style=color:#586e75></span>                            fdmax <span style=color:#719e07>=</span> newfd;
                        }
                        printf(<span style=color:#2aa198>&#34;selectserver: new connection from %s on &#34;</span>
                            <span style=color:#2aa198>&#34;socket %d</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>,
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((<span style=color:#719e07>struct</span> sockaddr<span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } <span style=color:#719e07>else</span> {
                    <span style=color:#586e75>// handle data from a client
</span><span style=color:#586e75></span>                    <span style=color:#719e07>if</span> ((nbytes <span style=color:#719e07>=</span> recv(i, buf, <span style=color:#719e07>sizeof</span> buf, <span style=color:#2aa198>0</span>)) <span style=color:#719e07>&lt;=</span> <span style=color:#2aa198>0</span>) {
                        <span style=color:#586e75>// got error or connection closed by client
</span><span style=color:#586e75></span>                        <span style=color:#719e07>if</span> (nbytes <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span>) {
                            <span style=color:#586e75>// connection closed
</span><span style=color:#586e75></span>                            printf(<span style=color:#2aa198>&#34;selectserver: socket %d hung up</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, i);
                        } <span style=color:#719e07>else</span> {
                            perror(<span style=color:#2aa198>&#34;recv&#34;</span>);
                        }
                        close(i); <span style=color:#586e75>// bye!
</span><span style=color:#586e75></span>                        FD_CLR(i, <span style=color:#719e07>&amp;</span>master); <span style=color:#586e75>// remove from master set
</span><span style=color:#586e75></span>                    } <span style=color:#719e07>else</span> {
                        <span style=color:#586e75>// we got some data from a client
</span><span style=color:#586e75></span>                        <span style=color:#719e07>for</span>(j <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; j <span style=color:#719e07>&lt;=</span> fdmax; j<span style=color:#719e07>++</span>) {
                            <span style=color:#586e75>// send to everyone!
</span><span style=color:#586e75></span>                            <span style=color:#719e07>if</span> (FD_ISSET(j, <span style=color:#719e07>&amp;</span>master)) {
                                <span style=color:#586e75>// except the listener and ourselves
</span><span style=color:#586e75></span>                                <span style=color:#719e07>if</span> (j <span style=color:#719e07>!=</span> listener <span style=color:#719e07>&amp;&amp;</span> j <span style=color:#719e07>!=</span> i) {
                                    <span style=color:#719e07>if</span> (send(j, buf, nbytes, <span style=color:#2aa198>0</span>) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
                                        perror(<span style=color:#2aa198>&#34;send&#34;</span>);
                                    }
                                }
                            }
                        }
                    }
                } <span style=color:#586e75>// END handle data from client
</span><span style=color:#586e75></span>            } <span style=color:#586e75>// END got new incoming connection
</span><span style=color:#586e75></span>        } <span style=color:#586e75>// END looping through file descriptors
</span><span style=color:#586e75></span>    } <span style=color:#586e75>// END for(;;)--and you thought it would never end!
</span><span style=color:#586e75></span>
    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>このコードでは、2つのファイル記述子セットを持っていることに注意してください。<code>master</code> と <code>read_fds</code> です。最初の <code>master</code> は、現在接続されているすべてのソケットディスクリプタと、新しい接続を待ち受けているソケットディスクリプタを保持します。</p>
<p><code>master</code> のセットを持っている理由は、<code>select()</code> が実際に渡すセットを変更して、どのソケットが読み込み可能な状態にあるかを反映させるためです。ある <code>select()</code> から次の <code>select()</code> への呼び出しまでの接続を追跡する必要があるので、これらをどこかに安全に保存しておかなければなりません。最後の最後で、<code>master</code> を <code>read_fds</code> にコピーしてから <code>select()</code> を呼び出します。</p>
<p>しかし、これでは新しい接続を得るたびに、それを <code>master</code> セットに追加しなければならないのではありませんか？そうです。そして接続が終了するたびに、それを <code>master</code> セットから削除しなければならないのですか？はい、その通りです。</p>
<p>注目すべきは、<code>listener</code> ソケットが読み込み可能な状態になったかどうかをチェックしていることです。このとき、新しい接続が保留されていることを意味するので、それを <code>accept()</code> して <code>master</code> セットに追加します。同様に、クライアントの接続が読み込み可能な状態になったときに、<code>recv()</code> が <code>0</code> を返したら、クライアントが接続を閉じたことがわかるので、<code>master</code> セットからそれを削除しなければなりません。</p>
<p>しかし、クライアントの <code>recv()</code> がゼロ以外を返した場合、何らかのデータを受信したことが分かります。そこで私はそれを取得し、<code>master</code> リストを経由して、接続されている残りのすべてのクライアントにそのデータを送信します。</p>
<p>以上が、全能の関数 <code>select()</code> の簡単でない概要です。</p>
<p>Linux ファンの皆さんへ：まれに、Linux の <code>select()</code> が &ldquo;ready-to-read&rdquo; を返した後、実際には読み込む準備ができていないことがあります！これは、Linux の <code>select()</code> が &ldquo;ready-to-read&rdquo; を返した後、実際には読み込む準備ができていないことを意味します。これはつまり、<code>select()</code> が読まないと言っているのに、<code>read()</code> でブロックしてしまうということです！なぜだ、この野郎&mdash;！とにかく、回避策は受信側のソケットで <code>O_NONBLOCK</code> フラグをセットして、 <code>EWOULDBLOCK</code> でエラーにすることです（これは発生しても無視しても大丈夫です）。ソケットをノンブロッキングに設定する方法については、
<a href=/bgnet/#fcntlman><code>fcntl()</code> リファレンスページ</a>を参照してください。</p>
<p>さらに、ここでボーナス的な余談ですが、<code>poll()</code> という別の関数があります。これは <code>select()</code> とほぼ同じ動作をしますが、ファイルディスクリプタ集合を管理するシステムが異なります。
<a href=/bgnet/#pollman>チェックしてみてください！</a></p>
<h2 id=sendall>
7.4 Handling Partial <code>send()</code>s
<a class=anchor href=#sendall>#</a>
</h2>
<p>上の
<a href=/bgnet/docs/system-calls-or-bust/#sendrecv><code>send()</code> の節</a>で、<code>send()</code> はあなたが頼んだバイトをすべて送らないかもしれない、と言ったのを覚えていますか？つまり、512バイト送って欲しいのに、412バイトが返ってきたとします。残りの100バイトはどうなったのでしょうか?</p>
<p>さて、それらはまだあなたの小さなバッファの中で送信されるのを待っています。あなたがコントロールできない状況のために、カーネルはすべてのデータを1つのチャンクで送信しないことを決定しました、そして今、私の友人は、データを外に出すのはあなた次第です。</p>
<p>このような関数を書いてやってもいいんじゃないでしょうか。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/socket.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>sendall</span>(<span style=color:#dc322f>int</span> s, <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf, <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>len)
{
    <span style=color:#dc322f>int</span> total <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;        <span style=color:#586e75>// how many bytes we&#39;ve sent
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> bytesleft <span style=color:#719e07>=</span> <span style=color:#719e07>*</span>len; <span style=color:#586e75>// how many we have left to send
</span><span style=color:#586e75></span>    <span style=color:#dc322f>int</span> n;

    <span style=color:#719e07>while</span>(total <span style=color:#719e07>&lt;</span> <span style=color:#719e07>*</span>len) {
        n <span style=color:#719e07>=</span> send(s, buf<span style=color:#719e07>+</span>total, bytesleft, <span style=color:#2aa198>0</span>);
        <span style=color:#719e07>if</span> (n <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) { <span style=color:#719e07>break</span>; }
        total <span style=color:#719e07>+=</span> n;
        bytesleft <span style=color:#719e07>-=</span> n;
    }

    <span style=color:#719e07>*</span>len <span style=color:#719e07>=</span> total; <span style=color:#586e75>// return number actually sent here
</span><span style=color:#586e75></span>
    <span style=color:#719e07>return</span> n<span style=color:#719e07>==-</span><span style=color:#2aa198>1</span><span style=color:#719e07>?-</span><span style=color:#2aa198>1</span><span style=color:#719e07>:</span><span style=color:#2aa198>0</span>; <span style=color:#586e75>// return -1 on failure, 0 on success
</span><span style=color:#586e75></span>}
</code></pre></div><p>この例では、<code>s</code> がデータを送信するソケット、<code>buf</code> がデータを格納するバッファ、<code>len</code> がバッファのバイト数を格納する <code>int</code> へのポインタです。</p>
<p>この関数は、エラーが発生すると <code>-1</code> を返します（また、<code>send()</code> の呼び出しによって <code>errno</code> が設定されたままです）。また、実際に送信されたバイト数は <code>len</code> として返されます。これは、エラーがない限り、あなたが送信するように頼んだバイト数と同じになります。<code>sendall()</code> はデータを送信するために最善を尽くし、ハァハァ言っていますが、もしエラーがあればすぐに返されます。</p>
<p>念のため、この関数の呼び出しのサンプルを示します。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#dc322f>char</span> buf[<span style=color:#2aa198>10</span>] <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;Beej!&#34;</span>;
<span style=color:#dc322f>int</span> len;

len <span style=color:#719e07>=</span> strlen(buf);
<span style=color:#719e07>if</span> (sendall(s, buf, <span style=color:#719e07>&amp;</span>len) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
    perror(<span style=color:#2aa198>&#34;sendall&#34;</span>);
    printf(<span style=color:#2aa198>&#34;We only sent %d bytes because of the error!</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, len);
}
</code></pre></div><p>パケットの一部が到着した場合、受信側ではどのようなことが起こるのでしょうか？パケットの長さがまちまちな場合、あるパケットが終わり、別のパケットが始まるのを受信側はどうやって知るのでしょうか？そう、現実のシナリオはロバの王道なのです。あなたはおそらくカプセル化しなければならないでしょう（冒頭の
<a href=/bgnet/docs/what-is-a-socket/#lowlevel>データのカプセル化のセクション</a>を覚えていますか？）詳細はこちらをご覧ください。</p>
<h2 id=serialization>
7.5 Serialization&mdash;How to Pack Data
<a class=anchor href=#serialization>#</a>
</h2>
<p>ネットワーク上でテキストデータを送るのは簡単ですが、<code>int</code> や <code>float</code> のような"バイナリ"データを送りたい場合はどうしたらよいでしょうか？その結果、いくつかの選択肢があることがわかりました。</p>
<ol>
<li>
<p>数字を <code>sprintf()</code> などの関数でテキストに変換し、送信します。受信側は <code>strtol()</code> などの関数を使ってテキストを解析し、数値に戻します。</p>
</li>
<li>
<p><code>send()</code> にデータへのポインタを渡して、データをそのまま送信します。</p>
</li>
<li>
<p>数値を携帯可能な2進数にエンコードします。受信側はそれをデコードします。</p>
</li>
</ol>
<p>スニークプレビュー！今夜だけ！</p>
<p>[<em>カーテン上昇</em>]</p>
<p>Beejは、&ldquo;私は、上の方法3を好みます！&ldquo;と言っています。</p>
<p>[<em>終</em>]</p>
<p>（このセクションを本格的に始める前に、これを行うためのライブラリは世の中に存在し、自分でローリングして移植性とエラーのない状態を維持することはかなり困難であることをお伝えしておきます。ですから、自分で実装することを決める前に、いろいろと調べて下調べをしてください。私は、このようなことがどのように機能するのかに興味がある人のために、ここに情報を記載します。）</p>
<p>実は、上記の方法はどれも欠点と利点があるのですが、一般的には、先ほど言ったように、私は3番目の方法を好みます。しかし、まず、他の2つの方法の欠点と利点について説明しましょう。</p>
<p>最初の方法は、数字をテキストとしてエンコードしてから送信するもので、電線を伝わってくるデータを簡単に印刷して読むことができるという利点があります。
<a href=https://en.wikipedia.org/wiki/Internet_Relay_Chat>インターネットリレーチャット（IRC）</a>のように、帯域幅を必要としない状況で使用するには、人間が読めるプロトコルが優れている場合もあります。しかし、変換に時間がかかるという欠点があり、その結果はほとんど常に元の数値よりも多くのスペースを取ってしまいます。</p>
<p>方法2：生データを渡します。これは非常に簡単です（しかし危険です！）。送信するデータへのポインタを取り、それを使って send を呼び出すだけです。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#dc322f>double</span> d <span style=color:#719e07>=</span> <span style=color:#2aa198>3490.15926535</span>;

send(s, <span style=color:#719e07>&amp;</span>d, <span style=color:#719e07>sizeof</span> d, <span style=color:#2aa198>0</span>);  <span style=color:#586e75>/* DANGER--non-portable! */</span>
</code></pre></div><p>受け手はこのように受け取ります。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#dc322f>double</span> d;

recv(s, <span style=color:#719e07>&amp;</span>d, <span style=color:#719e07>sizeof</span> d, <span style=color:#2aa198>0</span>);  <span style=color:#586e75>/* DANGER--non-portable! */</span>
</code></pre></div><p>速くて、シンプルで、いいことずくめじゃないですか。しかし、すべてのアーキテクチャが <code>double</code>（あるいは <code>int</code>）を同じビット表現で、あるいは同じバイト順序で表現しているわけではないことがわかりました！このコードは明らかに非移植的です。（おいおい&mdash;もしかしたら移植性は必要ないかもしれない。その場合は、これはいいし、速い。）</p>
<p>整数型をパッキングするとき、<code>htons()</code> クラスの関数が、数値をネットワークバイトオーダーに変換することによって、いかに移植性を保つのに役立つか、そして、それがいかに正しい行為であるかをすでに見てきました。残念ながら、<code>float</code> 型に対する同様の関数はありません。希望は失われてしまったのでしょうか？</p>
<p>恐るべし！（一瞬、怖くなったか？いいえ？少しも？）私たちにできることがあります。データを既知のバイナリ形式にパックし（または"マーシャル&rdquo;、&ldquo;シリアライズ&rdquo;、あるいは他の1億の名前のうちの1つ）、受信者がリモート側で解凍できるようにすることができるのです。</p>
<p>&ldquo;既知のバイナリ形式"とはどういう意味でしょうか？さて、<code>htons()</code> の例はもう見ましたね？これは、ホスト側のフォーマットが何であれ、数値をネットワークバイトオーダーに変更（あるいは"エンコード&rdquo;）します。数字を逆変換（アンエンコード）するために、受信側は <code>ntohs()</code> を呼び出します。</p>
<p>でも、他の非整数型にはそんな関数はないって、さっき言い終わったばかりじゃないですか。そうです。そうなんだ。そして、C 言語にはこれを行う標準的な方法がないので、ちょっと困ったことになります（Python ファンにとってはありがたいダジャレですね）。</p>
<p>そのためには、データを既知の形式にパックし、それを電送してデコードする必要があります。例えば、<code>float</code> をパックするために、以下は
<a href=https://beej.us/guide/bgnet/examples/pack.c>迅速で汚い方法ですが、改善の余地はたくさんあります</a>。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdint.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#dc322f>uint32_t</span> <span style=color:#268bd2>htonf</span>(<span style=color:#dc322f>float</span> f)
{
    <span style=color:#dc322f>uint32_t</span> p;
    <span style=color:#dc322f>uint32_t</span> sign;

    <span style=color:#719e07>if</span> (f <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) { sign <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>; f <span style=color:#719e07>=</span> <span style=color:#719e07>-</span>f; }
    <span style=color:#719e07>else</span> { sign <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; }

    p <span style=color:#719e07>=</span> ((((<span style=color:#dc322f>uint32_t</span>)f)<span style=color:#719e07>&amp;</span><span style=color:#2aa198>0x7fff</span>)<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>16</span>) <span style=color:#719e07>|</span> (sign<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>31</span>); <span style=color:#586e75>// whole part and sign
</span><span style=color:#586e75></span>    p <span style=color:#719e07>|=</span> (<span style=color:#dc322f>uint32_t</span>)(((f <span style=color:#719e07>-</span> (<span style=color:#dc322f>int</span>)f) <span style=color:#719e07>*</span> <span style=color:#2aa198>65536.0f</span>))<span style=color:#719e07>&amp;</span><span style=color:#2aa198>0xffff</span>; <span style=color:#586e75>// fraction
</span><span style=color:#586e75></span>
    <span style=color:#719e07>return</span> p;
}

<span style=color:#dc322f>float</span> <span style=color:#268bd2>ntohf</span>(<span style=color:#dc322f>uint32_t</span> p)
{
    <span style=color:#dc322f>float</span> f <span style=color:#719e07>=</span> ((p<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>16</span>)<span style=color:#719e07>&amp;</span><span style=color:#2aa198>0x7fff</span>); <span style=color:#586e75>// whole part
</span><span style=color:#586e75></span>    f <span style=color:#719e07>+=</span> (p<span style=color:#719e07>&amp;</span><span style=color:#2aa198>0xffff</span>) <span style=color:#719e07>/</span> <span style=color:#2aa198>65536.0f</span>; <span style=color:#586e75>// fraction
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> (((p<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>31</span>)<span style=color:#719e07>&amp;</span><span style=color:#2aa198>0x1</span>) <span style=color:#719e07>==</span> <span style=color:#2aa198>0x1</span>) { f <span style=color:#719e07>=</span> <span style=color:#719e07>-</span>f; } <span style=color:#586e75>// sign bit set
</span><span style=color:#586e75></span>
    <span style=color:#719e07>return</span> f;
}
</code></pre></div><p>上記のコードは、32 ビットの数値に <code>float</code> を格納する素朴な実装のようなものです。上位ビット（31）は数値の符号（&ldquo;1"は負を意味します）を格納するために使用され、次の7ビット（30-16）は <code>float</code> の整数部を格納するために使用されます。最後に残りのビット（15-0）は、数値の小数部分を格納するために使用されます。</p>
<p>使い方はいたって簡単です。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
    <span style=color:#dc322f>float</span> f <span style=color:#719e07>=</span> <span style=color:#2aa198>3.1415926</span>, f2;
    <span style=color:#dc322f>uint32_t</span> netf;

    netf <span style=color:#719e07>=</span> htonf(f);  <span style=color:#586e75>// convert to &#34;network&#34; form
</span><span style=color:#586e75></span>    f2 <span style=color:#719e07>=</span> ntohf(netf); <span style=color:#586e75>// convert back to test
</span><span style=color:#586e75></span>
    printf(<span style=color:#2aa198>&#34;Original: %f</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, f);        <span style=color:#586e75>// 3.141593
</span><span style=color:#586e75></span>    printf(<span style=color:#2aa198>&#34; Network: 0x%08X</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, netf); <span style=color:#586e75>// 0x0003243F
</span><span style=color:#586e75></span>    printf(<span style=color:#2aa198>&#34;Unpacked: %f</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, f2);       <span style=color:#586e75>// 3.141586
</span><span style=color:#586e75></span>
    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>プラス面は、小さくてシンプル、そして速いことです。32767 より大きい数を格納しようとすると、とても満足できるものではありません！マイナス面は、スペースを有効活用できないことと、範囲が大きく制限されることです。上の例では、小数点以下の桁数が正しく保存されていないこともおわかりいただけると思います。</p>
<p>代わりに何ができるのか？浮動小数点数を保存するための標準規格は
<a href=https://en.wikipedia.org/wiki/IEEE_754>IEEE-754</a> として知られています。ほとんどのコンピュータは内部でこのフォーマットを使って浮動小数点演算を行っているので、厳密に言えば変換する必要はないのです。しかし、ソースコードの移植性を重視するのであれば、必ずしもそのような前提は成り立ちません。（一方、高速に動作させたいのであれば、変換を行う必要のないプラットフォームでは最適化すべきです！それが <code>htons()</code> やその類いの処理です。）</p>
<p>以下は、浮動小数点と倍数を IEEE-754 フォーマットにエンコードするコードです。（ほとんど&mdash; NaN や Infinity はエンコードしませんが、そのように修正することができます。）</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#719e07>#define pack754_32(f) (pack754((f), 32, 8))
</span><span style=color:#719e07>#define pack754_64(f) (pack754((f), 64, 11))
</span><span style=color:#719e07>#define unpack754_32(i) (unpack754((i), 32, 8))
</span><span style=color:#719e07>#define unpack754_64(i) (unpack754((i), 64, 11))
</span><span style=color:#719e07></span>
<span style=color:#dc322f>uint64_t</span> <span style=color:#268bd2>pack754</span>(<span style=color:#dc322f>long</span> <span style=color:#dc322f>double</span> f, <span style=color:#dc322f>unsigned</span> bits, <span style=color:#dc322f>unsigned</span> expbits)
{
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>double</span> fnorm;
    <span style=color:#dc322f>int</span> shift;
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> sign, exp, significand;
    <span style=color:#dc322f>unsigned</span> significandbits <span style=color:#719e07>=</span> bits <span style=color:#719e07>-</span> expbits <span style=color:#719e07>-</span> <span style=color:#2aa198>1</span>; <span style=color:#586e75>// -1 for sign bit
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> (f <span style=color:#719e07>==</span> <span style=color:#2aa198>0.0</span>) <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>; <span style=color:#586e75>// get this special case out of the way
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// check sign and begin normalization
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (f <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) { sign <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>; fnorm <span style=color:#719e07>=</span> <span style=color:#719e07>-</span>f; }
    <span style=color:#719e07>else</span> { sign <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; fnorm <span style=color:#719e07>=</span> f; }

    <span style=color:#586e75>// get the normalized form of f and track the exponent
</span><span style=color:#586e75></span>    shift <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
    <span style=color:#719e07>while</span>(fnorm <span style=color:#719e07>&gt;=</span> <span style=color:#2aa198>2.0</span>) { fnorm <span style=color:#719e07>/=</span> <span style=color:#2aa198>2.0</span>; shift<span style=color:#719e07>++</span>; }
    <span style=color:#719e07>while</span>(fnorm <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>1.0</span>) { fnorm <span style=color:#719e07>*=</span> <span style=color:#2aa198>2.0</span>; shift<span style=color:#719e07>--</span>; }
    fnorm <span style=color:#719e07>=</span> fnorm <span style=color:#719e07>-</span> <span style=color:#2aa198>1.0</span>;

    <span style=color:#586e75>// calculate the binary form (non-float) of the significand data
</span><span style=color:#586e75></span>    significand <span style=color:#719e07>=</span> fnorm <span style=color:#719e07>*</span> ((<span style=color:#2aa198>1LL</span><span style=color:#719e07>&lt;&lt;</span>significandbits) <span style=color:#719e07>+</span> <span style=color:#2aa198>0.5f</span>);

    <span style=color:#586e75>// get the biased exponent
</span><span style=color:#586e75></span>    exp <span style=color:#719e07>=</span> shift <span style=color:#719e07>+</span> ((<span style=color:#2aa198>1</span><span style=color:#719e07>&lt;&lt;</span>(expbits<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)) <span style=color:#719e07>-</span> <span style=color:#2aa198>1</span>); <span style=color:#586e75>// shift + bias
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// return the final answer
</span><span style=color:#586e75></span>    <span style=color:#719e07>return</span> (sign<span style=color:#719e07>&lt;&lt;</span>(bits<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)) <span style=color:#719e07>|</span> (exp<span style=color:#719e07>&lt;&lt;</span>(bits<span style=color:#719e07>-</span>expbits<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)) <span style=color:#719e07>|</span> significand;
}

<span style=color:#dc322f>long</span> <span style=color:#dc322f>double</span> <span style=color:#268bd2>unpack754</span>(<span style=color:#dc322f>uint64_t</span> i, <span style=color:#dc322f>unsigned</span> bits, <span style=color:#dc322f>unsigned</span> expbits)
{
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>double</span> result;
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> shift;
    <span style=color:#dc322f>unsigned</span> bias;
    <span style=color:#dc322f>unsigned</span> significandbits <span style=color:#719e07>=</span> bits <span style=color:#719e07>-</span> expbits <span style=color:#719e07>-</span> <span style=color:#2aa198>1</span>; <span style=color:#586e75>// -1 for sign bit
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> (i <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span>) <span style=color:#719e07>return</span> <span style=color:#2aa198>0.0</span>;

    <span style=color:#586e75>// pull the significand
</span><span style=color:#586e75></span>    result <span style=color:#719e07>=</span> (i<span style=color:#719e07>&amp;</span>((<span style=color:#2aa198>1LL</span><span style=color:#719e07>&lt;&lt;</span>significandbits)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)); <span style=color:#586e75>// mask
</span><span style=color:#586e75></span>    result <span style=color:#719e07>/=</span> (<span style=color:#2aa198>1LL</span><span style=color:#719e07>&lt;&lt;</span>significandbits); <span style=color:#586e75>// convert back to float
</span><span style=color:#586e75></span>    result <span style=color:#719e07>+=</span> <span style=color:#2aa198>1.0f</span>; <span style=color:#586e75>// add the one back on
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// deal with the exponent
</span><span style=color:#586e75></span>    bias <span style=color:#719e07>=</span> (<span style=color:#2aa198>1</span><span style=color:#719e07>&lt;&lt;</span>(expbits<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)) <span style=color:#719e07>-</span> <span style=color:#2aa198>1</span>;
    shift <span style=color:#719e07>=</span> ((i<span style=color:#719e07>&gt;&gt;</span>significandbits)<span style=color:#719e07>&amp;</span>((<span style=color:#2aa198>1LL</span><span style=color:#719e07>&lt;&lt;</span>expbits)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)) <span style=color:#719e07>-</span> bias;
    <span style=color:#719e07>while</span>(shift <span style=color:#719e07>&gt;</span> <span style=color:#2aa198>0</span>) { result <span style=color:#719e07>*=</span> <span style=color:#2aa198>2.0</span>; shift<span style=color:#719e07>--</span>; }
    <span style=color:#719e07>while</span>(shift <span style=color:#719e07>&lt;</span> <span style=color:#2aa198>0</span>) { result <span style=color:#719e07>/=</span> <span style=color:#2aa198>2.0</span>; shift<span style=color:#719e07>++</span>; }

    <span style=color:#586e75>// sign it
</span><span style=color:#586e75></span>    result <span style=color:#719e07>*=</span> (i<span style=color:#719e07>&gt;&gt;</span>(bits<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>))<span style=color:#719e07>&amp;</span><span style=color:#2aa198>1</span><span style=color:#719e07>?</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1.0</span><span style=color:#719e07>:</span> <span style=color:#2aa198>1.0</span>;

    <span style=color:#719e07>return</span> result;
}
</code></pre></div><p>32 ビット（おそらく <code>float</code>）と 64 ビット（おそらく <code>double</code>）の数値のパッキングとアンパッキングのための便利なマクロをトップに置きましたが、<code>pack754()</code> 関数を直接呼んで <code>bits</code> 分のデータ（<code>expbits</code> は正規化した数値の指数用に予約されています）をエンコードするように指示することができます。</p>
<p>以下は使用例です。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c>
<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdint.h&gt; // defines uintN_t types</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;inttypes.h&gt; // defines PRIx macros</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
    <span style=color:#dc322f>float</span> f <span style=color:#719e07>=</span> <span style=color:#2aa198>3.1415926</span>, f2;
    <span style=color:#dc322f>double</span> d <span style=color:#719e07>=</span> <span style=color:#2aa198>3.14159265358979323</span>, d2;
    <span style=color:#dc322f>uint32_t</span> fi;
    <span style=color:#dc322f>uint64_t</span> di;

    fi <span style=color:#719e07>=</span> pack754_32(f);
    f2 <span style=color:#719e07>=</span> unpack754_32(fi);

    di <span style=color:#719e07>=</span> pack754_64(d);
    d2 <span style=color:#719e07>=</span> unpack754_64(di);

    printf(<span style=color:#2aa198>&#34;float before : %.7f</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, f);
    printf(<span style=color:#2aa198>&#34;float encoded: 0x%08&#34;</span> PRIx32 <span style=color:#2aa198>&#34;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, fi);
    printf(<span style=color:#2aa198>&#34;float after  : %.7f</span><span style=color:#cb4b16>\n\n</span><span style=color:#2aa198>&#34;</span>, f2);

    printf(<span style=color:#2aa198>&#34;double before : %.20lf</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, d);
    printf(<span style=color:#2aa198>&#34;double encoded: 0x%016&#34;</span> PRIx64 <span style=color:#2aa198>&#34;</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, di);
    printf(<span style=color:#2aa198>&#34;double after  : %.20lf</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, d2);

    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>上記のコードでは、このように出力されます。</p>
<pre tabindex=0><code>float before : 3.1415925
float encoded: 0x40490FDA
float after  : 3.1415925

double before : 3.14159265358979311600
double encoded: 0x400921FB54442D18
double after  : 3.14159265358979311600
</code></pre><p>もう一つの疑問は、<code>struct</code> をどのようにパックするかということです。残念ながら、コンパイラは <code>struct</code> の中に自由にパディングを入れることができるので、全体を1つのチャンクでポータブルに送信することはできません。（&ldquo;これができない&rdquo;、&ldquo;あれができない"というのはもう聞き飽きた？すみません。友人の言葉を借りれば、&ldquo;何か問題が起きると、いつもマイクロソフトのせいにする &ldquo;ということです。これは確かにマイクロソフトのせいではないかもしれませんが、友人の発言は完全に事実です。）</p>
<p>話を戻すと、<code>struct</code> を電線で送るには、各フィールドを独立してパックし、反対側に到着したらそれらを <code>struct</code> にアンパックするのが一番良い方法です。</p>
<p>それは大変なことだ、とお考えでしょう。そうなんです。ひとつは、データをパックするのを手伝ってくれるヘルパー関数を書くことです。これは楽しいぞ。本当に！？</p>
<p>Kernighan と Pike の
<a href="https://www.amazon.com/gp/product/020161586X/ref=as_li_tl?ie=UTF8&tag=beejus0c-20&camp=1789&creative=9325&linkCode=as2&creativeASIN=020161586X&linkId=b3ac9370d2df122adcce0316aed99924">The Practice of Programming</a> という本の中で、彼らは <code>printf()</code> に似た関数である <code>pack()</code> と <code>unpack()</code> を実装し、まさにこのようなことをやっています。リンクしたいのですが、どうやらこれらの関数はこの本の他のソースと一緒にオンラインにないようです。</p>
<p>（The Practice of Programming は素晴らしい読み物です。ゼウスは私が勧めるたびに子猫を救ってくれます。）</p>
<p>この時点で、私は使ったことはありませんが、完全に立派に見える
<a href=https://github.com/protobuf-c/protobuf-c>Protocol Buffers implementation in C</a> へのポインタを落とすつもりです。Python や Perl のプログラマは、同じことを実現するために、それぞれの言語の <code>pack()</code> と <code>unpack()</code> 関数をチェックアウトしたいと思うでしょう。また、Java には大きな Serializable インターフェースがあり、同じような方法で使用することができます。</p>
<p>しかし、C言語で独自のパッキングユーティリティを書きたい場合、K&P のトリックは、変数の引数リストを使って <code>printf()</code> 風の関数を作り、パケットを構築することです。 以下は、それを元に[
<a href=https://beej.us/guide/bgnet/examples/pack2.c>私が自作したバージョン</a>ですが、うまくいけば、このようなものがどのように動作するかのアイデアを与えるのに十分なものです。</p>
<p>（このコードは、上記の <code>pack754()</code> 関数を参照しています。<code>packi*()</code> 関数はおなじみの <code>htons()</code> ファミリーと同じように動作しますが、別の整数の代わりに <code>char</code> 配列にパックする点が異なります。）</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;ctype.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdarg.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#586e75>/*
</span><span style=color:#586e75>** packi16() -- store a 16-bit int into a char buffer (like htons())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>void</span> <span style=color:#268bd2>packi16</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> i)
{
    <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>8</span>; <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i;
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** packi32() -- store a 32-bit int into a char buffer (like htonl())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>void</span> <span style=color:#268bd2>packi32</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> i)
{
    <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>24</span>; <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>16</span>;
    <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>8</span>;  <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i;
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** packi64() -- store a 64-bit int into a char buffer (like htonl())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>void</span> <span style=color:#268bd2>packi64</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> i)
{
    <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>56</span>; <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>48</span>;
    <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>40</span>; <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>32</span>;
    <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>24</span>; <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>16</span>;
    <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i<span style=color:#719e07>&gt;&gt;</span><span style=color:#2aa198>8</span>;  <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> i;
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** unpacki16() -- unpack a 16-bit int from a char buffer (like ntohs())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>unpacki16</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf)
{
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> i2 <span style=color:#719e07>=</span> ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>0</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>8</span>) <span style=color:#719e07>|</span> buf[<span style=color:#2aa198>1</span>];
    <span style=color:#dc322f>int</span> i;

    <span style=color:#586e75>// change unsigned numbers to signed
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (i2 <span style=color:#719e07>&lt;=</span> <span style=color:#2aa198>0x7fffu</span>) { i <span style=color:#719e07>=</span> i2; }
    <span style=color:#719e07>else</span> { i <span style=color:#719e07>=</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span> <span style=color:#719e07>-</span> (<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span>)(<span style=color:#2aa198>0xffffu</span> <span style=color:#719e07>-</span> i2); }

    <span style=color:#719e07>return</span> i;
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** unpacku16() -- unpack a 16-bit unsigned from a char buffer (like ntohs())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>unpacku16</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf)
{
    <span style=color:#719e07>return</span> ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>0</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>8</span>) <span style=color:#719e07>|</span> buf[<span style=color:#2aa198>1</span>];
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** unpacki32() -- unpack a 32-bit int from a char buffer (like ntohl())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>unpacki32</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf)
{
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> i2 <span style=color:#719e07>=</span> ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>0</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>24</span>) <span style=color:#719e07>|</span>
                           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>1</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>16</span>) <span style=color:#719e07>|</span>
                           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>2</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>8</span>)  <span style=color:#719e07>|</span>
                           buf[<span style=color:#2aa198>3</span>];
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> i;

    <span style=color:#586e75>// change unsigned numbers to signed
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (i2 <span style=color:#719e07>&lt;=</span> <span style=color:#2aa198>0x7fffffffu</span>) { i <span style=color:#719e07>=</span> i2; }
    <span style=color:#719e07>else</span> { i <span style=color:#719e07>=</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span> <span style=color:#719e07>-</span> (<span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)(<span style=color:#2aa198>0xffffffffu</span> <span style=color:#719e07>-</span> i2); }

    <span style=color:#719e07>return</span> i;
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** unpacku32() -- unpack a 32-bit unsigned from a char buffer (like ntohl())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>unpacku32</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf)
{
    <span style=color:#719e07>return</span> ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>0</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>24</span>) <span style=color:#719e07>|</span>
           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>1</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>16</span>) <span style=color:#719e07>|</span>
           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>2</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>8</span>)  <span style=color:#719e07>|</span>
           buf[<span style=color:#2aa198>3</span>];
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** unpacki64() -- unpack a 64-bit int from a char buffer (like ntohl())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>unpacki64</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf)
{
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> i2 <span style=color:#719e07>=</span> ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>0</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>56</span>) <span style=color:#719e07>|</span>
                                ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>1</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>48</span>) <span style=color:#719e07>|</span>
                                ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>2</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>40</span>) <span style=color:#719e07>|</span>
                                ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>3</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>32</span>) <span style=color:#719e07>|</span>
                                ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>4</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>24</span>) <span style=color:#719e07>|</span>
                                ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>5</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>16</span>) <span style=color:#719e07>|</span>
                                ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>6</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>8</span>)  <span style=color:#719e07>|</span>
                                buf[<span style=color:#2aa198>7</span>];
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> i;

    <span style=color:#586e75>// change unsigned numbers to signed
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (i2 <span style=color:#719e07>&lt;=</span> <span style=color:#2aa198>0x7fffffffffffffffu</span>) { i <span style=color:#719e07>=</span> i2; }
    <span style=color:#719e07>else</span> { i <span style=color:#719e07>=</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span> <span style=color:#719e07>-</span>(<span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)(<span style=color:#2aa198>0xffffffffffffffffu</span> <span style=color:#719e07>-</span> i2); }

    <span style=color:#719e07>return</span> i;
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** unpacku64() -- unpack a 64-bit unsigned from a char buffer (like ntohl())
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>unpacku64</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf)
{
    <span style=color:#719e07>return</span> ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>0</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>56</span>) <span style=color:#719e07>|</span>
           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>1</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>48</span>) <span style=color:#719e07>|</span>
           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>2</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>40</span>) <span style=color:#719e07>|</span>
           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>3</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>32</span>) <span style=color:#719e07>|</span>
           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>4</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>24</span>) <span style=color:#719e07>|</span>
           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>5</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>16</span>) <span style=color:#719e07>|</span>
           ((<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>)buf[<span style=color:#2aa198>6</span>]<span style=color:#719e07>&lt;&lt;</span><span style=color:#2aa198>8</span>)  <span style=color:#719e07>|</span>
           buf[<span style=color:#2aa198>7</span>];
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** pack() -- store data dictated by the format string in the buffer
</span><span style=color:#586e75>**
</span><span style=color:#586e75>**   bits |signed   unsigned   float   string
</span><span style=color:#586e75>**   -----+----------------------------------
</span><span style=color:#586e75>**      8 |   c        C
</span><span style=color:#586e75>**     16 |   h        H         f
</span><span style=color:#586e75>**     32 |   l        L         d
</span><span style=color:#586e75>**     64 |   q        Q         g
</span><span style=color:#586e75>**      - |                               s
</span><span style=color:#586e75>**
</span><span style=color:#586e75>**  (16-bit unsigned length is automatically prepended to strings)
</span><span style=color:#586e75>*/</span>

<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>pack</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf, <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>format, ...)
{
    va_list ap;

    <span style=color:#dc322f>signed</span> <span style=color:#dc322f>char</span> c;              <span style=color:#586e75>// 8-bit
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> C;

    <span style=color:#dc322f>int</span> h;                      <span style=color:#586e75>// 16-bit
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> H;

    <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> l;                 <span style=color:#586e75>// 32-bit
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> L;

    <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> q;            <span style=color:#586e75>// 64-bit
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> Q;

    <span style=color:#dc322f>float</span> f;                    <span style=color:#586e75>// floats
</span><span style=color:#586e75></span>    <span style=color:#dc322f>double</span> d;
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>double</span> g;
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> fhold;

    <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>s;                    <span style=color:#586e75>// strings
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> len;

    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> size <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;

    va_start(ap, format);

    <span style=color:#719e07>for</span>(; <span style=color:#719e07>*</span>format <span style=color:#719e07>!=</span> <span style=color:#2aa198>&#39;\0&#39;</span>; format<span style=color:#719e07>++</span>) {
        <span style=color:#719e07>switch</span>(<span style=color:#719e07>*</span>format) {
        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;c&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 8-bit
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>1</span>;
            c <span style=color:#719e07>=</span> (<span style=color:#dc322f>signed</span> <span style=color:#dc322f>char</span>)va_arg(ap, <span style=color:#dc322f>int</span>); <span style=color:#586e75>// promoted
</span><span style=color:#586e75></span>            <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> c;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;C&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 8-bit unsigned
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>1</span>;
            C <span style=color:#719e07>=</span> (<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span>)va_arg(ap, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span>); <span style=color:#586e75>// promoted
</span><span style=color:#586e75></span>            <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span> <span style=color:#719e07>=</span> C;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;h&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 16-bit
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            h <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>int</span>);
            packi16(buf, h);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;H&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 16-bit unsigned
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            H <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span>);
            packi16(buf, H);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;l&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 32-bit
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            l <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>);
            packi32(buf, l);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;L&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 32-bit unsigned
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            L <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>);
            packi32(buf, L);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;q&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 64-bit
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            q <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>);
            packi64(buf, q);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;Q&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 64-bit unsigned
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            Q <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span>);
            packi64(buf, Q);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;f&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// float-16
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            f <span style=color:#719e07>=</span> (<span style=color:#dc322f>float</span>)va_arg(ap, <span style=color:#dc322f>double</span>); <span style=color:#586e75>// promoted
</span><span style=color:#586e75></span>            fhold <span style=color:#719e07>=</span> pack754_16(f); <span style=color:#586e75>// convert to IEEE 754
</span><span style=color:#586e75></span>            packi16(buf, fhold);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;d&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// float-32
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            d <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>double</span>);
            fhold <span style=color:#719e07>=</span> pack754_32(d); <span style=color:#586e75>// convert to IEEE 754
</span><span style=color:#586e75></span>            packi32(buf, fhold);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;g&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// float-64
</span><span style=color:#586e75></span>            size <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            g <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>long</span> <span style=color:#dc322f>double</span>);
            fhold <span style=color:#719e07>=</span> pack754_64(g); <span style=color:#586e75>// convert to IEEE 754
</span><span style=color:#586e75></span>            packi64(buf, fhold);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;s&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// string
</span><span style=color:#586e75></span>            s <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>char</span><span style=color:#719e07>*</span>);
            len <span style=color:#719e07>=</span> strlen(s);
            size <span style=color:#719e07>+=</span> len <span style=color:#719e07>+</span> <span style=color:#2aa198>2</span>;
            packi16(buf, len);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            memcpy(buf, s, len);
            buf <span style=color:#719e07>+=</span> len;
            <span style=color:#719e07>break</span>;
        }
    }

    va_end(ap);

    <span style=color:#719e07>return</span> size;
}

<span style=color:#586e75>/*
</span><span style=color:#586e75>** unpack() -- unpack data dictated by the format string into the buffer
</span><span style=color:#586e75>**
</span><span style=color:#586e75>**   bits |signed   unsigned   float   string
</span><span style=color:#586e75>**   -----+----------------------------------
</span><span style=color:#586e75>**      8 |   c        C
</span><span style=color:#586e75>**     16 |   h        H         f
</span><span style=color:#586e75>**     32 |   l        L         d
</span><span style=color:#586e75>**     64 |   q        Q         g
</span><span style=color:#586e75>**      - |                               s
</span><span style=color:#586e75>**
</span><span style=color:#586e75>**  (string is extracted based on its stored length, but &#39;s&#39; can be
</span><span style=color:#586e75>**  prepended with a max length)
</span><span style=color:#586e75>*/</span>
<span style=color:#dc322f>void</span> <span style=color:#268bd2>unpack</span>(<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>buf, <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>format, ...)
{
    va_list ap;

    <span style=color:#dc322f>signed</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>c;              <span style=color:#586e75>// 8-bit
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>C;

    <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>h;                      <span style=color:#586e75>// 16-bit
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>H;

    <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>l;                 <span style=color:#586e75>// 32-bit
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>L;

    <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>q;            <span style=color:#586e75>// 64-bit
</span><span style=color:#586e75></span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> <span style=color:#719e07>*</span>Q;

    <span style=color:#dc322f>float</span> <span style=color:#719e07>*</span>f;                    <span style=color:#586e75>// floats
</span><span style=color:#586e75></span>    <span style=color:#dc322f>double</span> <span style=color:#719e07>*</span>d;
    <span style=color:#dc322f>long</span> <span style=color:#dc322f>double</span> <span style=color:#719e07>*</span>g;
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span> fhold;

    <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>s;
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> len, maxstrlen<span style=color:#719e07>=</span><span style=color:#2aa198>0</span>, count;

    va_start(ap, format);

    <span style=color:#719e07>for</span>(; <span style=color:#719e07>*</span>format <span style=color:#719e07>!=</span> <span style=color:#2aa198>&#39;\0&#39;</span>; format<span style=color:#719e07>++</span>) {
        <span style=color:#719e07>switch</span>(<span style=color:#719e07>*</span>format) {
        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;c&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 8-bit
</span><span style=color:#586e75></span>            c <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>signed</span> <span style=color:#dc322f>char</span><span style=color:#719e07>*</span>);
            <span style=color:#719e07>if</span> (<span style=color:#719e07>*</span>buf <span style=color:#719e07>&lt;=</span> <span style=color:#2aa198>0x7f</span>) { <span style=color:#719e07>*</span>c <span style=color:#719e07>=</span> <span style=color:#719e07>*</span>buf;} <span style=color:#586e75>// re-sign
</span><span style=color:#586e75></span>            <span style=color:#719e07>else</span> { <span style=color:#719e07>*</span>c <span style=color:#719e07>=</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span> <span style=color:#719e07>-</span> (<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span>)(<span style=color:#2aa198>0xffu</span> <span style=color:#719e07>-</span> <span style=color:#719e07>*</span>buf); }
            buf<span style=color:#719e07>++</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;C&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 8-bit unsigned
</span><span style=color:#586e75></span>            C <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span><span style=color:#719e07>*</span>);
            <span style=color:#719e07>*</span>C <span style=color:#719e07>=</span> <span style=color:#719e07>*</span>buf<span style=color:#719e07>++</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;h&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 16-bit
</span><span style=color:#586e75></span>            h <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>int</span><span style=color:#719e07>*</span>);
            <span style=color:#719e07>*</span>h <span style=color:#719e07>=</span> unpacki16(buf);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;H&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 16-bit unsigned
</span><span style=color:#586e75></span>            H <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span><span style=color:#719e07>*</span>);
            <span style=color:#719e07>*</span>H <span style=color:#719e07>=</span> unpacku16(buf);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;l&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 32-bit
</span><span style=color:#586e75></span>            l <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span><span style=color:#719e07>*</span>);
            <span style=color:#719e07>*</span>l <span style=color:#719e07>=</span> unpacki32(buf);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;L&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 32-bit unsigned
</span><span style=color:#586e75></span>            L <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span><span style=color:#719e07>*</span>);
            <span style=color:#719e07>*</span>L <span style=color:#719e07>=</span> unpacku32(buf);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;q&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 64-bit
</span><span style=color:#586e75></span>            q <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span><span style=color:#719e07>*</span>);
            <span style=color:#719e07>*</span>q <span style=color:#719e07>=</span> unpacki64(buf);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;Q&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// 64-bit unsigned
</span><span style=color:#586e75></span>            Q <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>long</span> <span style=color:#dc322f>int</span><span style=color:#719e07>*</span>);
            <span style=color:#719e07>*</span>Q <span style=color:#719e07>=</span> unpacku64(buf);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;f&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// float
</span><span style=color:#586e75></span>            f <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>float</span><span style=color:#719e07>*</span>);
            fhold <span style=color:#719e07>=</span> unpacku16(buf);
            <span style=color:#719e07>*</span>f <span style=color:#719e07>=</span> unpack754_16(fhold);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;d&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// float-32
</span><span style=color:#586e75></span>            d <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>double</span><span style=color:#719e07>*</span>);
            fhold <span style=color:#719e07>=</span> unpacku32(buf);
            <span style=color:#719e07>*</span>d <span style=color:#719e07>=</span> unpack754_32(fhold);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;g&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// float-64
</span><span style=color:#586e75></span>            g <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>long</span> <span style=color:#dc322f>double</span><span style=color:#719e07>*</span>);
            fhold <span style=color:#719e07>=</span> unpacku64(buf);
            <span style=color:#719e07>*</span>g <span style=color:#719e07>=</span> unpack754_64(fhold);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span>;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;s&#39;</span><span style=color:#719e07>:</span> <span style=color:#586e75>// string
</span><span style=color:#586e75></span>            s <span style=color:#719e07>=</span> va_arg(ap, <span style=color:#dc322f>char</span><span style=color:#719e07>*</span>);
            len <span style=color:#719e07>=</span> unpacku16(buf);
            buf <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
            <span style=color:#719e07>if</span> (maxstrlen <span style=color:#719e07>&gt;</span> <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span> len <span style=color:#719e07>&gt;=</span> maxstrlen) count <span style=color:#719e07>=</span> maxstrlen <span style=color:#719e07>-</span> <span style=color:#2aa198>1</span>;
            <span style=color:#719e07>else</span> count <span style=color:#719e07>=</span> len;
            memcpy(s, buf, count);
            s[count] <span style=color:#719e07>=</span> <span style=color:#2aa198>&#39;\0&#39;</span>;
            buf <span style=color:#719e07>+=</span> len;
            <span style=color:#719e07>break</span>;

        <span style=color:#719e07>default</span><span style=color:#719e07>:</span>
            <span style=color:#719e07>if</span> (isdigit(<span style=color:#719e07>*</span>format)) { <span style=color:#586e75>// track max str len
</span><span style=color:#586e75></span>                maxstrlen <span style=color:#719e07>=</span> maxstrlen <span style=color:#719e07>*</span> <span style=color:#2aa198>10</span> <span style=color:#719e07>+</span> (<span style=color:#719e07>*</span>format<span style=color:#719e07>-</span><span style=color:#2aa198>&#39;0&#39;</span>);
            }
        }

        <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>isdigit(<span style=color:#719e07>*</span>format)) maxstrlen <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
    }

    va_end(ap);
}
</code></pre></div><p>そして、
<a href=https://beej.us/guide/bgnet/examples/pack2.c>上記のコード</a>で、あるデータを <code>buf</code> にパックし、それを変数に展開するデモプログラムを以下に示します。なお、文字列の引数（フォーマット指定子 &ldquo;<code>s</code>"）を指定して <code>unpack()</code> を呼び出す場合は、バッファオーバーランを防ぐために最大長を &ldquo;<code>96s</code>&rdquo; のように前に置くことが賢明です。ネットワーク経由で受け取ったデータを解凍するときには注意が必要です。悪意のあるユーザが、あなたのシステムを攻撃するために、うまく構成されたパケットを送るかもしれません！</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#586e75>// various bits for floating point types--
</span><span style=color:#586e75>// varies for different architectures
</span><span style=color:#586e75></span><span style=color:#719e07>typedef</span> <span style=color:#dc322f>float</span> float32_t;
<span style=color:#719e07>typedef</span> <span style=color:#dc322f>double</span> float64_t;

<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>void</span>)
{
    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> buf[<span style=color:#2aa198>1024</span>];
    <span style=color:#dc322f>int8_t</span> magic;
    <span style=color:#dc322f>int16_t</span> monkeycount;
    <span style=color:#dc322f>int32_t</span> altitude;
    float32_t absurdityfactor;
    <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>s <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;Great unmitigated Zot! You&#39;ve found the Runestaff!&#34;</span>;
    <span style=color:#dc322f>char</span> s2[<span style=color:#2aa198>96</span>];
    <span style=color:#dc322f>int16_t</span> packetsize, ps2;

    packetsize <span style=color:#719e07>=</span> pack(buf, <span style=color:#2aa198>&#34;chhlsf&#34;</span>, (<span style=color:#dc322f>int8_t</span>)<span style=color:#2aa198>&#39;B&#39;</span>, (<span style=color:#dc322f>int16_t</span>)<span style=color:#2aa198>0</span>, (<span style=color:#dc322f>int16_t</span>)<span style=color:#2aa198>37</span>, 
            (<span style=color:#dc322f>int32_t</span>)<span style=color:#719e07>-</span><span style=color:#2aa198>5</span>, s, (float32_t)<span style=color:#719e07>-</span><span style=color:#2aa198>3490.6677</span>);
    packi16(buf<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>, packetsize); <span style=color:#586e75>// store packet size in packet for kicks
</span><span style=color:#586e75></span>
    printf(<span style=color:#2aa198>&#34;packet is %&#34;</span> PRId32 <span style=color:#2aa198>&#34; bytes</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, packetsize);

    unpack(buf, <span style=color:#2aa198>&#34;chhl96sf&#34;</span>, <span style=color:#719e07>&amp;</span>magic, <span style=color:#719e07>&amp;</span>ps2, <span style=color:#719e07>&amp;</span>monkeycount, <span style=color:#719e07>&amp;</span>altitude, s2,
        <span style=color:#719e07>&amp;</span>absurdityfactor);

    printf(<span style=color:#2aa198>&#34;&#39;%c&#39; %&#34;</span> PRId32<span style=color:#2aa198>&#34; %&#34;</span> PRId16 <span style=color:#2aa198>&#34; %&#34;</span> PRId32
            <span style=color:#2aa198>&#34; </span><span style=color:#cb4b16>\&#34;</span><span style=color:#2aa198>%s</span><span style=color:#cb4b16>\&#34;</span><span style=color:#2aa198> %f</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, magic, ps2, monkeycount,
            altitude, s2, absurdityfactor);

    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>自分でコードをロールアップするにしても、他人のコードを使うにしても、毎回手作業で各ビットをパッキングするのではなく、バグを抑えるために一般的なデータパッキングルーチンのセットを用意するのは良いアイデアだと思います。</p>
<p>データをパッキングする場合、どのような形式が良いのでしょうか？素晴らしい質問です。幸いなことに、
<a href=https://datatracker.ietf.org/doc/html/rfc4506>RFC4506</a>（外部データ表現規格）では、浮動小数点型、整数型、配列、生データなど、さまざまな型のバイナリ形式をすでに定義しているんです。もし自分でデータをロールバックするのであれば、それに準拠することをお勧めします。でも、そうする義務はありません。パケット警察は、あなたのドアのすぐ外にいるわけではありません。少なくとも、私は彼らがそうだとは思いません。</p>
<p>いずれにせよ、データを送信する前に何らかの方法でエンコードするのが正しい方法なのです！</p>
<h2 id=sonofdataencap>
7.6 Son of Data Encapsulation
<a class=anchor href=#sonofdataencap>#</a>
</h2>
<p>ところで、データをカプセル化するとはどういうことでしょうか。最も単純なケースでは、識別情報かパケット長のどちらか、あるいは両方を含むヘッダーをそこに貼り付けるということです。</p>
<p>ヘッダーはどのようなものにすべきでしょうか？まあ、プロジェクトを完成させるために必要だと思うものを表すバイナリデータに過ぎません。</p>
<p>うわー。漠然としてますね。</p>
<p>なるほど。例えば、<code>SOCK_STREAM</code> を使用したマルチユーザチャットプログラムがあるとします。ユーザが何かをタイプする (&ldquo;発言する&rdquo;) と、2つの情報がサーバに送信される必要があります: 何を発言したか、誰が発言したかです。</p>
<p>ここまでは良いですか？&ldquo;では何が問題なのか？&ldquo;とあなたは聞いているのでしょう。</p>
<p>問題は、メッセージの長さがまちまちであることです。ある人は &ldquo;tom&rdquo; と名乗り、ある人は &ldquo;Benjamin&rdquo; と名乗り、&ldquo;Hey guys what is up?&rdquo; と言うかもしれません。</p>
<p>そこで、これらのものが入ってきたときに <code>send()</code> でクライアントに送るわけです。送信するデータストリームは次のようになります。</p>
<pre tabindex=0><code>t o m H i B e n j a m i n H e y g u y s w h a t i s u p ?
</code></pre><p>といった具合に。あるメッセージが始まり、別のメッセージが止まったとき、クライアントはどうやって知るのでしょうか？もし望むなら、すべてのメッセージを同じ長さにして、
<a href=/bgnet/docs/slightly-advanced-techniques/#sendall>上で実装</a>した <code>sendall()</code> を呼び出すだけでよいでしょう。しかし、それはバンド幅を浪費します！&ldquo;tom&rdquo; が &ldquo;Hi&rdquo; と言うために 1024 バイトも <code>send()</code> したくはないでしょう。</p>
<p>そこで、データを小さなヘッダーとパケット構造でカプセル化します。クライアントもサーバも、このデータをどのようにパックしたりアンパックしたりするか（&ldquo;マーシャル"&ldquo;アンマーシャル"と呼ばれることもあります）知っています。今は見ないでください、私たちは、クライアントとサーバがどのように通信するかを記述するプロトコルを定義し始めているのです</p>
<p>この場合、ユーザ名は固定長で8文字、パディングは <code>'\0'</code> とします。そして、データは最大 128 文字の可変長とします。このような場合に使用するパケット構造の例を見てみましょう。</p>
<ol>
<li>
<p><code>len</code> (1 byte, unsigned)&mdash;8 バイトのユーザ名とチャットデータをカウントしたパケットの総長です。</p>
</li>
<li>
<p><code>name</code> (8 bytes)&mdash;ユーザの名前。必要なら NUL パッドされます。</p>
</li>
<li>
<p><code>chatdata</code> (n-bytes) &mdash; データ自体で、128 バイト以下です。パケットの長さは、このデータの長さに 8（上記の名前フィールドの長さ）を加えたものとします。</p>
</li>
</ol>
<p>なぜ、8 バイトと 128 バイトというフィールドの制限を選んだのか？十分な長さがあると思い、思いつきで選んだのです。しかし、8 バイトでは制約が多すぎる、30 バイトの名前フィールドがあってもいい、などということもあるかもしれません。 選択はあなた次第です。</p>
<p>上記のパケット定義を用いると、最初のパケットは以下の情報（16 進数、ASCII）で構成されることになります。</p>
<pre tabindex=0><code>   0A     74 6F 6D 00 00 00 00 00      48 69
(length)  T  o  m    (padding)         H  i
</code></pre><p>そして、2つ目も同様です。</p>
<pre tabindex=0><code>   18     42 65 6E 6A 61 6D 69 6E      48 65 79 20 67 75 79 73 20 77 ...
(length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w  ...
</code></pre><p>（もちろん、長さはネットワークバイトオーダーで格納されます。この場合は 1 バイトだけなので問題ないですが、一般的にはパケット内の 2 進整数はすべてネットワークバイトオーダーで格納されるようにしたいです。）</p>
<p>このデータを送信するときには、安全策をとって上記の
<a href=/bgnet/docs/slightly-advanced-techniques/#sendall><code>sendall()</code></a> のようなコマンドを使うべきです。そうすれば、たとえすべてのデータを送信するために <code>send()</code> を複数回呼び出す必要があったとしても、すべてのデータが送信されたことを確認できます。</p>
<p>同様に、このデータを受信するときにも、少し余分な作業をする必要があります。念のため、部分的なパケットを受け取るかもしれないことを想定しておく必要があります（例えば、上の Benjamin から &ldquo;<code>18 42 65 6E 6A</code>&rdquo; を受け取るかもしれませんが、この <code>recv()</code> のコールではそれがすべてです。）。パケットが完全に受信されるまで、何度も何度も <code>recv()</code> を呼び出す必要があります。</p>
<p>でも、どうやって？さて、私たちはパケットが完成するために必要な合計バイト数を知っています。その数はパケットの前面に貼られているからです。 また、パケットの最大サイズは 1+8+128、つまり 137 バイトであることも知っています（パケットの定義がそうなっているからです）。</p>
<p>実は、ここでできることがいくつかあるんです。すべてのパケットが長さで始まることを知っているので、パケットの長さを取得するためだけに <code>recv()</code> を呼び出すことができます。そして、一度それを手に入れたら、パケットの残りの長さを正確に指定して（おそらくすべてのデータを得るために繰り返し）、完全なパケットを手に入れるまで再びそれを呼び出すことができます。この方法の利点は、1つのパケットに対して十分な大きさのバッファが必要なことで、欠点は、すべてのデータを取得するために少なくとも2回 <code>recv()</code> を呼び出す必要があることです。</p>
<p>もう一つの方法は、単に <code>recv()</code> を呼び出して、受信してもよい量をパケットの最大バイト数として言うことです。そして、受け取ったものはすべてバッファの後ろに貼り付け、最後にパケットが完了したかどうかを確認します。もちろん、次のパケットの一部を受け取るかもしれないので、そのためのスペースが必要です。</p>
<p>そこで、2つのパケットに十分な大きさの配列を宣言します。これは作業用の配列で、到着したパケットを再構築します。</p>
<p>データを <code>recv()</code> するたびに、ワークバッファにデータを追加し、パケットが完成したかどうかチェックします。すなわち、バッファ内のバイト数がヘッダで指定された長さ以上であること（ヘッダの長さには長さ自体のバイト数は含まれないので、+1）です。バッファ内のバイト数が1より小さい場合、明らかにパケットは完全ではありません。この場合、特別なケースを作る必要があります。しかし、最初の 1 バイトはゴミなので、正しいパケット長を知るためにそれを当てにすることはできないからです。</p>
<p>パケットを完成させたら、あとは好きなように使ってください。使って、ワークバッファから削除してください。</p>
<p>ふぅ〜。もう頭の中でグルグルしてますか？さて、ここでワンツーパンチの2つ目です。1回の <code>recv()</code> 呼び出しで、あるパケットの終わりを越えて次のパケットを読んでしまったかもしれません。つまり、一つの完全なパケットと、次のパケットの不完全な部分を持つワークバッファを持っているのです！なんてこったい。（しかし、このような事態を想定して、ワークバッファを2つのパケットを保持できるような大きさにしたのです！）</p>
<p>最初のパケットの長さはヘッダからわかっているし、ワークバッファのバイト数も記録しているので、ワークバッファのバイト数のうち何バイトが2番目の（不完全な）パケットに属しているかを差し引いて計算することができるのです。最初のパケットを処理したら、それをワークバッファから取り除き、部分的な2番目のパケットをバッファの先頭に移動させ、次の <code>recv() </code> のためにすべての準備をすることができます。</p>
<p>（読者の中には、実際に部分的な2番目のパケットをワークバッファの先頭に移動させるのに時間がかかることを指摘する人もいるでしょう。プログラムは、循環バッファを使用することによって、これを必要としないようにコード化することができます。残念ながら、円形バッファに関する議論は、この記事の範囲外です。それでも気になるなら、データ構造の本を読んでみてください。）</p>
<p>簡単だとは言っていません。なるほど、簡単だとは言いました。練習すれば、すぐに自然にできるようになりますよ。エクスカリバーに誓って！</p>
<h2 id=77-broadcast-packets---hello-world>
7.7 Broadcast Packets&mdash;Hello, World!
<a class=anchor href=#77-broadcast-packets---hello-world>#</a>
</h2>
<p>これまで、このガイドでは、1つのホストから他の1つのホストにデータを送信することについて話してきました。しかし、適切な権限があれば、同時に複数のホストにデータを送信することが可能です、と私は主張します！</p>
<p>UDP（TCP ではなく UDP のみ）と標準的な IPv4 では、これはブロードキャストと呼ばれるメカニズムによって行われます。IPv6 ではブロードキャストはサポートされていないため、マルチキャストという優れた技術を利用する必要があります。しかし、未来に目を向けるのはもう十分です。私たちは 32 ビットの現在に留まっています。</p>
<p>しかし、ちょっと待ってください！いきなりブロードキャストを始めることはできません。ブロードキャストパケットをネットワークに送信する前に、ソケットオプション <code>SO_BROADCAST</code> をセットしなければなりません。まるでミサイルの発射スイッチの上に被せる小さなプラスチックのカバーのようなものです。そのくらいのパワーを秘めているのです。</p>
<p>しかし、真面目な話、ブロードキャストパケットを使うには危険性があるのです。ブロードキャストパケットを受信したすべてのシステムは、そのデータの行き先がどのポートか分かるまで、何層にもわたるデータのカプセル化を解かなければならないのです。そして、そのデータを渡すか、廃棄するかしなければなりません。どちらの場合でも、ブロードキャストパケットを受信した各マシンは、ローカルネットワーク上のすべてのマシンで、多くのマシンが不必要な作業をすることになりかねません。ゲーム Doom が発売された当初、これはそのネットワークコードに対する不満でした。</p>
<p>さて、猫の皮を剥ぐ方法は一つではない&mldr;&mldr;ちょっと待った。本当に猫の皮を剥ぐ方法は1つではないのですか？どんな表現なんだ？それと同じように、ブロードキャストパケットを送る方法も1つではありません。では、本題のブロードキャストメッセージの宛先アドレスはどのように指定するのでしょうか？一般的には2つの方法があります。</p>
<ol>
<li>
<p>特定のサブネットのブロードキャストアドレスにデータを送信します。これは、サブネットのネットワーク番号に、アドレスのホスト部分のすべての 1 ビットを設定したものです。例えば、私の家のネットワークは <code>192.168.1.0</code>、ネットマスクは <code>255.255.255.0</code> で、アドレスの最後のバイトは私のホスト番号です（ネットマスクによると、最初の 3 バイトはネットワーク番号だからです）。つまり、私のブロードキャストアドレスは <code>192.168.1.255</code> です。Unix では、<code>ifconfig</code> コマンドが実際にこのすべてのデータを与えてくれます。（気になる方は、ブロードキャストアドレスを得るためのビット論理は <code>network_number</code> OR (NOT <code>netmask</code>) です。）このタイプのブロードキャストパケットは、自分のローカルネットワークだけでなく、遠隔地のネットワークにも送ることができますが、宛先のルータによってパケットがドロップされる危険性があります。（もしドロップされなかったら、どこかのランダムなスマーフが彼らの LAN にブロードキャストトラフィックを流し始めるかもしれません。）</p>
</li>
<li>
<p>&ldquo;グローバル"ブロードキャストアドレスにデータを送信します。これは <code>255.255.255.255</code> で、別名 <code>INADDR_BROADCAST</code> と呼ばれるものです。多くのマシンはこれをネットワーク番号と自動的にビット演算して、ネットワークブロードキャストアドレスに変換しますが、そうでないものもあります。ルータは、皮肉なことに、この種のブロードキャストパケットをローカルネットワークから転送しません。</p>
</li>
</ol>
<p>では、ソケットオプション <code>SO_BROADCAST</code> を設定せずに、ブロードキャストアドレスでデータを送信しようとするとどうなるでしょうか。それでは、古き良き時代の
<a href=/bgnet/docs/client-server-background/#datagram><code>talker</code> and <code>listener</code></a> を起動し、何が起こるか見てみましょう。</p>
<pre tabindex=0><code>$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sendto: Permission denied
$ talker 255.255.255.255 foo
sendto: Permission denied
</code></pre><p>そう、全然嬉しくないんです&mldr;ソケットオプションの <code>SO_BROADCAST</code> を設定していなかったからです。そうすれば、どこでも <code>sendto()</code> ができるようになります！</p>
<p>実際、これがブロードキャストできる UDP アプリケーションとできない UDP アプリケーションの唯一の違いなのです。そこで、古い <code>talker</code> アプリケーションに <code>SO_BROADCAST</code> ソケットオプションを設定するセクションを一つ追加してみましょう。このプログラムを
<a href=https://beej.us/guide/bgnet/examples/broadcaster.c><code>broadcaster.c</code></a> と呼ぶことにします。</p>
<div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#586e75>/*
</span><span style=color:#586e75>** broadcaster.c -- a datagram &#34;client&#34; like talker.c, except
</span><span style=color:#586e75>**                  this one can broadcast
</span><span style=color:#586e75>*/</span>

<span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdio.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;stdlib.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;unistd.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;errno.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;string.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/types.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;sys/socket.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netinet/in.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;arpa/inet.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;netdb.h&gt;</span><span style=color:#719e07>
</span><span style=color:#719e07></span>
<span style=color:#719e07>#define SERVERPORT 4950 </span><span style=color:#586e75>// the port users will be connecting to
</span><span style=color:#586e75></span>
<span style=color:#dc322f>int</span> <span style=color:#268bd2>main</span>(<span style=color:#dc322f>int</span> argc, <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>argv[])
{
    <span style=color:#dc322f>int</span> sockfd;
    <span style=color:#719e07>struct</span> sockaddr_in their_addr; <span style=color:#586e75>// connector&#39;s address information
</span><span style=color:#586e75></span>    <span style=color:#719e07>struct</span> hostent <span style=color:#719e07>*</span>he;
    <span style=color:#dc322f>int</span> numbytes;
    <span style=color:#dc322f>int</span> broadcast <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
    <span style=color:#586e75>//char broadcast = &#39;1&#39;; // if that doesn&#39;t work, try this
</span><span style=color:#586e75></span>
    <span style=color:#719e07>if</span> (argc <span style=color:#719e07>!=</span> <span style=color:#2aa198>3</span>) {
        fprintf(stderr,<span style=color:#2aa198>&#34;usage: broadcaster hostname message</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    <span style=color:#719e07>if</span> ((he<span style=color:#719e07>=</span>gethostbyname(argv[<span style=color:#2aa198>1</span>])) <span style=color:#719e07>==</span> <span style=color:#b58900>NULL</span>) {  <span style=color:#586e75>// get the host info
</span><span style=color:#586e75></span>        perror(<span style=color:#2aa198>&#34;gethostbyname&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    <span style=color:#719e07>if</span> ((sockfd <span style=color:#719e07>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#2aa198>0</span>)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        perror(<span style=color:#2aa198>&#34;socket&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    <span style=color:#586e75>// this call is what allows broadcast packets to be sent:
</span><span style=color:#586e75></span>    <span style=color:#719e07>if</span> (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, <span style=color:#719e07>&amp;</span>broadcast,
        <span style=color:#719e07>sizeof</span> broadcast) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        perror(<span style=color:#2aa198>&#34;setsockopt (SO_BROADCAST)&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    their_addr.sin_family <span style=color:#719e07>=</span> AF_INET;     <span style=color:#586e75>// host byte order
</span><span style=color:#586e75></span>    their_addr.sin_port <span style=color:#719e07>=</span> htons(SERVERPORT); <span style=color:#586e75>// short, network byte order
</span><span style=color:#586e75></span>    their_addr.sin_addr <span style=color:#719e07>=</span> <span style=color:#719e07>*</span>((<span style=color:#719e07>struct</span> in_addr <span style=color:#719e07>*</span>)he<span style=color:#719e07>-&gt;</span>h_addr);
    memset(their_addr.sin_zero, <span style=color:#2aa198>&#39;\0&#39;</span>, <span style=color:#719e07>sizeof</span> their_addr.sin_zero);

    <span style=color:#719e07>if</span> ((numbytes<span style=color:#719e07>=</span>sendto(sockfd, argv[<span style=color:#2aa198>2</span>], strlen(argv[<span style=color:#2aa198>2</span>]), <span style=color:#2aa198>0</span>,
             (<span style=color:#719e07>struct</span> sockaddr <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>their_addr, <span style=color:#719e07>sizeof</span> their_addr)) <span style=color:#719e07>==</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>) {
        perror(<span style=color:#2aa198>&#34;sendto&#34;</span>);
        exit(<span style=color:#2aa198>1</span>);
    }

    printf(<span style=color:#2aa198>&#34;sent %d bytes to %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, numbytes,
        inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    <span style=color:#719e07>return</span> <span style=color:#2aa198>0</span>;
}
</code></pre></div><p>&ldquo;通常の&rdquo; UDP クライアント/サーバーの状況と何が違うのでしょうか？何もありません。（この場合、クライアントがブロードキャストパケットの送信を許可されていることを除けば。）このように、古い UDP
<a href=/bgnet/docs/client-server-background/#datagram><code>listener</code></a> プログラムを1つのウィンドウで実行し、<code>broadcaster</code> を別のウィンドウで実行してみてください。これで、上で失敗した送信をすべて行うことができるはずです。</p>
<pre tabindex=0><code>$ broadcaster 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ broadcaster 192.168.1.255 foo
sent 3 bytes to 192.168.1.255
$ broadcaster 255.255.255.255 foo
sent 3 bytes to 255.255.255.255
</code></pre><p>そして、<code>listener</code> がパケットを受け取ったと応答するのが見えるはずです。（もし <code>listener</code> が応答しないなら、それは IPv6 アドレスにバインドされているからかもしれません。<code>listener.c</code> の <code>AF_UNSPEC</code> を <code>AF_INET</code> に変更して、強制的に IPv4 にすることを試してみてください。）</p>
<p>なるほど、それはちょっと楽しみですね。しかし、今度は同じネットワーク上にある隣のマシンで <code>listener</code> を起動して、それぞれのマシンに2つのコピーを作成し、ブロードキャストアドレスを指定して <code>broadcaster</code> を再度実行してみてください&mldr; おい！両方の <code>listener</code> がパケットを受け取るぞ！<code>sendto()</code> を一度しか呼んでいないのにな。かっこいい！</p>
<p>もし <code>listener</code> が、あなたが直接送ったデータを受け取って、ブロードキャストアドレスのデータを受け取らないなら、あなたのローカルマシンのファイアウォールがパケットをブロックしている可能性があります。（そうそう、Pat とBapper、これが私のサンプルコードが動作しない理由だと、私より先に気づいてくれてありがとうございます。ガイドの中で紹介すると言っておいたのに、こうして紹介してくれて。というわけで、にゃー。）</p>
<p>繰り返しになりますが、ブロードキャストパケットには注意が必要です。LAN 上のすべてのマシンが <code>recvfrom()</code> したかどうかに関わらず、そのパケットを処理しなければならないので、計算機ネットワーク全体にかなりの負荷を与える可能性があります。ブロードキャストパケットは控えめに、そして適切に使用されるべきものであることは間違いありません。</p>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
<div><a class="flex align-center" href=https://github.com/solareenlo/bgnet/commit/27d55f5a45fbc82fdc869f9cfbf1cc09d286dd2c title="Last modified by solareenlo | Jan 5, 2022" target=_blank rel=noopener>
<img src=/bgnet/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 5, 2022</span>
</a>
</div>
<div>
<a class="flex align-center" href=https://github.com/solareenlo/bgnet/edit/master/content/content/docs/slightly-advanced-techniques/_index.md target=_blank rel=noopener>
<img src=/bgnet/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span>
</a>
</div>
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#7-slightly-advanced-techniques>7 Slightly Advanced Techniques</a>
<ul>
<li><a href=#blocking>7.1 Blocking</a></li>
<li><a href=#poll>7.2 <code>poll()</code>&mdash;Synchronous I/O Multiplexing</a></li>
<li><a href=#select>7.3 <code>select()</code>&mdash;Synchronous I/O Multiplexing, Old School</a></li>
<li><a href=#sendall>7.4 Handling Partial <code>send()</code>s</a></li>
<li><a href=#serialization>7.5 Serialization&mdash;How to Pack Data</a></li>
<li><a href=#sonofdataencap>7.6 Son of Data Encapsulation</a></li>
<li><a href=#77-broadcast-packets---hello-world>7.7 Broadcast Packets&mdash;Hello, World!</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>