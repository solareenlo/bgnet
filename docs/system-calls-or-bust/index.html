<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="5 System Calls or Bust #  このセクションでは、Unix マシンのネットワーク機能にアクセスするためのシステムコールやその他のライブラリコールに触れることができますし、ソケット API をサポートしているあらゆるマシン (BSD, Windows, Linux, Mac, など) も同様です。これらの関数を呼び出すと、カーネルが引き継ぎ、すべての作業を自動で行ってくれます。
このあたりで多くの人がつまづくのは、これらのものをどのような順序で呼び出すかということです。これについては、皆さんもお分かりのように、man ページが役に立ちません。そこで、この恐ろしい状況を改善するために、以下の章のシステムコールを、あなたがプログラムの中で呼び出す必要があるのと全く（おおよそ）同じ順序で並べることにしました。
これに、あちこちにあるサンプルコード、ミルクとクッキー（自分で用意しなければならないのが怖い）、そして生粋のガッツと勇気があれば、ジョン・ポステルの息子のようにインターネット上でデータを発信することができるのです！
(なお、以下の多くのコードでは、簡潔にするため、必要なエラーチェックは行っていません。また、getaddrinfo() の呼び出しが成功し、リンクリストの有効なエントリを返すと仮定することが非常に一般的です。これらの状況はいずれもスタンドアロン・プログラムで適切に対処されているので、それらをモデルとして使用してください。)
5.1 getaddrinfo()&mdash;Prepare to launch! #  この関数は多くのオプションを持つ真の主力関数ですが、使い方はいたってシンプルです。後で必要な構造体をセットアップするのに役立ちます。
昔は、gethostbyname() という関数を使って DNS のルックアップを行っていました。そして、その情報を sockaddr_in 構造体に手作業でロードし、それを呼び出しに使用するのです。
これは、ありがたいことに、もう必要ありません。(IPv4 と IPv6 の両方で動作するコードを書きたいのであれば、望ましいことではありません！) 現代では、DNS やサービス名のルックアップなど、あらゆる種類の良いことをやってくれる getaddrinfo() という関数があり、さらに必要な struct も埋めてくれます！
それでは、ご覧ください！
#include <sys/types.h>#include <sys/socket.h>#include <netdb.h> int getaddrinfo(const char *node, // e.g. &#34;www.example.com&#34; or IP  const char *service, // e.g. &#34;http&#34; or port number  const struct addrinfo *hints, struct addrinfo **res); この関数に3つの入力パラメータを与えると、結果のリンクリストである res へのポインタが得られます。">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content="5 System Calls or Bust">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="https://solareenlo.com/bgnet/docs/system-calls-or-bust/">
<title>5 System Calls or Bust | Beej's Guide to Network Programming</title>
<link rel=manifest href=/bgnet/manifest.json>
<link rel=icon href=/bgnet/favicon.png type=image/x-icon>
<link rel=stylesheet href=/bgnet/book.min.7d12d4add234c27cb11a219e7b205a38bbfc902fc5f73a3417e46984bbc3fa91.css integrity="sha256-fRLUrdI0wnyxGiGeeyBaOLv8kC/F9zo0F+RphLvD+pE=" crossorigin=anonymous>
<script defer src=/bgnet/flexsearch.min.js></script>
<script defer src=/bgnet/en.search.min.8dae42eea6c990411c9826e44dff73b66d7575c531c49ac6b1e73d8a8ecf4e6f.js integrity="sha256-ja5C7qbJkEEcmCbkTf9ztm11dcUxxJrGsec9io7PTm8=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=https://solareenlo.com/bgnet/docs/system-calls-or-bust/index.xml title="Beej's Guide to Network Programming">
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/bgnet/><span>Beej's Guide to Network Programming</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li>
<a href=/bgnet/docs/intro><strong>1</strong> Intro</a>
<ul>
<li>
<a href=/bgnet/docs/intro/#11-audience><strong>1.1</strong> Audience</a></li>
<li>
<a href=/bgnet/docs/intro/#12-platform-and-compiler><strong>1.2</strong> Platform and Compiler</a></li>
<li>
<a href=/bgnet/docs/intro/#13-official-homepage-and-books-for-sale><strong>1.3</strong> Official Homepage and Books For Sale</a></li>
<li>
<a href=/bgnet/docs/intro/#solaris><strong>1.4</strong> Note for Solaris/SunOS Programmers</a></li>
<li>
<a href=/bgnet/docs/intro/#windows><strong>1.5</strong> Note for Windows Programmers</a></li>
<li>
<a href=/bgnet/docs/intro/#16-email-policy><strong>1.6</strong> Email Policy</a></li>
<li>
<a href=/bgnet/docs/intro/#17-mirroring><strong>1.7</strong> Mirroring</a></li>
<li>
<a href=/bgnet/docs/intro/#18-note-for-translators><strong>1.8</strong> Note for Translators</a></li>
<li>
<a href=/bgnet/docs/intro/#legal><strong>1.9</strong> Copyright, Distribution, and Legal</a></li>
<li>
<a href=/bgnet/docs/intro/#110-dedication><strong>1.10</strong> Dedication</a></li>
<li>
<a href=/bgnet/docs/intro/#111-publishing-information><strong>1.11</strong> Publishing Information</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/what-is-a-socket><strong>2</strong> What is a socket?</a>
<ul>
<li>
<a href=/bgnet/docs/what-is-a-socket/#21-two-types-of-internet-sockets><strong>2.1</strong> Two Types of Internet Sockets</a></li>
<li>
<a href=/bgnet/docs/what-is-a-socket/#lowlevel><strong>2.2</strong> Low level Nonsense and Network Theory</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging><strong>3</strong> IP Addresses, structs, and Data Munging</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#31-ip-addresses-versions-4-and-6><strong>3.1</strong> IP Addresses, versions 4 and 6</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#311-subnets><strong>3.1.1</strong> Subnets</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#312-port-numbers><strong>3.1.2</strong> Port Numbers</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#32-byte-order><strong>3.2</strong> Byte Order</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#structs><strong>3.3</strong> structs</a></li>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#34-ip-addresses-part-deux><strong>3.4</strong> IP Addresses, Part Deux</a>
<ul>
<li>
<a href=/bgnet/docs/ip-addresses-structs-and-data-munging/#341-private-or-disconnected-networks><strong>3.4.1</strong> Private (Or Disconnected) Networks</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=/bgnet/docs/jumping-from-ipv4-to-ipv6><strong>4</strong> Jumping from IPv4 to IPv6</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust><strong>5</strong> System Calls or Bust</a>
<ul>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#51-getaddrinfo---prepare-to-launch><strong>5.1</strong> getaddrinfo()—Prepare to launch!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#socket><strong>5.2</strong> socket()—Get the File Descriptor!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#bind><strong>5.3</strong> bind()—What port am I on?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#connect><strong>5.4</strong> connect()—Hey, you!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#listen><strong>5.5</strong> listen()—Will somebody please call me?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#56-accept---thank-you-for-calling-port-3490><strong>5.6</strong> accept()—“Thank you for calling port 3490.”</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#sendrecv><strong>5.7</strong> send() and recv()—Talk to me, baby!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#sendtorecv><strong>5.8</strong> sendto() and recvfrom()—Talk to me, DGRAM-style</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#59-close-and-shutdown---get-outta-my-face><strong>5.9</strong> close() and shutdown()—Get outta my face!</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#510-getpeername---who-are-you><strong>5.10</strong> getpeername()—Who are you?</a></li>
<li>
<a href=/bgnet/docs/system-calls-or-bust/#511-gethostname---who-am-i><strong>5.11</strong> gethostname()—Who am I?</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/client-server-background><strong>6</strong> Client-Server Background</a>
<ul>
<li>
<a href=/bgnet/docs/client-server-background/#61-a-simple-stream-server><strong>6.1</strong> A Simple Stream Server</a></li>
<li>
<a href=/bgnet/docs/client-server-background/#62-a-simple-stream-client><strong>6.2</strong> A Simple Stream Client</a></li>
<li>
<a href=/bgnet/docs/client-server-background/#datagram><strong>6.3</strong> Datagram Sockets</a></li>
</ul>
</li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques><strong>7</strong> Slightly Advanced Techniques</a>
<ul>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#blocking><strong>7.1</strong> Blocking</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#poll><strong>7.2</strong> poll()—Synchronous I/O Multiplexing</a></li>
<li>
<a href=/bgnet/docs/slightly-advanced-techniques/#select><strong>7.3</strong> select()—Synchronous I/O Multiplexing, Old School</a>
<br></li>
</ul>
</li>
</ul>
<ul>
<li>
<a href=https://github.com/solareenlo/bgnet target=_blank rel=noopener>
Github
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/bgnet/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>5 System Calls or Bust</strong>
<label for=toc-control>
<img src=/bgnet/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#5-system-calls-or-bust>5 System Calls or Bust</a>
<ul>
<li><a href=#51-getaddrinfo---prepare-to-launch>5.1 <code>getaddrinfo()</code>&mdash;Prepare to launch!</a></li>
<li><a href=#socket>5.2 <code>socket()</code>&mdash;Get the File Descriptor!</a></li>
<li><a href=#bind>5.3 <code>bind()</code>&mdash;What port am I on?</a></li>
<li><a href=#connect>5.4 <code>connect()</code>&mdash;Hey, you!</a></li>
<li><a href=#listen>5.5 <code>listen()</code>&mdash;Will somebody please call me?</a></li>
<li><a href=#56-accept---thank-you-for-calling-port-3490>5.6 <code>accept()</code>&mdash;&ldquo;Thank you for calling port 3490.&rdquo;</a></li>
<li><a href=#sendrecv>5.7 <code>send()</code> and <code>recv()</code>&mdash;Talk to me, baby!</a></li>
<li><a href=#sendtorecv>5.8 <code>sendto()</code> and <code>recvfrom()</code>&mdash;Talk to me, DGRAM-style</a></li>
<li><a href=#59-close-and-shutdown---get-outta-my-face>5.9 <code>close()</code> and <code>shutdown()</code>&mdash;Get outta my face!</a></li>
<li><a href=#510-getpeername---who-are-you>5.10 <code>getpeername()</code>&mdash;Who are you?</a></li>
<li><a href=#511-gethostname---who-am-i>5.11 <code>gethostname()</code>&mdash;Who am I?</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h1 id=5-system-calls-or-bust>
5 System Calls or Bust
<a class=anchor href=#5-system-calls-or-bust>#</a>
</h1>
<p>このセクションでは、Unix マシンのネットワーク機能にアクセスするためのシステムコールやその他のライブラリコールに触れることができますし、ソケット API をサポートしているあらゆるマシン (BSD, Windows, Linux, Mac, など) も同様です。これらの関数を呼び出すと、カーネルが引き継ぎ、すべての作業を自動で行ってくれます。</p>
<p>このあたりで多くの人がつまづくのは、これらのものをどのような順序で呼び出すかということです。これについては、皆さんもお分かりのように、<code>man</code> ページが役に立ちません。そこで、この恐ろしい状況を改善するために、以下の章のシステムコールを、あなたがプログラムの中で呼び出す必要があるのと全く（おおよそ）同じ順序で並べることにしました。</p>
<p>これに、あちこちにあるサンプルコード、ミルクとクッキー（自分で用意しなければならないのが怖い）、そして生粋のガッツと勇気があれば、ジョン・ポステルの息子のようにインターネット上でデータを発信することができるのです！</p>
<p>(なお、以下の多くのコードでは、簡潔にするため、必要なエラーチェックは行っていません。また、<code>getaddrinfo()</code> の呼び出しが成功し、リンクリストの有効なエントリを返すと仮定することが非常に一般的です。これらの状況はいずれもスタンドアロン・プログラムで適切に対処されているので、それらをモデルとして使用してください。)</p>
<h2 id=51-getaddrinfo---prepare-to-launch>
5.1 <code>getaddrinfo()</code>&mdash;Prepare to launch!
<a class=anchor href=#51-getaddrinfo---prepare-to-launch>#</a>
</h2>
<p>この関数は多くのオプションを持つ真の主力関数ですが、使い方はいたってシンプルです。後で必要な構造体をセットアップするのに役立ちます。</p>
<p>昔は、<code>gethostbyname()</code> という関数を使って DNS のルックアップを行っていました。そして、その情報を <code>sockaddr_in</code> 構造体に手作業でロードし、それを呼び出しに使用するのです。</p>
<p>これは、ありがたいことに、もう必要ありません。(IPv4 と IPv6 の両方で動作するコードを書きたいのであれば、望ましいことではありません！) 現代では、DNS やサービス名のルックアップなど、あらゆる種類の良いことをやってくれる <code>getaddrinfo()</code> という関数があり、さらに必要な <code>struct</code> も埋めてくれます！</p>
<p>それでは、ご覧ください！</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getaddrinfo</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>node,     <span style=color:#75715e>// e.g. &#34;www.example.com&#34; or IP
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>service,  <span style=color:#75715e>// e.g. &#34;http&#34; or port number
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> addrinfo <span style=color:#f92672>*</span>hints,
                <span style=color:#66d9ef>struct</span> addrinfo <span style=color:#f92672>**</span>res);
</code></pre></div><p>この関数に3つの入力パラメータを与えると、結果のリンクリストである <code>res</code> へのポインタが得られます。</p>
<p><code>node</code> パラメータには、接続先のホスト名、または IP アドレスを指定します。</p>
<p>次にパラメータ <code>service</code> ですが、これは &ldquo;80&rdquo; のようなポート番号か、&ldquo;http&rdquo;, &ldquo;ftp&rdquo;, &ldquo;telnet&rdquo;, &ldquo;smtp&rdquo; などの特定のサービスの名前（
<a href=https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml>IANAポートリスト</a>や Unix マシンの <code>/etc/services</code> ファイルで見つけることができます）であることができます。</p>
<p>最後に、<code>hints</code> パラメータは、関連情報をすでに記入した <code>addrinfo</code> 構造体を指します。</p>
<p>以下は、自分のホストの IP アドレス、ポート 3490 をリッスンしたいサーバの場合の呼び出し例です。これは実際にはリスニングやネットワークの設定を行っていないことに注意してください。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#66d9ef>int</span> status;
<span style=color:#66d9ef>struct</span> addrinfo hints;
<span style=color:#66d9ef>struct</span> addrinfo <span style=color:#f92672>*</span>servinfo;  <span style=color:#75715e>// will point to the results
</span><span style=color:#75715e></span>
memset(<span style=color:#f92672>&amp;</span>hints, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> hints); <span style=color:#75715e>// make sure the struct is empty
</span><span style=color:#75715e></span>hints.ai_family <span style=color:#f92672>=</span> AF_UNSPEC;     <span style=color:#75715e>// don&#39;t care IPv4 or IPv6
</span><span style=color:#75715e></span>hints.ai_socktype <span style=color:#f92672>=</span> SOCK_STREAM; <span style=color:#75715e>// TCP stream sockets
</span><span style=color:#75715e></span>hints.ai_flags <span style=color:#f92672>=</span> AI_PASSIVE;     <span style=color:#75715e>// fill in my IP for me
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>if</span> ((status <span style=color:#f92672>=</span> getaddrinfo(NULL, <span style=color:#e6db74>&#34;3490&#34;</span>, <span style=color:#f92672>&amp;</span>hints, <span style=color:#f92672>&amp;</span>servinfo)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
    fprintf(stderr, <span style=color:#e6db74>&#34;getaddrinfo error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, gai_strerror(status));
    exit(<span style=color:#ae81ff>1</span>);
}

<span style=color:#75715e>// servinfo now points to a linked list of 1 or more struct addrinfos
</span><span style=color:#75715e></span>
<span style=color:#75715e>// ... do everything until you don&#39;t need servinfo anymore ....
</span><span style=color:#75715e></span>
freeaddrinfo(servinfo); <span style=color:#75715e>// free the linked-list
</span></code></pre></div><p><code>ai_family</code> を <code>AF_UNSPEC</code> に設定することで、IPv4 や IPv6 を使うかどうかを気にしないことを表明していることに注意してください。もし、どちらか一方だけを使いたい場合は、<code>AF_INET</code> または <code>AF_INET6</code> に設定することができます。</p>
<p>また、<code>AI_PASSIVE</code> フラグがあるのがわかると思いますが、これは <code>getaddrinfo()</code> にローカルホストのアドレスをソケット構造体に割り当てるように指示しています。これは、ハードコードする必要がないのがいいところです。(あるいは、<code>getaddrinfo()</code> の最初のパラメータとして特定のアドレスを入れることもできます。私は現在 <code>NULL</code> を持っています。)</p>
<p>そして、呼び出しを行います。エラー(<code>getaddrinfo()</code> が0以外を返す)があれば、ご覧のように関数 <code>gai_strerror()</code> を使ってそれを表示することができます。しかし、すべてがうまくいけば、<code>servinfo</code> は <code>struct addrinfos</code> のリンクリストを指し、それぞれのリストには後で使用できる何らかの <code>sockaddr</code> 構造体が含まれています！素晴らしい！</p>
<p>最後に、<code>getaddrinfo()</code> が快く割り当ててくれたリンクリストをすべて使い終わったら、<code>freeaddrinfo()</code> を呼び出してすべてを解放することができます(そうすべき)です。</p>
<p>ここでは、クライアントが特定のサーバ、例えば &ldquo;
<a href=http://www.example.net>www.example.net</a>&rdquo; ポート 3490 に接続したい場合のサンプルコールを紹介します。繰り返しますが、これは実際には接続しませんが、後で使用する構造をセットアップしています。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#66d9ef>int</span> status;
<span style=color:#66d9ef>struct</span> addrinfo hints;
<span style=color:#66d9ef>struct</span> addrinfo <span style=color:#f92672>*</span>servinfo;  <span style=color:#75715e>// will point to the results
</span><span style=color:#75715e></span>
memset(<span style=color:#f92672>&amp;</span>hints, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> hints); <span style=color:#75715e>// make sure the struct is empty
</span><span style=color:#75715e></span>hints.ai_family <span style=color:#f92672>=</span> AF_UNSPEC;     <span style=color:#75715e>// don&#39;t care IPv4 or IPv6
</span><span style=color:#75715e></span>hints.ai_socktype <span style=color:#f92672>=</span> SOCK_STREAM; <span style=color:#75715e>// TCP stream sockets
</span><span style=color:#75715e></span>
<span style=color:#75715e>// get ready to connect
</span><span style=color:#75715e></span>status <span style=color:#f92672>=</span> getaddrinfo(<span style=color:#e6db74>&#34;www.example.net&#34;</span>, <span style=color:#e6db74>&#34;3490&#34;</span>, <span style=color:#f92672>&amp;</span>hints, <span style=color:#f92672>&amp;</span>servinfo);

<span style=color:#75715e>// servinfo now points to a linked list of 1 or more struct addrinfos
</span><span style=color:#75715e></span>
<span style=color:#75715e>// etc.
</span></code></pre></div><p><code>servinfo</code> は、あらゆるアドレス情報を持つリンクリストだと言い続けています。この情報を披露するために、簡単なデモプログラムを書いてみよう。
<a href=https://beej.us/guide/bgnet/examples/showip.c>この短いプログラム</a>は、コマンドラインで指定された任意のホストの IP アドレスを表示します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#75715e>/*
</span><span style=color:#75715e>** showip.c -- show IP addresses for a host given on the command line
</span><span style=color:#75715e>*/</span>

<span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
{
    <span style=color:#66d9ef>struct</span> addrinfo hints, <span style=color:#f92672>*</span>res, <span style=color:#f92672>*</span>p;
    <span style=color:#66d9ef>int</span> status;
    <span style=color:#66d9ef>char</span> ipstr[INET6_ADDRSTRLEN];

    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>) {
        fprintf(stderr,<span style=color:#e6db74>&#34;usage: showip hostname</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
    }

    memset(<span style=color:#f92672>&amp;</span>hints, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> hints);
    hints.ai_family <span style=color:#f92672>=</span> AF_UNSPEC; <span style=color:#75715e>// AF_INET or AF_INET6 to force version
</span><span style=color:#75715e></span>    hints.ai_socktype <span style=color:#f92672>=</span> SOCK_STREAM;

    <span style=color:#66d9ef>if</span> ((status <span style=color:#f92672>=</span> getaddrinfo(argv[<span style=color:#ae81ff>1</span>], NULL, <span style=color:#f92672>&amp;</span>hints, <span style=color:#f92672>&amp;</span>res)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
        fprintf(stderr, <span style=color:#e6db74>&#34;getaddrinfo: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, gai_strerror(status));
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
    }

    printf(<span style=color:#e6db74>&#34;IP addresses for %s:</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>1</span>]);

    <span style=color:#66d9ef>for</span>(p <span style=color:#f92672>=</span> res;p <span style=color:#f92672>!=</span> NULL; p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>ai_next) {
        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr;
        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>ipver;

        <span style=color:#75715e>// get the pointer to the address itself,
</span><span style=color:#75715e></span>        <span style=color:#75715e>// different fields in IPv4 and IPv6:
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (p<span style=color:#f92672>-&gt;</span>ai_family <span style=color:#f92672>==</span> AF_INET) { <span style=color:#75715e>// IPv4
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>ipv4 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>)p<span style=color:#f92672>-&gt;</span>ai_addr;
            addr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>(ipv4<span style=color:#f92672>-&gt;</span>sin_addr);
            ipver <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;IPv4&#34;</span>;
        } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// IPv6
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>struct</span> sockaddr_in6 <span style=color:#f92672>*</span>ipv6 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> sockaddr_in6 <span style=color:#f92672>*</span>)p<span style=color:#f92672>-&gt;</span>ai_addr;
            addr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>(ipv6<span style=color:#f92672>-&gt;</span>sin6_addr);
            ipver <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;IPv6&#34;</span>;
        }

        <span style=color:#75715e>// convert the IP to a string and print it:
</span><span style=color:#75715e></span>        inet_ntop(p<span style=color:#f92672>-&gt;</span>ai_family, addr, ipstr, <span style=color:#66d9ef>sizeof</span> ipstr);
        printf(<span style=color:#e6db74>&#34;  %s: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ipver, ipstr);
    }

    freeaddrinfo(res); <span style=color:#75715e>// free the linked list
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>ご覧のように、このコードはコマンドラインで渡されたものに対して <code>getaddrinfo()</code> を呼び出し、<code>res</code> が指すリンクリストを埋めて、そのリストを繰り返し表示して何かを出力したりすることができます。</p>
<p>(そこには、IP バージョンによって異なるタイプの <code>struct sockaddrs</code> を掘り下げなければならない、ちょっとした醜さがあります。申し訳ありません。他にいい方法はないかなぁ&mldr;)</p>
<p>サンプル走行！みんな大好きスクリーンショット。</p>
<pre tabindex=0><code>$ showip www.example.net
IP addresses for www.example.net:

  IPv4: 192.0.2.88

$ showip ipv6.example.com
IP addresses for ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171
</code></pre><p>これで、<code>getaddrinfo()</code> の結果を他のソケット関数に渡して、ついにネットワーク接続を確立することができます。引き続きお読みください。</p>
<h2 id=socket>
5.2 <code>socket()</code>&mdash;Get the File Descriptor!
<a class=anchor href=#socket>#</a>
</h2>
<p>もう先延ばしにはできません。<code>socket()</code> システムコールの話をしなければならないのです。以下はその内訳です。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>socket</span>(<span style=color:#66d9ef>int</span> domain, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol);
</code></pre></div><p>しかし、これらの引数は何なのでしょうか？これらは、どのようなソケットが欲しいか（IPv4 か IPv6 か、ストリームかデータグラムか、TCP か UDP か）を指定することができます。</p>
<p>以前は、これらの値をハードコードする人がいましたが、今でも絶対にそうすることができます。(ドメインは <code>PF_INET</code> または <code>PF_INET6</code>、タイプは <code>SOCK_STREAM</code> または <code>SOCK_DGRAM</code>、プロトコルは <code>0</code> に設定すると、与えられたタイプに適したプロトコルを選択することができます。あるいは <code>getprotobyname()</code> を呼んで、&ldquo;tcp&rdquo; や &ldquo;udp&rdquo; などの欲しいプロトコルを調べることもできます。)</p>
<p>(この <code>PF_INET</code> は、<code>struct sockaddr_in</code> の <code>sin_family</code> フィールドを初期化するときに使用できる <code>AF_INET</code> の近縁種です。実際、両者は非常に密接な関係にあり、実際に同じ値を持っているので、多くのプログラマは <code>socket()</code> を呼び出して <code>PF_INET</code> の代わりに <code>AF_INET</code> を第一引数に渡しています。さて、ミルクとクッキーを用意して、お話の時間です。昔々、あるアドレスファミリ(<code>AF_INET</code> の AF)が、プロトコルファミリ(<code>PF_INET</code> の PF)で参照される複数のプロトコルをサポートするかもしれないと考えられたことがあります。しかし、そうはなりませんでした。そして、みんな幸せに暮らした、ザ・エンド。というわけで、最も正しいのは <code>struct sockaddr_in</code> で <code>AF_INET</code> を使い、<code>socket()</code> の呼び出しで <code>PF_INET</code> を使うことです。)</p>
<p>とにかく、もう十分です。本当にやりたいことは、<code>getaddrinfo()</code> の呼び出しの結果の値を使い、以下のように直接 <code>socket()</code> に送り込むことです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#66d9ef>int</span> s;
<span style=color:#66d9ef>struct</span> addrinfo hints, <span style=color:#f92672>*</span>res;

<span style=color:#75715e>// do the lookup
</span><span style=color:#75715e>// [pretend we already filled out the &#34;hints&#34; struct]
</span><span style=color:#75715e></span>getaddrinfo(<span style=color:#e6db74>&#34;www.example.com&#34;</span>, <span style=color:#e6db74>&#34;http&#34;</span>, <span style=color:#f92672>&amp;</span>hints, <span style=color:#f92672>&amp;</span>res);

<span style=color:#75715e>// again, you should do error-checking on getaddrinfo(), and walk
</span><span style=color:#75715e>// the &#34;res&#34; linked list looking for valid entries instead of just
</span><span style=color:#75715e>// assuming the first one is good (like many of these examples do).
</span><span style=color:#75715e>// See the section on client/server for real examples.
</span><span style=color:#75715e></span>
s <span style=color:#f92672>=</span> socket(res<span style=color:#f92672>-&gt;</span>ai_family, res<span style=color:#f92672>-&gt;</span>ai_socktype, res<span style=color:#f92672>-&gt;</span>ai_protocol);
</code></pre></div><p><code>socket()</code> は単に、後のシステムコールで使用できるソケットディスクリプタを返すか、エラーの場合は <code>-1</code> を返します。グローバル変数 <code>errno</code> にはエラーの値が設定されます (詳細については [<code>errno</code>(#errnoman) のマニュアルページを参照してください。また、マルチスレッドプログラムで <code>errno</code> を使用する際の簡単な注意も参照してください)。</p>
<p>でも、このソケットは何の役に立つのでしょうか？答えは、これだけでは本当に意味がなく、もっと読み進めてシステムコールを作らないと意味がないのです。</p>
<h2 id=bind>
5.3 <code>bind()</code>&mdash;What port am I on?
<a class=anchor href=#bind>#</a>
</h2>
<p>ソケットを取得したら、そのソケットをローカルマシンのポートに関連付ける必要があるかもしれません。(これは、特定のポートへの接続を <code>listen()</code> する場合によく行われます。多人数参加型ネットワークゲームで &ldquo;192.168.5.10 ポート 3490 に接続&rdquo; と指示されたときに行います)。ポート番号はカーネルが受信パケットを特定のプロセスのソケットディスクリプタにマッチさせるために使用されます。もしあなたが <code>connect()</code> を行うだけなら(あなたはクライアントであり、サーバではないので)、これはおそらく不要でしょう。とにかく読んでみてください。</p>
<p><code>bind()</code> システムコールの概要は以下のとおりです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>my_addr, <span style=color:#66d9ef>int</span> addrlen);
</code></pre></div><p><code>sockfd</code> は <code>socket()</code> が返すソケットファイル記述子です。<code>my_addr</code> は自分のアドレスに関する情報、すなわちポートおよび IP アドレスを含む <code>sockaddr</code> 構造体へのポインタです。</p>
<p>ふぅー。一度に吸収するのはちょっと無理があるな。ソケットをプログラムが実行されているホスト、ポート 3490 にバインドする例を見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#66d9ef>struct</span> addrinfo hints, <span style=color:#f92672>*</span>res;
<span style=color:#66d9ef>int</span> sockfd;

<span style=color:#75715e>// first, load up address structs with getaddrinfo():
</span><span style=color:#75715e></span>
memset(<span style=color:#f92672>&amp;</span>hints, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> hints);
hints.ai_family <span style=color:#f92672>=</span> AF_UNSPEC;  <span style=color:#75715e>// use IPv4 or IPv6, whichever
</span><span style=color:#75715e></span>hints.ai_socktype <span style=color:#f92672>=</span> SOCK_STREAM;
hints.ai_flags <span style=color:#f92672>=</span> AI_PASSIVE;     <span style=color:#75715e>// fill in my IP for me
</span><span style=color:#75715e></span>
getaddrinfo(NULL, <span style=color:#e6db74>&#34;3490&#34;</span>, <span style=color:#f92672>&amp;</span>hints, <span style=color:#f92672>&amp;</span>res);

<span style=color:#75715e>// make a socket:
</span><span style=color:#75715e></span>
sockfd <span style=color:#f92672>=</span> socket(res<span style=color:#f92672>-&gt;</span>ai_family, res<span style=color:#f92672>-&gt;</span>ai_socktype, res<span style=color:#f92672>-&gt;</span>ai_protocol);

<span style=color:#75715e>// bind it to the port we passed in to getaddrinfo():
</span><span style=color:#75715e></span>
bind(sockfd, res<span style=color:#f92672>-&gt;</span>ai_addr, res<span style=color:#f92672>-&gt;</span>ai_addrlen);
</code></pre></div><p><code>AI_PASSIVE</code> フラグを使うことで、プログラムが動作しているホストの IP にバインドするように指示しているのです。もし、特定のローカル IP アドレスにバインドしたい場合は、<code>AI_PASSIVE</code> を削除して、<code>getaddrinfo()</code> の最初の引数に IP アドレスを入れてください。</p>
<p><code>bind()</code> もエラー時には <code>-1</code> を返し、<code>errno</code> にエラーの値を設定します。</p>
<p>多くの古いコードでは、<code>bind()</code> を呼び出す前に、<code>struct sockaddr_in</code> を手動でパックしています。これは明らかに IPv4 特有のものですが、IPv6 で同じことをするのを止めるものは何もありません。ただし、一般的には <code>getaddrinfo()</code> を使う方が簡単になりそうです。とにかく、古いコードは次のようなものです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#75715e>// !!! THIS IS THE OLD WAY !!!
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> sockfd;
<span style=color:#66d9ef>struct</span> sockaddr_in my_addr;

sockfd <span style=color:#f92672>=</span> socket(PF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);

my_addr.sin_family <span style=color:#f92672>=</span> AF_INET;
my_addr.sin_port <span style=color:#f92672>=</span> htons(MYPORT);     <span style=color:#75715e>// short, network byte order
</span><span style=color:#75715e></span>my_addr.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(<span style=color:#e6db74>&#34;10.12.110.57&#34;</span>);
memset(my_addr.sin_zero, <span style=color:#e6db74>&#39;\0&#39;</span>, <span style=color:#66d9ef>sizeof</span> my_addr.sin_zero);

bind(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>my_addr, <span style=color:#66d9ef>sizeof</span> my_addr);
</code></pre></div><p>上記のコードでは、ローカルの IP アドレスにバインドしたい場合、<code>s_addr</code> フィールドに <code>INADDR_ANY</code> を代入することもできます（上記の <code>AI_PASSIVE</code> フラグのようなものです）。<code>INADDR_ANY</code> の IPv6 バージョンはグローバル変数 <code>in6addr_any</code> で、<code>struct sockaddr_in6</code> の <code>sin6_addr</code> フィールドに代入されます。(変数の初期化で使用できるマクロ <code>IN6ADDR_ANY_INIT</code> も存在します。)また、<code>IN6ADDR_ANY_INIT</code> を使用することで、IPv6 の IP アドレスにバインドできます。</p>
<p><code>bind()</code> を呼ぶときにもうひとつ気をつけなければならないのは、ポート番号で下手を打たないことです。1024 以下のポートはすべて予約済みです(あなたがスーパーユーザでない限り)！それ以上のポート番号は、(他のプログラムによってすでに使われていなければ) 65535 までの任意のポート番号を使用することができます。</p>
<p>時々、サーバを再実行しようとすると、<code>bind()</code> が &ldquo;Address already in use&rdquo; と言って失敗することに気がつくかもしれません。これはどういうことでしょう? それは、接続されたソケットの一部がまだカーネル内に残っていて、ポートを占有しているのです。それが消えるのを待つか(1分くらい)、次のようにポートが再利用できるようなコードをプログラムに追加します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#66d9ef>int</span> yes<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
<span style=color:#75715e>//char yes=&#39;1&#39;; // Solaris people use this
</span><span style=color:#75715e></span>
<span style=color:#75715e>// lose the pesky &#34;Address already in use&#34; error message
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,<span style=color:#f92672>&amp;</span>yes,<span style=color:#66d9ef>sizeof</span> yes) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
    perror(<span style=color:#e6db74>&#34;setsockopt&#34;</span>);
    exit(<span style=color:#ae81ff>1</span>);
}
</code></pre></div><p><code>bind()</code> について、最後にちょっとした注意点があります。<code>bind()</code> を絶対に呼び出す必要がない場合があります。リモートマシンに <code>connect()</code> する際に、ローカルポートを気にしない場合 (telnet のようにリモートポートを気にする場合) は、単に <code>connect()</code> をコールすれば、ソケットが未束縛かどうかをチェックし、必要なら未使用のローカルポートに <code>bind()</code> してくれます。</p>
<h2 id=connect>
5.4 <code>connect()</code>&mdash;Hey, you!
<a class=anchor href=#connect>#</a>
</h2>
<p>ちょっとだけ、あなたが telnet アプリケーションであることを仮定してみましょう。ユーザが（映画 TRON のように）ソケットファイル記述子を取得するように命令します。あなたはそれに応じ、<code>socket()</code> を呼び出します。次に、ユーザはポート &ldquo;<code>23</code>&rdquo; (標準的な telnet ポート) で &ldquo;<code>10.12.110.57</code>&rdquo; に接続するように指示します。やったー! どうするんだ？</p>
<p>幸運なことに、あなたは今、<code>connect()</code>の章&mdash;リモートホストに接続する方法を読んでいるところです。だから、猛烈に読み進めよう！時間がない！</p>
<p><code>connect()</code>の呼び出しは以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>connect</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>serv_addr, <span style=color:#66d9ef>int</span> addrlen);
</code></pre></div><p><code>sockfd</code> は <code>socket()</code> コールで返される、我々の身近なソケットファイル記述子、<code>serv_addr</code> は宛先ポートと IP アドレスを含む <code>struct sockaddr</code>、<code>addrlen</code> はサーバアドレス構造体のバイト長です。</p>
<p>これらの情報はすべて、<code>getaddrinfo()</code> の呼び出しの結果から得ることができ、これはロックします。</p>
<p>だんだん分かってきたかな？ここからは聞こえないので、そうであることを祈るしかないですね。ポート <code>3490</code> の &ldquo;<code>www.example.com</code>&rdquo; にソケット接続する例を見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#66d9ef>struct</span> addrinfo hints, <span style=color:#f92672>*</span>res;
<span style=color:#66d9ef>int</span> sockfd;

<span style=color:#75715e>// first, load up address structs with getaddrinfo():
</span><span style=color:#75715e></span>
memset(<span style=color:#f92672>&amp;</span>hints, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> hints);
hints.ai_family <span style=color:#f92672>=</span> AF_UNSPEC;
hints.ai_socktype <span style=color:#f92672>=</span> SOCK_STREAM;

getaddrinfo(<span style=color:#e6db74>&#34;www.example.com&#34;</span>, <span style=color:#e6db74>&#34;3490&#34;</span>, <span style=color:#f92672>&amp;</span>hints, <span style=color:#f92672>&amp;</span>res);

<span style=color:#75715e>// make a socket:
</span><span style=color:#75715e></span>
sockfd <span style=color:#f92672>=</span> socket(res<span style=color:#f92672>-&gt;</span>ai_family, res<span style=color:#f92672>-&gt;</span>ai_socktype, res<span style=color:#f92672>-&gt;</span>ai_protocol);

<span style=color:#75715e>// connect!
</span><span style=color:#75715e></span>
connect(sockfd, res<span style=color:#f92672>-&gt;</span>ai_addr, res<span style=color:#f92672>-&gt;</span>ai_addrlen);
</code></pre></div><p>繰り返しになりますが、古いタイプのプログラムでは、独自の <code>struct sockaddr_ins</code> を作成して <code>connect()</code> に渡していました。必要であれば、そうすることができます。上の
<a href=/bgnet/docs/system-calls-or-bust/#bind><code>bind()</code></a> の節で同様のことを書いています。</p>
<p><code>connect()</code> の戻り値を必ず確認してください。エラー時に <code>-1</code> が返され、<code>errno</code> という変数がセットされます。</p>
<p>また、<code>bind()</code> を呼んでいないことに注意してください。基本的に、私たちはローカルのポート番号には関心がありません。カーネルは私たちのためにローカルポートを選択し、接続先のサイトは自動的にこの情報を取得します。心配はいりません。</p>
<h2 id=listen>
5.5 <code>listen()</code>&mdash;Will somebody please call me?
<a class=anchor href=#listen>#</a>
</h2>
<p>よし、気分転換の時間です。リモートホストに接続したくない場合はどうすればいいのでしょう。例えば、接続が来るのを待ち、何らかの方法でそれを処理したいとします。この処理は2段階です。まず <code>listen()</code> を行い、次に <code>accept()</code> を行います (後述)。</p>
<p><code>listen()</code> の呼び出しはかなり単純ですが、少し説明が必要です。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>listen</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>int</span> backlog);
</code></pre></div><p><code>sockfd</code> は <code>socket()</code> システムコールから得られる通常のソケットファイル記述子です。これはどういう意味でしょうか？着信した接続は、<code>accept()</code> (後述) するまでこのキューで待機することになりますが、このキューに入れることができる数の上限を表しているのです。ほとんどのシステムでは、この数を黙って約 20 に制限しています。おそらく、<code>5</code> や <code>10</code> に設定しても大丈夫でしょう。</p>
<p>ここでも、いつものように <code>listen()</code> はエラー時に <code>-1</code> を返し、<code>errno</code> をセットします。</p>
<p>さて、想像がつくと思いますが、サーバが特定のポートで動作するように <code>listen()</code> を呼び出す前に <code>bind()</code> を呼び出す必要があります。(どのポートに接続するかを仲間に伝えることができなければなりません！) ですから、もし接続を待ち受けるのであれば、一連のシステムコールは次のようになります。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c>getaddrinfo();
socket();
bind();
listen();
<span style=color:#75715e>/* accept() goes here */</span>
</code></pre></div><p>かなり自明なので、サンプルコードの代わりに置いておきます。(以下の <code>accept()</code> 章のコードはより完全なものです。) この全体の中で本当に厄介なのは、<code>accept()</code> の呼び出しです。</p>
<h2 id=56-accept---thank-you-for-calling-port-3490>
5.6 <code>accept()</code>&mdash;&ldquo;Thank you for calling port 3490.&rdquo;
<a class=anchor href=#56-accept---thank-you-for-calling-port-3490>#</a>
</h2>
<p><code>accept()</code> の呼び出しはちょっと変です。これから起こることはこうです。遠く離れた誰かが、あなたが <code>listen()</code> しているポートであなたのマシンに <code>connect()</code> しようとするでしょう。その接続は、<code>accept()</code> されるのを待つためにキューに入れられることになります。あなたは <code>accept()</code> をコールし、保留中の接続を取得するように指示します。すると、この接続に使用する新しいソケットファイル記述子が返されます！そうです、1つの値段で2つのソケットファイル記述子を手に入れたことになります。元のソケットファイル記述子はまだ新しい接続を待ち続けており、新しく作成されたソケットファイル記述子はようやく <code>send()</code> と <code>recv()</code> を行う準備が整いました。着いたぞ！</p>
<p>コールは以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>accept</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>addr, socklen_t <span style=color:#f92672>*</span>addrlen);
</code></pre></div><p><code>sockfd</code> は <code>listen()</code> するソケットディスクリプタです。<code>addr</code> は通常、ローカルの<code>struct sockaddr_storage</code> へのポインタになります。この構造体には、着信接続に関する情報が格納されます(これにより、どのホストがどのポートから電話をかけてきたかを判断することができます)。<code>addrlen</code> はローカルの整数型変数で、そのアドレスが <code>accept()</code> に渡される前に <code>sizeof(struct sockaddr_storage)</code> に設定されなければなりません。<code>accept()</code> は、<code>addr</code> にそれ以上のバイト数を入れることはありません。もし、それ以下のバイト数であれば、<code>addrlen</code> の値を変更します。</p>
<p>何だと思いますか？<code>accept()</code> はエラーが発生した場合は <code>-1</code> を返し、<code>errno</code> をセットします。そうだったんですか。</p>
<p>前回と同様、一度に吸収するのは大変なので、サンプルコードの一部をご覧ください。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define MYPORT &#34;3490&#34;  </span><span style=color:#75715e>// the port users will be connecting to
</span><span style=color:#75715e></span><span style=color:#75715e>#define BACKLOG 10     </span><span style=color:#75715e>// how many pending connections queue will hold
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>struct</span> sockaddr_storage their_addr;
    socklen_t addr_size;
    <span style=color:#66d9ef>struct</span> addrinfo hints, <span style=color:#f92672>*</span>res;
    <span style=color:#66d9ef>int</span> sockfd, new_fd;

    <span style=color:#75715e>// !! don&#39;t forget your error checking for these calls !!
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// first, load up address structs with getaddrinfo():
</span><span style=color:#75715e></span>
    memset(<span style=color:#f92672>&amp;</span>hints, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> hints);
    hints.ai_family <span style=color:#f92672>=</span> AF_UNSPEC;  <span style=color:#75715e>// use IPv4 or IPv6, whichever
</span><span style=color:#75715e></span>    hints.ai_socktype <span style=color:#f92672>=</span> SOCK_STREAM;
    hints.ai_flags <span style=color:#f92672>=</span> AI_PASSIVE;     <span style=color:#75715e>// fill in my IP for me
</span><span style=color:#75715e></span>
    getaddrinfo(NULL, MYPORT, <span style=color:#f92672>&amp;</span>hints, <span style=color:#f92672>&amp;</span>res);

    <span style=color:#75715e>// make a socket, bind it, and listen on it:
</span><span style=color:#75715e></span>
    sockfd <span style=color:#f92672>=</span> socket(res<span style=color:#f92672>-&gt;</span>ai_family, res<span style=color:#f92672>-&gt;</span>ai_socktype, res<span style=color:#f92672>-&gt;</span>ai_protocol);
    bind(sockfd, res<span style=color:#f92672>-&gt;</span>ai_addr, res<span style=color:#f92672>-&gt;</span>ai_addrlen);
    listen(sockfd, BACKLOG);

    <span style=color:#75715e>// now accept an incoming connection:
</span><span style=color:#75715e></span>
    addr_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span> their_addr;
    new_fd <span style=color:#f92672>=</span> accept(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>their_addr, <span style=color:#f92672>&amp;</span>addr_size);

    <span style=color:#75715e>// ready to communicate on socket descriptor new_fd!
</span><span style=color:#75715e></span>    .
    .
    .
</code></pre></div><p>ここでも、すべての <code>send()</code> と <code>recv()</code> の呼び出しに、ソケットディスクリプタ <code>new_fd</code> を使用することに注意してください。もし、一度しか接続がないのであれば、同じポートからの接続を防ぐために、<code>listen</code> している <code>sockfd</code> を <code>close()</code> することができます。</p>
<h2 id=sendrecv>
5.7 <code>send()</code> and <code>recv()</code>&mdash;Talk to me, baby!
<a class=anchor href=#sendrecv>#</a>
</h2>
<p>この2つの関数は、ストリームソケットまたは接続されたデータグラムソケットで通信を行うためのものです。通常の非接続型データグラムソケットを使いたい場合は、以下の
<a href=/bgnet/docs/system-calls-or-bust/#sendtorecv><code>sendto()</code> and <code>recvfrom()</code></a> の節を参照する必要があります。</p>
<p><code>send()</code> 呼び出し。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>send</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>msg, <span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>int</span> flags);
</code></pre></div><p><code>sockfd</code> はデータを送信したいソケットディスクリプタ（<code>socket()</code> で返されたものでも <code>accept()</code> で取得したものでも可）、<code>msg</code> は送信したいデータへのポインタ、<code>len</code> はそのデータの長さ(バイト数)です。<code>flags</code> を <code>0</code> に設定するだけです(フラグに関する詳しい情報は <code>send()</code> の man ページを参照してください)。</p>
<p>サンプルコードとしては、以下のようなものがあります。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-{.c data-lang={.c><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>msg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Beej was here!&#34;</span>;
<span style=color:#66d9ef>int</span> len, bytes_sent;
.
.
.
len <span style=color:#f92672>=</span> strlen(msg);
bytes_sent <span style=color:#f92672>=</span> send(sockfd, msg, len, <span style=color:#ae81ff>0</span>);
.
.
.
</code></pre></div><p><code>send()</code> は実際に送信されたバイト数を返しますが、これは送信するように指示した数よりも少ないかもしれません！つまり、大量のデータを送信するように指示しても、それが処理しきれないことがあるのです。その場合、できる限りのデータを送信し、残りは後で送信するように指示します。<code>send()</code> が返す値が <code>len</code> の値と一致しない場合、残りの文字列を送信するかどうかはあなた次第だということを覚えておいてください。良いニュースはこれです。パケットが小さければ（1K以下とか）、 おそらく全部を一度に送信することができるでしょう。ここでも、エラー時には <code>-1</code> が返され、 <code>errno</code> にはエラー番号がセットされます。</p>
<p><code>recv()</code> 呼び出しは、多くの点で類似しています。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>recv</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>int</span> flags);
</code></pre></div><p><code>sockfd</code> は読み込むソケットディスクリプタ、<code>buf</code> は情報を読み込むバッファ、<code>len</code> はバッファの最大長、<code>flags</code> は再び <code>0</code> に設定できます(フラグについては <code>recv()</code> の man ページを参照してください)。</p>
<p><code>recv()</code> は、実際にバッファに読み込まれたバイト数を返し、エラーの場合は <code>-1</code> を返します（それに応じて <code>errno</code> が設定されます）。</p>
<p>待ってください！<code>recv()</code> は <code>0</code> を返すことがあります。これは、リモート側が接続を切断したことを意味します！<code>0</code> という返り値は、<code>recv()</code> がこのような事態が発生したことをあなたに知らせるためのものです。</p>
<p>ほら、簡単だったでしょう？これでストリームソケットでデータのやり取りができるようになったぞ。やったー！あなたは Unix ネットワークプログラマーです！</p>
<h2 id=sendtorecv>
5.8 <code>sendto()</code> and <code>recvfrom()</code>&mdash;Talk to me, DGRAM-style
<a class=anchor href=#sendtorecv>#</a>
</h2>
<p>&ldquo;これはすべて素晴らしく、ダンディーだ&rdquo;、&ldquo;しかし、データグラムソケットを接続しないままにしておくのはどうなんだ？"、という声が聞こえてきそうです。大丈夫だ、アミーゴ。ちょうどいいものがありますよ。</p>
<p>データグラムソケットはリモートホストに接続されていないので、パケットを送信する前にどのような情報を与える必要があるか分かりますか？そうです！宛先アドレスです！これがそのスコープです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sendto</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>msg, <span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flags,
           <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>to, socklen_t tolen);
</code></pre></div><p>見ての通り、この呼び出しは基本的に <code>send()</code> の呼び出しと同じで、他に2つの情報が追加されています。<code>to</code> は <code>struct sockaddr</code> へのポインタで（おそらく直前にキャストした別の <code>struct sockaddr_in</code> や <code>struct sockaddr_in6</code>、<code>struct sockaddr_storage</code> になるでしょう）、送信先の IP アドレスとポートが含まれています。<code>tolen</code> は <code>int</code> 型ですが、単純に <code>sizeof *to</code> または <code>sizeof(struct sockaddr_storage)</code> に設定することができます。</p>
<p>宛先アドレスの構造体を手に入れるには、<code>getaddrinfo()</code> や以下の <code>recvfrom()</code> から取得するか、手で記入することになると思います。</p>
<p><code>send()</code> と同様、<code>sendto()</code> は実際に送信したバイト数 (これも、送信するように指示したバイト数よりも少ないかもしれません！) を返し、エラーの場合は <code>-1</code> を返します。</p>
<p>同様に、<code>recv()</code> と <code>recvfrom()</code> も類似しています。<code>recvfrom()</code> の概要は以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>recvfrom</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flags,
             <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>from, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>fromlen);
</code></pre></div><p>これも <code>recv()</code> と同様であるが、いくつかのフィールドが追加されています。<code>from</code> はローカルの <code>struct sockaddr_storage</code> へのポインタで、送信元のマシンの IP アドレスとポートが格納されます。<code>fromlen</code> はローカルの <code>int</code> へのポインタであり、<code>sizeof *from</code> または <code>sizeof(struct sockaddr_storage)</code> に初期化する必要があります。この関数が戻ったとき、<code>fromlen</code> は実際に <code>from</code> に格納されたアドレスの長さを含みます。</p>
<p><code>recvfrom()</code> は受信したバイト数を返し、エラーの場合は <code>-1</code> を返します（<code>errno</code> はそれに応じて設定されます）。</p>
<p>そこで質問ですが、なぜソケットの型として <code>struct sockaddr_storage</code> を使うのでしょうか？なぜ、<code>struct sockaddr_in</code> ではないのでしょうか？なぜなら、私たちは IPv4 や IPv6 に縛られたくないからです。そこで、汎用的な構造体である <code>sockaddr_storage</code> を使用するのですが、これはどちらにも十分な大きさであることが分かっています。</p>
<p>（そこで&mldr;ここでまた疑問なのですが、なぜ <code>struct sockaddr</code> 自体はどんなアドレスに対しても十分な大きさがないのでしょうか？汎用 <code>struct sockaddr_storage</code> を汎用 <code>struct sockaddr</code> にキャストしているくらいなのに！？余計なことをしたような気がしますね。答えは、十分な大きさがなく、この時点で変更するのは問題がある、ということでしょう。だから新しいのを作ったんだ。）</p>
<p>データグラムソケットを <code>connect()</code> すれば、すべてのトランザクションに <code>send()</code> と <code>recv()</code> を使用できることを覚えておいてください。ソケット自体はデータグラムソケットであり、パケットは UDP を使用しますが、ソケットインターフェイスが自動的に宛先と送信元の情報を追加してくれるのです。</p>
<h2 id=59-close-and-shutdown---get-outta-my-face>
5.9 <code>close()</code> and <code>shutdown()</code>&mdash;Get outta my face!
<a class=anchor href=#59-close-and-shutdown---get-outta-my-face>#</a>
</h2>
<p>ふぅー 一日中データの送受信（<code>send()</code>ing と <code>recv()</code>ing）をしていて、もう限界だ。ソケットディスクリプタの接続を閉じる準備ができました。これは簡単です。通常の Unix ファイルディスクリプタの <code>close()</code> 関数を使えばいいのです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>close(sockfd);
</code></pre></div><p>これにより、それ以上のソケットへの読み書きができなくなります。リモート側でソケットの読み書きをしようとすると、エラーが発生します。</p>
<p>ソケットの閉じ方をもう少し制御したい場合は、<code>shutdown()</code> 関数を使用します。この関数では、特定の方向、あるいは両方の通信を遮断することができます (ちょうど <code>close()</code> がそうであるように)。概要:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>shutdown</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>int</span> how);
</code></pre></div><p><code>sockfd</code> はシャットダウンしたいソケットファイル記述子、<code>how</code> は以下のいずれかです。</p>
<table>
<thead>
<tr>
<th style=text-align:center><code>how</code></th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center><code>0</code></td>
<td>それ以上の受信は不可</td>
</tr>
<tr>
<td style=text-align:center><code>1</code></td>
<td>それ以上の送信は禁止</td>
</tr>
<tr>
<td style=text-align:center><code>2</code></td>
<td>それ以上の送受信は禁止(<code>close()</code>のように)</td>
</tr>
</tbody>
</table>
<p><code>shutdown()</code> は成功すると <code>0</code> を、エラーが発生すると <code>-1</code> を返します（<code>errno</code> は適宜設定されます）。</p>
<p>データグラムソケットが接続されていない状態で <code>shutdown()</code> を使用すると、それ以降の <code>send()</code> および <code>recv()</code> 呼び出しに使用できなくなります（データグラムソケットを <code>connect()</code> した場合、これらを使用できることを忘れないでください）。</p>
<p><code>shutdown()</code> は実際にはファイルディスクリプタを閉じないことに注意することが重要です。ソケットディスクリプタを解放するには、<code>close()</code> を使用する必要があります。</p>
<p>何もないんだけどね。</p>
<p>（ただし、Windows と Winsock を使用している場合は、<code>close()</code> ではなく <code>closesocket()</code> を呼び出すべきであることを忘れないでください。）</p>
<h2 id=510-getpeername---who-are-you>
5.10 <code>getpeername()</code>&mdash;Who are you?
<a class=anchor href=#510-getpeername---who-are-you>#</a>
</h2>
<p>この関数はとても簡単です。</p>
<p>あまりに簡単なので、ほとんど独自のセクションを設けなかったほどです。でも、とりあえずここに書いておきます。</p>
<p><code>getpeername()</code> 関数は、接続されたストリームソケットのもう一方の端にいるのが誰であるかを教えてくれます。その概要は</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getpeername</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>addr, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>addrlen);
</code></pre></div><p><code>sockfd</code> は接続したストリームソケットのディスクリプタ、<code>addr</code> は接続の相手側の情報を保持する <code>struct sockaddr</code>（または <code>struct sockaddr_in</code>）へのポインタ、<code>addrlen</code> は <code>int</code> へのポインタであり、 <code>sizeof *addr</code> または <code>sizeof(struct sockaddr)</code> で初期化される必要があります。</p>
<p>この関数は，エラーが発生すると <code>-1</code> を返し，それに応じて <code>errno</code> を設定します。</p>
<p>アドレスがわかれば、<code>inet_ntop()</code>、<code>getnameinfo()</code>、<code>gethostbyaddr()</code> を使って、より詳しい情報を表示したり取得したりすることができます。いいえ、ログイン名を取得することはできません。（OK、OK。相手のコンピュータで ident デーモンが動いていれば、可能です。しかし、これはこのドキュメントの範囲外です。詳しくは
<a href=https://datatracker.ietf.org/doc/html/rfc1413>RFC 1413</a> をチェックしてください。）</p>
<h2 id=511-gethostname---who-am-i>
5.11 <code>gethostname()</code>&mdash;Who am I?
<a class=anchor href=#511-gethostname---who-am-i>#</a>
</h2>
<p><code>getpeername()</code> よりもさらに簡単なのは、<code>gethostname()</code> という関数です。これは、あなたのプログラムが動作しているコンピュータの名前を返します。この名前は、後述の <code>gethostbyname()</code> でローカルマシンの IP アドレスを決定するために使用されます。</p>
<p>これ以上楽しいことはないでしょう？いくつか思いつきましたが、ソケットプログラミングには関係ないですね。とにかく、内訳はこんな感じです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>gethostname</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>hostname, size_t size);
</code></pre></div><p>引数は単純で、<code>hostname</code> はこの関数が戻ったときにホスト名を格納する文字列の配列へのポインタ、<code>size</code> はホスト名配列のバイト長です。</p>
<p>この関数は，正常に終了した場合は <code>0</code> を，エラーの場合は <code>-1</code> を返し，通常通り <code>errno</code> を設定します。</p>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
<div><a class="flex align-center" href=https://github.com/solareenlo/bgnet/commit/050bcfd0a962625450e0185d01f55cd26bf7dfe9 title="Last modified by solareenlo | Jan 5, 2022" target=_blank rel=noopener>
<img src=/bgnet/svg/calendar.svg class=book-icon alt=Calendar>
<span>Jan 5, 2022</span>
</a>
</div>
<div>
<a class="flex align-center" href=https://github.com/solareenlo/bgnet/edit/master/content/content/docs/system-calls-or-bust/_index.md target=_blank rel=noopener>
<img src=/bgnet/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span>
</a>
</div>
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#5-system-calls-or-bust>5 System Calls or Bust</a>
<ul>
<li><a href=#51-getaddrinfo---prepare-to-launch>5.1 <code>getaddrinfo()</code>&mdash;Prepare to launch!</a></li>
<li><a href=#socket>5.2 <code>socket()</code>&mdash;Get the File Descriptor!</a></li>
<li><a href=#bind>5.3 <code>bind()</code>&mdash;What port am I on?</a></li>
<li><a href=#connect>5.4 <code>connect()</code>&mdash;Hey, you!</a></li>
<li><a href=#listen>5.5 <code>listen()</code>&mdash;Will somebody please call me?</a></li>
<li><a href=#56-accept---thank-you-for-calling-port-3490>5.6 <code>accept()</code>&mdash;&ldquo;Thank you for calling port 3490.&rdquo;</a></li>
<li><a href=#sendrecv>5.7 <code>send()</code> and <code>recv()</code>&mdash;Talk to me, baby!</a></li>
<li><a href=#sendtorecv>5.8 <code>sendto()</code> and <code>recvfrom()</code>&mdash;Talk to me, DGRAM-style</a></li>
<li><a href=#59-close-and-shutdown---get-outta-my-face>5.9 <code>close()</code> and <code>shutdown()</code>&mdash;Get outta my face!</a></li>
<li><a href=#510-getpeername---who-are-you>5.10 <code>getpeername()</code>&mdash;Who are you?</a></li>
<li><a href=#511-gethostname---who-am-i>5.11 <code>gethostname()</code>&mdash;Who am I?</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>